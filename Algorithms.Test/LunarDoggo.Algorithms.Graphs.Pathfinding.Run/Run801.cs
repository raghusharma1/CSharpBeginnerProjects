// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleCSharpEnv using AI Type  and AI Model 

ROOST_METHOD_HASH=Run_a2e9436d0a
ROOST_METHOD_SIG_HASH=Run_9ce955ed80

   ########## Test-Scenarios ##########  

Based on the provided method and related code, here are several test scenarios for the `Run` method of the `DepthFirstSearch` class:

Scenario 1: Null Graph Input

Details:
  TestName: ThrowArgumentNullExceptionWhenGraphIsNull
  Description: Verify that the method throws an ArgumentNullException when a null graph is provided.
Execution:
  Arrange: Create a DepthFirstSearch instance.
  Act: Call the Run method with a null graph.
  Assert: Expect an ArgumentNullException to be thrown.
Validation:
  This test ensures that the method properly handles null input, preventing potential null reference exceptions later in the execution.

Scenario 2: Empty Graph

Details:
  TestName: ProcessEmptyGraphWithoutException
  Description: Ensure the method can handle an empty graph without throwing exceptions.
Execution:
  Arrange: Create a DepthFirstSearch instance and an empty UndirectedUnweightedGraph<DFSVertex>.
  Act: Call the Run method with the empty graph.
  Assert: Verify that no exception is thrown and the method completes successfully.
Validation:
  This test confirms that the method can handle edge cases like empty graphs gracefully.

Scenario 3: Single Vertex Graph

Details:
  TestName: ProcessSingleVertexGraphCorrectly
  Description: Verify that a graph with a single vertex is processed correctly.
Execution:
  Arrange: Create a DepthFirstSearch instance and a UndirectedUnweightedGraph<DFSVertex> with one vertex.
  Act: Call the Run method with the graph.
  Assert: Check that the vertex's StartTime and EndTime are set and not equal to -1.
Validation:
  This test ensures that the basic processing of a vertex works as expected, even in a minimal graph scenario.

Scenario 4: Linear Graph

Details:
  TestName: ProcessLinearGraphInCorrectOrder
  Description: Verify that a linear graph (vertices connected in a line) is processed in the correct order.
Execution:
  Arrange: Create a DepthFirstSearch instance and a UndirectedUnweightedGraph<DFSVertex> with multiple vertices connected linearly.
  Act: Call the Run method with the graph.
  Assert: Verify that the StartTime and EndTime of each vertex are in the correct ascending order.
Validation:
  This test checks if the depth-first traversal works correctly for a simple linear structure.

Scenario 5: Cyclic Graph

Details:
  TestName: HandleCyclicGraphWithoutInfiniteLoop
  Description: Ensure that a graph with cycles is processed without getting stuck in an infinite loop.
Execution:
  Arrange: Create a DepthFirstSearch instance and a UndirectedUnweightedGraph<DFSVertex> with a cycle.
  Act: Call the Run method with the graph.
  Assert: Verify that all vertices are processed (StartTime and EndTime set) and the method completes in a reasonable time.
Validation:
  This test confirms that the algorithm can handle cycles in the graph, which is a critical aspect of depth-first search.

Scenario 6: Disconnected Graph

Details:
  TestName: ProcessAllComponentsOfDisconnectedGraph
  Description: Verify that all components of a disconnected graph are processed.
Execution:
  Arrange: Create a DepthFirstSearch instance and a UndirectedUnweightedGraph<DFSVertex> with multiple disconnected components.
  Act: Call the Run method with the graph.
  Assert: Check that all vertices in all components have been processed (StartTime and EndTime set).
Validation:
  This test ensures that the algorithm doesn't stop after processing just one connected component but continues to process all vertices in the graph.

Scenario 7: Pre-initialized Vertex Values

Details:
  TestName: ResetPreInitializedVertexValues
  Description: Ensure that the method correctly resets any pre-initialized vertex values.
Execution:
  Arrange: Create a DepthFirstSearch instance and a UndirectedUnweightedGraph<DFSVertex>. Set some initial non-default values for StartTime, EndTime, and Predecessor for some vertices.
  Act: Call the Run method with the graph.
  Assert: Verify that all vertices have been properly processed, overwriting the initial values.
Validation:
  This test checks if the method correctly initializes all vertices before processing, regardless of their initial state.

These scenarios cover various aspects of the `Run` method, including edge cases, error handling, and different graph structures. They aim to ensure the correct functionality of the Depth-First Search algorithm implementation.


*/

// ********RoostGPT********
using NUnit.Framework;
using LunarDoggo.Datastructures.Graphs;
using LunarDoggo.Algorithms.Graphs.Pathfinding;
using System;

namespace LunarDoggo.Algorithms.Graphs.Pathfinding.Test
{
    [TestFixture]
    public class Run801Test
    {
        private DepthFirstSearch dfs;

        [SetUp]
        public void Setup()
        {
            dfs = new DepthFirstSearch();
        }

        [Test, Category("invalid")]
        public void ThrowArgumentNullExceptionWhenGraphIsNull()
        {
            Assert.Throws<ArgumentNullException>(() => dfs.Run(null));
        }

        [Test, Category("valid")]
        public void ProcessEmptyGraphWithoutException()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            Assert.DoesNotThrow(() => dfs.Run(graph));
        }

        [Test, Category("valid")]
        public void ProcessSingleVertexGraphCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var vertex = graph.AddVertex(new DFSVertex());

            dfs.Run(graph);

            Assert.That(vertex.Value.StartTime, Is.Not.EqualTo(-1));
            Assert.That(vertex.Value.EndTime, Is.Not.EqualTo(-1));
            Assert.That(vertex.Value.EndTime, Is.GreaterThan(vertex.Value.StartTime));
        }

        [Test, Category("valid")]
        public void ProcessLinearGraphInCorrectOrder()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var v1 = graph.AddVertex(new DFSVertex());
            var v2 = graph.AddVertex(new DFSVertex());
            var v3 = graph.AddVertex(new DFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);

            dfs.Run(graph);

            Assert.That(v1.Value.StartTime, Is.LessThan(v2.Value.StartTime));
            Assert.That(v2.Value.StartTime, Is.LessThan(v3.Value.StartTime));
            Assert.That(v3.Value.EndTime, Is.LessThan(v2.Value.EndTime));
            Assert.That(v2.Value.EndTime, Is.LessThan(v1.Value.EndTime));
        }

        [Test, Category("valid")]
        public void HandleCyclicGraphWithoutInfiniteLoop()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var v1 = graph.AddVertex(new DFSVertex());
            var v2 = graph.AddVertex(new DFSVertex());
            var v3 = graph.AddVertex(new DFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);
            graph.AddEdge(v3, v1);

            Assert.DoesNotThrow(() => dfs.Run(graph));

            Assert.That(v1.Value.StartTime, Is.Not.EqualTo(-1));
            Assert.That(v2.Value.StartTime, Is.Not.EqualTo(-1));
            Assert.That(v3.Value.StartTime, Is.Not.EqualTo(-1));
            Assert.That(v1.Value.EndTime, Is.Not.EqualTo(-1));
            Assert.That(v2.Value.EndTime, Is.Not.EqualTo(-1));
            Assert.That(v3.Value.EndTime, Is.Not.EqualTo(-1));
        }

        [Test, Category("valid")]
        public void ProcessAllComponentsOfDisconnectedGraph()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var v1 = graph.AddVertex(new DFSVertex());
            var v2 = graph.AddVertex(new DFSVertex());
            var v3 = graph.AddVertex(new DFSVertex());
            var v4 = graph.AddVertex(new DFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v3, v4);

            dfs.Run(graph);

            Assert.That(v1.Value.StartTime, Is.Not.EqualTo(-1));
            Assert.That(v2.Value.StartTime, Is.Not.EqualTo(-1));
            Assert.That(v3.Value.StartTime, Is.Not.EqualTo(-1));
            Assert.That(v4.Value.StartTime, Is.Not.EqualTo(-1));
            Assert.That(v1.Value.EndTime, Is.Not.EqualTo(-1));
            Assert.That(v2.Value.EndTime, Is.Not.EqualTo(-1));
            Assert.That(v3.Value.EndTime, Is.Not.EqualTo(-1));
            Assert.That(v4.Value.EndTime, Is.Not.EqualTo(-1));
        }

        [Test, Category("valid")]
        public void ResetPreInitializedVertexValues()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var v1 = graph.AddVertex(new DFSVertex { StartTime = 10, EndTime = 20 });
            var v2 = graph.AddVertex(new DFSVertex { StartTime = 30, EndTime = 40 });
            graph.AddEdge(v1, v2);

            dfs.Run(graph);

            Assert.That(v1.Value.StartTime, Is.Not.EqualTo(10));
            Assert.That(v1.Value.EndTime, Is.Not.EqualTo(20));
            Assert.That(v2.Value.StartTime, Is.Not.EqualTo(30));
            Assert.That(v2.Value.EndTime, Is.Not.EqualTo(40));
            Assert.That(v1.Value.StartTime, Is.LessThan(v1.Value.EndTime));
            Assert.That(v2.Value.StartTime, Is.LessThan(v2.Value.EndTime));
        }
    }
}
