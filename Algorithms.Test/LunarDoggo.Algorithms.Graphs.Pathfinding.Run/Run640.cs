// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleCSharpEnv using AI Type  and AI Model 

ROOST_METHOD_HASH=Run_a2e9436d0a
ROOST_METHOD_SIG_HASH=Run_9ce955ed80

   ########## Test-Scenarios ##########  

Based on the provided method and associated context, here are several test scenarios for the `Run` method of the `DepthFirstSearch` class:

Scenario 1: Null Graph Input

Details:
  TestName: ThrowArgumentNullExceptionWhenGraphIsNull
  Description: Verify that the method throws an ArgumentNullException when a null graph is provided.
Execution:
  Arrange: Create a DepthFirstSearch instance with no graph.
  Act: Call the Run method with a null graph.
  Assert: Expect an ArgumentNullException to be thrown.
Validation:
  This test ensures that the method properly handles null input, preventing null reference exceptions later in the execution.

Scenario 2: Empty Graph

Details:
  TestName: ProcessEmptyGraphWithoutException
  Description: Ensure the method can handle an empty graph without throwing exceptions.
Execution:
  Arrange: Create a DepthFirstSearch instance and an empty IGraph<DFSVertex>.
  Act: Call the Run method with the empty graph.
  Assert: Verify that no exception is thrown and the method completes successfully.
Validation:
  This test confirms that the method can handle edge cases like empty graphs gracefully.

Scenario 3: Single Vertex Graph

Details:
  TestName: ProcessSingleVertexGraphCorrectly
  Description: Check if the method correctly processes a graph with only one vertex.
Execution:
  Arrange: Create a DepthFirstSearch instance and an IGraph<DFSVertex> with a single vertex.
  Act: Call the Run method with this graph.
  Assert: Verify that the vertex's StartTime and EndTime are set and Processed is true.
Validation:
  This test ensures that the basic functionality works for the simplest possible graph.

Scenario 4: Disconnected Graph

Details:
  TestName: ProcessAllVerticesInDisconnectedGraph
  Description: Verify that all vertices in a disconnected graph are processed.
Execution:
  Arrange: Create a DepthFirstSearch instance and an IGraph<DFSVertex> with multiple disconnected vertices.
  Act: Call the Run method with this graph.
  Assert: Check that all vertices have been processed (Processed is true for all).
Validation:
  This test confirms that the method handles disconnected graphs correctly, processing all vertices regardless of connectivity.

Scenario 5: Cyclic Graph

Details:
  TestName: HandleCyclicGraphWithoutInfiniteLoop
  Description: Ensure the method can process a graph containing cycles without entering an infinite loop.
Execution:
  Arrange: Create a DepthFirstSearch instance and an IGraph<DFSVertex> with cycles.
  Act: Call the Run method with this cyclic graph.
  Assert: Verify that all vertices are processed and the method terminates.
Validation:
  This test checks that the algorithm can handle cycles in the graph, which is a common edge case in graph traversal.

Scenario 6: Large Graph Performance

Details:
  TestName: ProcessLargeGraphWithinReasonableTime
  Description: Test the performance of the method with a large graph.
Execution:
  Arrange: Create a DepthFirstSearch instance and a large IGraph<DFSVertex> (e.g., 10000 vertices).
  Act: Call the Run method with this large graph, measuring execution time.
  Assert: Verify that the method completes within a reasonable time frame and all vertices are processed.
Validation:
  This test ensures that the method scales well with larger inputs and doesn't have unexpected performance issues.

Scenario 7: Correct Start and End Times

Details:
  TestName: AssignCorrectStartAndEndTimesToVertices
  Description: Verify that the start and end times for each vertex are assigned correctly and in the right order.
Execution:
  Arrange: Create a DepthFirstSearch instance and an IGraph<DFSVertex> with a known structure.
  Act: Call the Run method with this graph.
  Assert: Check that the start and end times for each vertex are consistent with DFS traversal order.
Validation:
  This test ensures that the core functionality of DFS (assigning discovery and finish times) is working correctly.

Scenario 8: Predecessor Assignment

Details:
  TestName: AssignCorrectPredecessorsToVertices
  Description: Check if the predecessor for each vertex is correctly assigned during the traversal.
Execution:
  Arrange: Create a DepthFirstSearch instance and an IGraph<DFSVertex> with a known structure.
  Act: Call the Run method with this graph.
  Assert: Verify that each vertex (except the start vertex) has the correct predecessor assigned.
Validation:
  This test confirms that the method correctly builds the DFS tree by assigning predecessors, which is crucial for path reconstruction and other graph algorithms.

These scenarios cover various aspects of the `Run` method, including edge cases, error handling, and core functionality. They should provide a comprehensive test suite for the DepthFirstSearch class.


*/

// ********RoostGPT********
using NUnit.Framework;
using LunarDoggo.Datastructures.Graphs;
using LunarDoggo.Algorithms.Graphs.Pathfinding;
using System;
using System.Linq;

namespace LunarDoggo.Algorithms.Graphs.Pathfinding.Test
{
    [TestFixture]
    public class Run640Test
    {
        private DepthFirstSearch dfs;

        [SetUp]
        public void Setup()
        {
            dfs = new DepthFirstSearch();
        }

        [Test, Category("invalid")]
        public void ThrowArgumentNullExceptionWhenGraphIsNull()
        {
            Assert.Throws<ArgumentNullException>(() => dfs.Run(null));
        }

        [Test, Category("valid")]
        public void ProcessEmptyGraphWithoutException()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            Assert.DoesNotThrow(() => dfs.Run(graph));
        }

        [Test, Category("valid")]
        public void ProcessSingleVertexGraphCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var vertex = graph.AddVertex(new DFSVertex());

            dfs.Run(graph);

            Assert.That(vertex.Value.Processed, Is.True);
            Assert.That(vertex.Value.StartTime, Is.GreaterThanOrEqualTo(0));
            Assert.That(vertex.Value.EndTime, Is.GreaterThan(vertex.Value.StartTime));
        }

        [Test, Category("valid")]
        public void ProcessAllVerticesInDisconnectedGraph()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var v1 = graph.AddVertex(new DFSVertex());
            var v2 = graph.AddVertex(new DFSVertex());
            var v3 = graph.AddVertex(new DFSVertex());

            dfs.Run(graph);

            Assert.That(graph.Vertices.All(v => v.Value.Processed), Is.True);
        }

        [Test, Category("valid")]
        public void HandleCyclicGraphWithoutInfiniteLoop()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var v1 = graph.AddVertex(new DFSVertex());
            var v2 = graph.AddVertex(new DFSVertex());
            var v3 = graph.AddVertex(new DFSVertex());

            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);
            graph.AddEdge(v3, v1);

            Assert.DoesNotThrow(() => dfs.Run(graph));
            Assert.That(graph.Vertices.All(v => v.Value.Processed), Is.True);
        }

        [Test, Category("valid")]
        public void ProcessLargeGraphWithinReasonableTime()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            for (int i = 0; i < 10000; i++)
            {
                graph.AddVertex(new DFSVertex());
            }

            var startTime = DateTime.Now;
            dfs.Run(graph);
            var endTime = DateTime.Now;

            Assert.That((endTime - startTime).TotalSeconds, Is.LessThan(5));
            Assert.That(graph.Vertices.All(v => v.Value.Processed), Is.True);
        }

        [Test, Category("valid")]
        public void AssignCorrectStartAndEndTimesToVertices()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var v1 = graph.AddVertex(new DFSVertex());
            var v2 = graph.AddVertex(new DFSVertex());
            var v3 = graph.AddVertex(new DFSVertex());

            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);

            dfs.Run(graph);

            Assert.That(v1.Value.StartTime, Is.LessThan(v1.Value.EndTime));
            Assert.That(v2.Value.StartTime, Is.LessThan(v2.Value.EndTime));
            Assert.That(v3.Value.StartTime, Is.LessThan(v3.Value.EndTime));

            Assert.That(v1.Value.StartTime, Is.LessThan(v2.Value.StartTime));
            Assert.That(v2.Value.StartTime, Is.LessThan(v3.Value.StartTime));
            Assert.That(v3.Value.EndTime, Is.LessThan(v2.Value.EndTime));
            Assert.That(v2.Value.EndTime, Is.LessThan(v1.Value.EndTime));
        }

        [Test, Category("valid")]
        public void AssignCorrectPredecessorsToVertices()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var v1 = graph.AddVertex(new DFSVertex());
            var v2 = graph.AddVertex(new DFSVertex());
            var v3 = graph.AddVertex(new DFSVertex());

            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);

            dfs.Run(graph);

            Assert.That(v1.Value.Predecessor, Is.Null);
            Assert.That(v2.Value.Predecessor, Is.EqualTo(v1));
            Assert.That(v3.Value.Predecessor, Is.EqualTo(v2));
        }
    }
}
