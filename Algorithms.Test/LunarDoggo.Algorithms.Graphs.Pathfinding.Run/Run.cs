// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleCSharpEnv using AI Type  and AI Model 

ROOST_METHOD_HASH=Run_bbc3b7dcfd
ROOST_METHOD_SIG_HASH=Run_23f9485d25

   ########## Test-Scenarios ##########  

Based on the provided method and related code, I'll generate test scenarios for the `Run` method of the `BreadthFirstSearch` class. Here are the test scenarios:

Scenario 1: Null Graph Handling

Details:
  TestName: ThrowArgumentNullExceptionWhenGraphIsNull
  Description: Verify that the method throws an ArgumentNullException when a null graph is passed.
Execution:
  Arrange: Create a BreadthFirstSearch instance and set up a null graph and a valid start vertex.
  Act: Call the Run method with the null graph and valid start vertex.
  Assert: Verify that an ArgumentNullException is thrown with the correct message.
Validation:
  This test ensures that the method properly handles null input for the graph parameter, maintaining robustness and preventing null reference exceptions later in the execution.

Scenario 2: Basic BFS Traversal

Details:
  TestName: CorrectlyTraversesSimpleGraph
  Description: Ensure that the BFS algorithm correctly traverses a simple graph and sets the correct distances and predecessors.
Execution:
  Arrange: Create a simple graph with known structure, initialize a BreadthFirstSearch instance, and choose a start vertex.
  Act: Call the Run method with the created graph and start vertex.
  Assert: Verify that each vertex has the correct distance and predecessor set.
Validation:
  This test confirms that the basic BFS algorithm is working correctly, visiting vertices in the right order and setting appropriate distances and predecessors.

Scenario 3: Isolated Vertices Handling

Details:
  TestName: HandlesGraphWithIsolatedVertices
  Description: Check if the algorithm correctly handles a graph with isolated vertices.
Execution:
  Arrange: Create a graph with some connected vertices and some isolated vertices, initialize a BreadthFirstSearch instance, and choose a start vertex.
  Act: Call the Run method with the created graph and start vertex.
  Assert: Verify that connected vertices have correct distances and predecessors, while isolated vertices remain unprocessed.
Validation:
  This test ensures that the algorithm works correctly in graphs that are not fully connected, which is a common real-world scenario.

Scenario 4: Cyclic Graph Traversal

Details:
  TestName: CorrectlyTraversesCyclicGraph
  Description: Ensure that the BFS algorithm correctly handles cycles in the graph without getting stuck in infinite loops.
Execution:
  Arrange: Create a graph with cycles, initialize a BreadthFirstSearch instance, and choose a start vertex.
  Act: Call the Run method with the created graph and start vertex.
  Assert: Verify that all vertices are processed exactly once and have correct distances and predecessors.
Validation:
  This test confirms that the algorithm can handle cyclic graphs, which is crucial for its correctness and termination.

Scenario 5: Large Graph Performance

Details:
  TestName: PerformsEfficientlyOnLargeGraph
  Description: Verify that the BFS algorithm performs efficiently on a large graph within a reasonable time frame.
Execution:
  Arrange: Create a large graph with many vertices and edges, initialize a BreadthFirstSearch instance, and choose a start vertex.
  Act: Measure the time taken to call and complete the Run method with the large graph and start vertex.
  Assert: Verify that the execution time is within acceptable limits and all vertices are correctly processed.
Validation:
  This test ensures that the algorithm's performance scales well with larger graphs, which is important for real-world applications.

Scenario 6: Start Vertex Initialization

Details:
  TestName: CorrectlyInitializesStartVertex
  Description: Ensure that the start vertex is correctly initialized with distance 0 and no predecessor.
Execution:
  Arrange: Create a graph, initialize a BreadthFirstSearch instance, and choose a start vertex.
  Act: Call the Run method with the created graph and start vertex.
  Assert: Verify that the start vertex has a distance of 0 and null predecessor.
Validation:
  This test confirms that the algorithm correctly sets up the starting point for the BFS traversal.

Scenario 7: All Vertices Processed

Details:
  TestName: ProcessesAllReachableVertices
  Description: Verify that all vertices reachable from the start vertex are processed.
Execution:
  Arrange: Create a connected graph, initialize a BreadthFirstSearch instance, and choose a start vertex.
  Act: Call the Run method with the created graph and start vertex.
  Assert: Check that all vertices in the graph have been processed (Processed flag is true).
Validation:
  This test ensures that the BFS algorithm reaches all connected vertices in the graph, which is a fundamental property of BFS.

These test scenarios cover various aspects of the BreadthFirstSearch.Run method, including error handling, correctness of traversal, handling of different graph structures, and performance considerations.


*/

// ********RoostGPT********
using NUnit.Framework;
using LunarDoggo.Datastructures.Graphs;
using LunarDoggo.Algorithms.Graphs.Pathfinding;
using System;
using System.Linq;

namespace LunarDoggo.Algorithms.Graphs.Pathfinding.Test
{
    [TestFixture]
    public class RunTest
    {
        [Test, Category("invalid")]
        public void ThrowArgumentNullExceptionWhenGraphIsNull()
        {
            var bfs = new BreadthFirstSearch();
            var startVertex = new Vertex<BFSVertex>(0, new BFSVertex());

            Assert.Throws<ArgumentNullException>(() => bfs.Run(null, startVertex));
        }

        [Test, Category("valid")]
        public void CorrectlyTraversesSimpleGraph()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);

            var bfs = new BreadthFirstSearch();
            bfs.Run(graph, v1);

            Assert.AreEqual(0, v1.Value.Distance);
            Assert.AreEqual(1, v2.Value.Distance);
            Assert.AreEqual(2, v3.Value.Distance);
            Assert.IsNull(v1.Value.Predecessor);
            Assert.AreEqual(v1, v2.Value.Predecessor);
            Assert.AreEqual(v2, v3.Value.Predecessor);
        }

        [Test, Category("valid")]
        public void HandlesGraphWithIsolatedVertices()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            var v4 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);

            var bfs = new BreadthFirstSearch();
            bfs.Run(graph, v1);

            Assert.AreEqual(0, v1.Value.Distance);
            Assert.AreEqual(1, v2.Value.Distance);
            Assert.AreEqual(int.MaxValue, v3.Value.Distance);
            Assert.AreEqual(int.MaxValue, v4.Value.Distance);
            Assert.IsFalse(v3.Value.Processed);
            Assert.IsFalse(v4.Value.Processed);
        }

        [Test, Category("valid")]
        public void CorrectlyTraversesCyclicGraph()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);
            graph.AddEdge(v3, v1);

            var bfs = new BreadthFirstSearch();
            bfs.Run(graph, v1);

            Assert.AreEqual(0, v1.Value.Distance);
            Assert.AreEqual(1, v2.Value.Distance);
            Assert.AreEqual(1, v3.Value.Distance);
            Assert.IsTrue(v1.Value.Processed);
            Assert.IsTrue(v2.Value.Processed);
            Assert.IsTrue(v3.Value.Processed);
        }

        [Test, Category("valid")]
        public void PerformsEfficientlyOnLargeGraph()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertices = Enumerable.Range(0, 10000).Select(_ => graph.AddVertex(new BFSVertex())).ToList();
            for (int i = 0; i < vertices.Count - 1; i++)
            {
                graph.AddEdge(vertices[i], vertices[i + 1]);
            }

            var bfs = new BreadthFirstSearch();
            var startTime = DateTime.Now;
            bfs.Run(graph, vertices[0]);
            var endTime = DateTime.Now;

            Assert.Less((endTime - startTime).TotalSeconds, 5);
            Assert.IsTrue(vertices.All(v => v.Value.Processed));
        }

        [Test, Category("valid")]
        public void CorrectlyInitializesStartVertex()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var start = graph.AddVertex(new BFSVertex());
            var other = graph.AddVertex(new BFSVertex());
            graph.AddEdge(start, other);

            var bfs = new BreadthFirstSearch();
            bfs.Run(graph, start);

            Assert.AreEqual(0, start.Value.Distance);
            Assert.IsNull(start.Value.Predecessor);
            Assert.IsTrue(start.Value.Processed);
        }

        [Test, Category("valid")]
        public void ProcessesAllReachableVertices()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            var v4 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);
            graph.AddEdge(v3, v4);

            var bfs = new BreadthFirstSearch();
            bfs.Run(graph, v1);

            Assert.IsTrue(graph.Vertices.All(v => v.Value.Processed));
        }
    }
}
