// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleCSharpEnv using AI Type  and AI Model 

ROOST_METHOD_HASH=Run_bbc3b7dcfd
ROOST_METHOD_SIG_HASH=Run_23f9485d25

   ########## Test-Scenarios ##########  

Based on the provided method and related code, here are several test scenarios for the `Run` method of the `BreadthFirstSearch` class:

Scenario 1: Null Graph Handling

Details:
  TestName: ThrowsArgumentNullExceptionWhenGraphIsNull
  Description: Verify that the method throws an ArgumentNullException when a null graph is passed.

Execution:
  Arrange: Create a BreadthFirstSearch instance and a null graph.
  Act: Call the Run method with the null graph and a valid start vertex.
  Assert: Verify that an ArgumentNullException is thrown.

Validation:
  This test ensures that the method properly handles null input for the graph parameter, maintaining robustness and preventing null reference exceptions later in the execution.

Scenario 2: Single Vertex Graph

Details:
  TestName: ProcessesSingleVertexGraphCorrectly
  Description: Ensure the method correctly processes a graph with only one vertex.

Execution:
  Arrange: Create a graph with a single vertex and initialize a BreadthFirstSearch instance.
  Act: Run the BFS algorithm on this graph.
  Assert: Verify that the single vertex is processed (Processed = true) and its Distance is 0.

Validation:
  This test confirms that the BFS algorithm works correctly for the simplest possible graph, setting the base case for more complex scenarios.

Scenario 3: Linear Graph Traversal

Details:
  TestName: CorrectlyTraversesLinearGraph
  Description: Verify that the BFS algorithm correctly traverses a linear graph (each vertex connected to at most two others).

Execution:
  Arrange: Create a linear graph with multiple vertices (e.g., A -> B -> C -> D).
  Act: Run the BFS algorithm starting from vertex A.
  Assert: Check that all vertices are processed and their distances are set correctly (A:0, B:1, C:2, D:3).

Validation:
  This test ensures that the BFS algorithm correctly calculates distances and processes vertices in a simple linear structure.

Scenario 4: Cyclic Graph Handling

Details:
  TestName: HandlesGraphWithCyclesCorrectly
  Description: Ensure the BFS algorithm correctly processes a graph containing cycles without getting stuck in an infinite loop.

Execution:
  Arrange: Create a graph with cycles (e.g., A -> B -> C -> A).
  Act: Run the BFS algorithm starting from any vertex.
  Assert: Verify that all vertices are processed exactly once and their distances are set to the shortest path from the start.

Validation:
  This test confirms that the algorithm can handle cyclic graphs without revisiting already processed vertices, which is crucial for its correctness and efficiency.

Scenario 5: Disconnected Graph Components

Details:
  TestName: ProcessesOnlyReachableVerticesInDisconnectedGraph
  Description: Verify that the BFS algorithm only processes vertices reachable from the start vertex in a disconnected graph.

Execution:
  Arrange: Create a graph with two disconnected components.
  Act: Run the BFS algorithm starting from a vertex in one component.
  Assert: Check that all vertices in the start component are processed, while vertices in the other component remain unprocessed.

Validation:
  This test ensures that the BFS algorithm correctly handles disconnected graphs, processing only the reachable vertices from the given start point.

Scenario 6: Correct Distance Calculation

Details:
  TestName: CalculatesCorrectDistancesInComplexGraph
  Description: Ensure that the BFS algorithm calculates correct distances in a more complex graph structure.

Execution:
  Arrange: Create a complex graph with multiple paths between vertices.
  Act: Run the BFS algorithm from a chosen start vertex.
  Assert: Verify that the distance to each vertex represents the shortest path from the start vertex.

Validation:
  This test confirms that the BFS algorithm correctly identifies the shortest paths in more complex graph structures, which is a key property of breadth-first search.

Scenario 7: Predecessor Assignment

Details:
  TestName: AssignsPredecessorsCorrectly
  Description: Verify that the BFS algorithm correctly assigns predecessors to each processed vertex.

Execution:
  Arrange: Create a graph with a known structure.
  Act: Run the BFS algorithm from a specific start vertex.
  Assert: Check that each processed vertex (except the start) has a predecessor assigned, and that the predecessor is on the shortest path from the start.

Validation:
  This test ensures that the predecessor information is correctly maintained, which is crucial for reconstructing paths or understanding the traversal order.

Scenario 8: Large Graph Performance

Details:
  TestName: CompletesInReasonableTimeForLargeGraph
  Description: Ensure that the BFS algorithm completes within a reasonable time frame for a large graph.

Execution:
  Arrange: Create a large graph with many vertices and edges.
  Act: Run the BFS algorithm and measure the execution time.
  Assert: Verify that the execution completes within an expected time frame and that all reachable vertices are processed.

Validation:
  This test checks the algorithm's performance and scalability, ensuring it remains efficient for larger datasets.

These scenarios cover various aspects of the BreadthFirstSearch algorithm, including edge cases, error handling, and different graph structures. They aim to thoroughly test the correctness and robustness of the implementation.


*/

// ********RoostGPT********
using NUnit.Framework;
using LunarDoggo.Datastructures.Graphs;
using LunarDoggo.Algorithms.Graphs.Pathfinding;
using System;
using System.Linq;

namespace LunarDoggo.Algorithms.Graphs.Pathfinding.Test
{
    [TestFixture]
    public class RunTest
    {
        [Test, Category("invalid")]
        public void ThrowsArgumentNullExceptionWhenGraphIsNull()
        {
            var bfs = new BreadthFirstSearch();
            var start = new Vertex<BFSVertex>(0, new BFSVertex());

            Assert.Throws<ArgumentNullException>(() => bfs.Run(null, start));
        }

        [Test, Category("valid")]
        public void ProcessesSingleVertexGraphCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertex = graph.AddVertex(new BFSVertex());
            var bfs = new BreadthFirstSearch();

            bfs.Run(graph, vertex);

            Assert.IsTrue(vertex.Value.Processed);
            Assert.AreEqual(0, vertex.Value.Distance);
        }

        [Test, Category("valid")]
        public void CorrectlyTraversesLinearGraph()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var a = graph.AddVertex(new BFSVertex());
            var b = graph.AddVertex(new BFSVertex());
            var c = graph.AddVertex(new BFSVertex());
            var d = graph.AddVertex(new BFSVertex());

            graph.AddEdge(a, b);
            graph.AddEdge(b, c);
            graph.AddEdge(c, d);

            var bfs = new BreadthFirstSearch();
            bfs.Run(graph, a);

            Assert.AreEqual(0, a.Value.Distance);
            Assert.AreEqual(1, b.Value.Distance);
            Assert.AreEqual(2, c.Value.Distance);
            Assert.AreEqual(3, d.Value.Distance);
        }

        [Test, Category("valid")]
        public void HandlesGraphWithCyclesCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var a = graph.AddVertex(new BFSVertex());
            var b = graph.AddVertex(new BFSVertex());
            var c = graph.AddVertex(new BFSVertex());

            graph.AddEdge(a, b);
            graph.AddEdge(b, c);
            graph.AddEdge(c, a);

            var bfs = new BreadthFirstSearch();
            bfs.Run(graph, a);

            Assert.IsTrue(graph.Vertices.All(v => v.Value.Processed));
            Assert.AreEqual(0, a.Value.Distance);
            Assert.AreEqual(1, b.Value.Distance);
            Assert.AreEqual(1, c.Value.Distance);
        }

        [Test, Category("valid")]
        public void ProcessesOnlyReachableVerticesInDisconnectedGraph()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var a = graph.AddVertex(new BFSVertex());
            var b = graph.AddVertex(new BFSVertex());
            var c = graph.AddVertex(new BFSVertex());
            var d = graph.AddVertex(new BFSVertex());

            graph.AddEdge(a, b);
            graph.AddEdge(c, d);

            var bfs = new BreadthFirstSearch();
            bfs.Run(graph, a);

            Assert.IsTrue(a.Value.Processed);
            Assert.IsTrue(b.Value.Processed);
            Assert.IsFalse(c.Value.Processed);
            Assert.IsFalse(d.Value.Processed);
        }

        [Test, Category("valid")]
        public void CalculatesCorrectDistancesInComplexGraph()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var a = graph.AddVertex(new BFSVertex());
            var b = graph.AddVertex(new BFSVertex());
            var c = graph.AddVertex(new BFSVertex());
            var d = graph.AddVertex(new BFSVertex());
            var e = graph.AddVertex(new BFSVertex());

            graph.AddEdge(a, b);
            graph.AddEdge(a, c);
            graph.AddEdge(b, d);
            graph.AddEdge(c, d);
            graph.AddEdge(d, e);

            var bfs = new BreadthFirstSearch();
            bfs.Run(graph, a);

            Assert.AreEqual(0, a.Value.Distance);
            Assert.AreEqual(1, b.Value.Distance);
            Assert.AreEqual(1, c.Value.Distance);
            Assert.AreEqual(2, d.Value.Distance);
            Assert.AreEqual(3, e.Value.Distance);
        }

        [Test, Category("valid")]
        public void AssignsPredecessorsCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var a = graph.AddVertex(new BFSVertex());
            var b = graph.AddVertex(new BFSVertex());
            var c = graph.AddVertex(new BFSVertex());

            graph.AddEdge(a, b);
            graph.AddEdge(b, c);

            var bfs = new BreadthFirstSearch();
            bfs.Run(graph, a);

            Assert.IsNull(a.Value.Predecessor);
            Assert.AreEqual(a, b.Value.Predecessor);
            Assert.AreEqual(b, c.Value.Predecessor);
        }

        [Test, Category("valid")]
        public void CompletesInReasonableTimeForLargeGraph()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertices = Enumerable.Range(0, 10000).Select(_ => graph.AddVertex(new BFSVertex())).ToList();

            for (int i = 0; i < vertices.Count - 1; i++)
            {
                graph.AddEdge(vertices[i], vertices[i + 1]);
            }

            var bfs = new BreadthFirstSearch();
            var startTime = DateTime.Now;

            bfs.Run(graph, vertices[0]);

            var endTime = DateTime.Now;
            var duration = (endTime - startTime).TotalSeconds;

            Assert.Less(duration, 5, "BFS took too long to complete");
            Assert.IsTrue(vertices.All(v => v.Value.Processed));
        }
    }
}
