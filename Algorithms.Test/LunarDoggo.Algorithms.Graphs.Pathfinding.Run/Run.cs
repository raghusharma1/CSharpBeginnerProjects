// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleCSharpEnv using AI Type  and AI Model 

ROOST_METHOD_HASH=Run_bbc3b7dcfd
ROOST_METHOD_SIG_HASH=Run_23f9485d25

   ########## Test-Scenarios ##########  

Based on the provided method and related code, here are several test scenarios for the `Run` method of the `BreadthFirstSearch` class:

Scenario 1: Null Graph Handling

Details:
  TestName: ThrowsArgumentNullExceptionWhenGraphIsNull
  Description: Verify that the method throws an ArgumentNullException when a null graph is provided.
Execution:
  Arrange: Create a BreadthFirstSearch instance and prepare a null graph and a valid start vertex.
  Act: Call the Run method with the null graph and valid start vertex.
  Assert: Verify that an ArgumentNullException is thrown with the correct message.
Validation:
  This test ensures that the method properly handles null input for the graph parameter, maintaining robustness and preventing null reference exceptions later in the execution.

Scenario 2: Basic BFS Traversal

Details:
  TestName: CorrectlyTraversesSimpleGraph
  Description: Ensure that the BFS algorithm correctly traverses a simple graph and sets the correct distances and predecessors.
Execution:
  Arrange: Create a simple graph with known structure, initialize a BreadthFirstSearch instance, and choose a start vertex.
  Act: Call the Run method with the created graph and start vertex.
  Assert: Verify that each vertex has the correct distance and predecessor set.
Validation:
  This test confirms that the basic BFS traversal works as expected, correctly identifying the shortest path to each vertex from the start vertex.

Scenario 3: Isolated Vertices Handling

Details:
  TestName: HandlesGraphWithIsolatedVertices
  Description: Check if the algorithm correctly handles a graph with isolated vertices.
Execution:
  Arrange: Create a graph with some connected vertices and some isolated vertices.
  Act: Run the BFS algorithm on this graph.
  Assert: Verify that isolated vertices have maximum distance and null predecessors.
Validation:
  This test ensures that the algorithm correctly handles graphs that are not fully connected, which is a common edge case in graph problems.

Scenario 4: Cyclic Graph Traversal

Details:
  TestName: CorrectlyTraversesCyclicGraph
  Description: Ensure that the BFS algorithm correctly handles graphs with cycles.
Execution:
  Arrange: Create a graph with at least one cycle, initialize BFS, and choose a start vertex.
  Act: Run the BFS algorithm.
  Assert: Check that all vertices are processed and have correct distances despite the presence of cycles.
Validation:
  This test verifies that the algorithm doesn't get stuck in infinite loops when encountering cycles, which is crucial for its correctness and termination.

Scenario 5: Large Graph Performance

Details:
  TestName: PerformsEfficientlyOnLargeGraph
  Description: Test the performance of the BFS algorithm on a large graph.
Execution:
  Arrange: Generate a large graph with many vertices and edges.
  Act: Run the BFS algorithm and measure the execution time.
  Assert: Verify that the execution time is within acceptable bounds for the graph size.
Validation:
  This test ensures that the implementation remains efficient for larger datasets, which is important for real-world applications.

Scenario 6: Start Vertex Initialization

Details:
  TestName: CorrectlyInitializesStartVertex
  Description: Verify that the start vertex is correctly initialized with distance 0 and no predecessor.
Execution:
  Arrange: Create a graph and choose a start vertex.
  Act: Run the BFS algorithm.
  Assert: Check that the start vertex has a distance of 0 and null predecessor.
Validation:
  This test ensures that the starting conditions for the BFS are correctly set, which is crucial for the algorithm's correctness.

Scenario 7: All Vertices Processed

Details:
  TestName: ProcessesAllReachableVertices
  Description: Ensure that all vertices reachable from the start vertex are processed.
Execution:
  Arrange: Create a connected graph with multiple vertices.
  Act: Run the BFS algorithm from any vertex.
  Assert: Verify that all vertices have been processed (Processed flag is true).
Validation:
  This test confirms that the BFS algorithm reaches all connected vertices, which is a fundamental property of the algorithm.

These test scenarios cover various aspects of the BreadthFirstSearch implementation, including basic functionality, edge cases, and performance considerations.


*/

// ********RoostGPT********
using NUnit.Framework;
using LunarDoggo.Datastructures.Graphs;
using LunarDoggo.Algorithms.Graphs.Pathfinding;
using System;
using System.Linq;

namespace LunarDoggo.Algorithms.Graphs.Pathfinding.Test
{
    [TestFixture]
    public class RunTest
    {
        [Test, Category("invalid")]
        public void ThrowsArgumentNullExceptionWhenGraphIsNull()
        {
            var bfs = new BreadthFirstSearch();
            var startVertex = new Vertex<BFSVertex>(0, new BFSVertex());

            Assert.Throws<ArgumentNullException>(() => bfs.Run(null, startVertex));
        }

        [Test, Category("valid")]
        public void CorrectlyTraversesSimpleGraph()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);

            var bfs = new BreadthFirstSearch();
            bfs.Run(graph, v1);

            Assert.AreEqual(0, v1.Value.Distance);
            Assert.AreEqual(1, v2.Value.Distance);
            Assert.AreEqual(2, v3.Value.Distance);
            Assert.IsNull(v1.Value.Predecessor);
            Assert.AreEqual(v1, v2.Value.Predecessor);
            Assert.AreEqual(v2, v3.Value.Predecessor);
        }

        [Test, Category("boundary")]
        public void HandlesGraphWithIsolatedVertices()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var isolated = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);

            var bfs = new BreadthFirstSearch();
            bfs.Run(graph, v1);

            Assert.AreEqual(0, v1.Value.Distance);
            Assert.AreEqual(1, v2.Value.Distance);
            Assert.AreEqual(int.MaxValue, isolated.Value.Distance);
            Assert.IsNull(isolated.Value.Predecessor);
            Assert.IsFalse(isolated.Value.Processed);
        }

        [Test, Category("valid")]
        public void CorrectlyTraversesCyclicGraph()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);
            graph.AddEdge(v3, v1);

            var bfs = new BreadthFirstSearch();
            bfs.Run(graph, v1);

            Assert.AreEqual(0, v1.Value.Distance);
            Assert.AreEqual(1, v2.Value.Distance);
            Assert.AreEqual(1, v3.Value.Distance);
            Assert.IsTrue(v1.Value.Processed);
            Assert.IsTrue(v2.Value.Processed);
            Assert.IsTrue(v3.Value.Processed);
        }

        [Test, Category("integration")]
        public void PerformsEfficientlyOnLargeGraph()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertices = Enumerable.Range(0, 10000).Select(_ => graph.AddVertex(new BFSVertex())).ToList();
            
            for (int i = 0; i < vertices.Count - 1; i++)
            {
                graph.AddEdge(vertices[i], vertices[i + 1]);
            }

            var bfs = new BreadthFirstSearch();
            var startTime = DateTime.Now;
            bfs.Run(graph, vertices[0]);
            var endTime = DateTime.Now;

            Assert.Less((endTime - startTime).TotalSeconds, 5); // Assuming 5 seconds is an acceptable upper bound
            Assert.AreEqual(vertices.Count - 1, vertices.Last().Value.Distance);
        }

        [Test, Category("valid")]
        public void CorrectlyInitializesStartVertex()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var start = graph.AddVertex(new BFSVertex());
            graph.AddVertex(new BFSVertex());

            var bfs = new BreadthFirstSearch();
            bfs.Run(graph, start);

            Assert.AreEqual(0, start.Value.Distance);
            Assert.IsNull(start.Value.Predecessor);
            Assert.IsTrue(start.Value.Processed);
        }

        [Test, Category("valid")]
        public void ProcessesAllReachableVertices()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            var v4 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);
            graph.AddEdge(v3, v4);

            var bfs = new BreadthFirstSearch();
            bfs.Run(graph, v1);

            Assert.IsTrue(graph.Vertices.All(v => v.Value.Processed));
        }
    }
}
