// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleCSharpEnv using AI Type  and AI Model 

ROOST_METHOD_HASH=Run_bbc3b7dcfd
ROOST_METHOD_SIG_HASH=Run_23f9485d25

   ########## Test-Scenarios ##########  

Based on the provided method and related code, here are several test scenarios for the `Run` method of the `BreadthFirstSearch` class:

Scenario 1: Valid Graph and Start Vertex

Details:
  TestName: RunBFSWithValidGraphAndStartVertex
  Description: Test the BFS algorithm with a valid graph and start vertex to ensure correct traversal and distance calculation.

Execution:
  Arrange: Create a valid graph with multiple vertices and edges, and select a start vertex.
  Act: Call the Run method with the created graph and start vertex.
  Assert: Check if all vertices are processed, distances are correctly set, and predecessors are properly assigned.

Validation:
  This test verifies that the BFS algorithm correctly traverses the graph, assigns distances, and sets predecessors for all reachable vertices from the start vertex.

Scenario 2: Null Graph Input

Details:
  TestName: RunBFSWithNullGraphThrowsArgumentNullException
  Description: Test that the method throws an ArgumentNullException when a null graph is provided.

Execution:
  Arrange: Prepare a null graph and a valid start vertex.
  Act: Call the Run method with the null graph and valid start vertex.
  Assert: Verify that an ArgumentNullException is thrown with the correct error message.

Validation:
  This test ensures that the method properly handles null input for the graph parameter and throws the expected exception.

Scenario 3: Disconnected Graph

Details:
  TestName: RunBFSWithDisconnectedGraph
  Description: Test the BFS algorithm on a graph with disconnected components.

Execution:
  Arrange: Create a graph with multiple disconnected components and select a start vertex in one component.
  Act: Call the Run method with the created graph and start vertex.
  Assert: Verify that vertices in the same component as the start vertex are processed, while vertices in other components remain unprocessed.

Validation:
  This test checks if the BFS algorithm correctly handles disconnected graphs by only processing reachable vertices.

Scenario 4: Single Vertex Graph

Details:
  TestName: RunBFSWithSingleVertexGraph
  Description: Test the BFS algorithm on a graph containing only one vertex.

Execution:
  Arrange: Create a graph with a single vertex and use it as the start vertex.
  Act: Call the Run method with the single-vertex graph and start vertex.
  Assert: Verify that the vertex is processed, its distance is 0, and it has no predecessor.

Validation:
  This test ensures that the BFS algorithm works correctly for the edge case of a graph with only one vertex.

Scenario 5: Cyclic Graph

Details:
  TestName: RunBFSWithCyclicGraph
  Description: Test the BFS algorithm on a graph containing cycles to ensure correct traversal.

Execution:
  Arrange: Create a graph with cycles and select a start vertex.
  Act: Call the Run method with the cyclic graph and start vertex.
  Assert: Verify that all vertices are processed, distances are correct, and the algorithm doesn't enter an infinite loop.

Validation:
  This test checks if the BFS algorithm correctly handles cyclic graphs without getting stuck in loops and assigns correct distances.

Scenario 6: Large Graph Performance

Details:
  TestName: RunBFSWithLargeGraphPerformance
  Description: Test the performance of the BFS algorithm on a large graph.

Execution:
  Arrange: Create a large graph with many vertices and edges, and select a start vertex.
  Act: Measure the execution time of the Run method with the large graph and start vertex.
  Assert: Verify that the execution time is within acceptable limits and all vertices are processed correctly.

Validation:
  This test ensures that the BFS algorithm performs efficiently on large graphs and correctly processes all vertices.

Scenario 7: Graph with Isolated Vertices

Details:
  TestName: RunBFSWithGraphContainingIsolatedVertices
  Description: Test the BFS algorithm on a graph containing isolated vertices (vertices with no edges).

Execution:
  Arrange: Create a graph with some connected vertices and some isolated vertices, and select a start vertex from the connected portion.
  Act: Call the Run method with the created graph and start vertex.
  Assert: Verify that connected vertices are processed and isolated vertices remain unprocessed.

Validation:
  This test checks if the BFS algorithm correctly handles graphs with isolated vertices by not processing them when unreachable from the start vertex.

These test scenarios cover various aspects of the BreadthFirstSearch.Run method, including normal operation, edge cases, error handling, and performance considerations.


*/

// ********RoostGPT********
using NUnit.Framework;
using LunarDoggo.Datastructures.Graphs;
using LunarDoggo.Algorithms.Graphs.Pathfinding;
using System;
using System.Collections.Generic;
using System.Linq;

namespace LunarDoggo.Algorithms.Graphs.Pathfinding.Test
{
    [TestFixture]
    public class RunTest
    {
        private BreadthFirstSearch bfs;

        [SetUp]
        public void Setup()
        {
            bfs = new BreadthFirstSearch();
        }

        [Test, Category("valid")]
        public void RunBFSWithValidGraphAndStartVertex()
        {
            // Arrange
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);

            // Act
            bfs.Run(graph, v1);

            // Assert
            Assert.That(v1.Value.Distance, Is.EqualTo(0));
            Assert.That(v2.Value.Distance, Is.EqualTo(1));
            Assert.That(v3.Value.Distance, Is.EqualTo(2));
            Assert.That(v1.Value.Predecessor, Is.Null);
            Assert.That(v2.Value.Predecessor, Is.EqualTo(v1));
            Assert.That(v3.Value.Predecessor, Is.EqualTo(v2));
            Assert.That(v1.Value.Processed, Is.True);
            Assert.That(v2.Value.Processed, Is.True);
            Assert.That(v3.Value.Processed, Is.True);
        }

        [Test, Category("invalid")]
        public void RunBFSWithNullGraphThrowsArgumentNullException()
        {
            // Arrange
            IGraph<BFSVertex> nullGraph = null;
            var startVertex = new Vertex<BFSVertex>(0, new BFSVertex());

            // Act & Assert
            Assert.Throws<ArgumentNullException>(() => bfs.Run(nullGraph, startVertex));
        }

        [Test, Category("valid")]
        public void RunBFSWithDisconnectedGraph()
        {
            // Arrange
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            var v4 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v3, v4);

            // Act
            bfs.Run(graph, v1);

            // Assert
            Assert.That(v1.Value.Distance, Is.EqualTo(0));
            Assert.That(v2.Value.Distance, Is.EqualTo(1));
            Assert.That(v3.Value.Distance, Is.EqualTo(int.MaxValue));
            Assert.That(v4.Value.Distance, Is.EqualTo(int.MaxValue));
            Assert.That(v1.Value.Processed, Is.True);
            Assert.That(v2.Value.Processed, Is.True);
            Assert.That(v3.Value.Processed, Is.False);
            Assert.That(v4.Value.Processed, Is.False);
        }

        [Test, Category("boundary")]
        public void RunBFSWithSingleVertexGraph()
        {
            // Arrange
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());

            // Act
            bfs.Run(graph, v1);

            // Assert
            Assert.That(v1.Value.Distance, Is.EqualTo(0));
            Assert.That(v1.Value.Predecessor, Is.Null);
            Assert.That(v1.Value.Processed, Is.True);
        }

        [Test, Category("valid")]
        public void RunBFSWithCyclicGraph()
        {
            // Arrange
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);
            graph.AddEdge(v3, v1);

            // Act
            bfs.Run(graph, v1);

            // Assert
            Assert.That(v1.Value.Distance, Is.EqualTo(0));
            Assert.That(v2.Value.Distance, Is.EqualTo(1));
            Assert.That(v3.Value.Distance, Is.EqualTo(1));
            Assert.That(v1.Value.Predecessor, Is.Null);
            Assert.That(v2.Value.Predecessor, Is.EqualTo(v1));
            Assert.That(v3.Value.Predecessor, Is.EqualTo(v1));
            Assert.That(v1.Value.Processed, Is.True);
            Assert.That(v2.Value.Processed, Is.True);
            Assert.That(v3.Value.Processed, Is.True);
        }

        [Test, Category("valid")]
        public void RunBFSWithLargeGraphPerformance()
        {
            // Arrange
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertices = new List<Vertex<BFSVertex>>();
            for (int i = 0; i < 10000; i++)
            {
                vertices.Add(graph.AddVertex(new BFSVertex()));
            }
            for (int i = 0; i < 9999; i++)
            {
                graph.AddEdge(vertices[i], vertices[i + 1]);
            }

            // Act
            var startTime = DateTime.Now;
            bfs.Run(graph, vertices[0]);
            var endTime = DateTime.Now;

            // Assert
            var executionTime = (endTime - startTime).TotalSeconds;
            Assert.That(executionTime, Is.LessThan(5)); // Assuming 5 seconds is an acceptable time limit
            Assert.That(vertices.All(v => v.Value.Processed), Is.True);
            Assert.That(vertices[9999].Value.Distance, Is.EqualTo(9999));
        }

        [Test, Category("valid")]
        public void RunBFSWithGraphContainingIsolatedVertices()
        {
            // Arrange
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            var isolated = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);

            // Act
            bfs.Run(graph, v1);

            // Assert
            Assert.That(v1.Value.Processed, Is.True);
            Assert.That(v2.Value.Processed, Is.True);
            Assert.That(v3.Value.Processed, Is.True);
            Assert.That(isolated.Value.Processed, Is.False);
            Assert.That(isolated.Value.Distance, Is.EqualTo(int.MaxValue));
            Assert.That(isolated.Value.Predecessor, Is.Null);
        }
    }
}
