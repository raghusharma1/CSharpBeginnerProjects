// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleCSharpEnv using AI Type  and AI Model 

ROOST_METHOD_HASH=Run_bbc3b7dcfd
ROOST_METHOD_SIG_HASH=Run_23f9485d25

   ########## Test-Scenarios ##########  

Based on the provided method and context, here are several test scenarios for the `Run` method of the `BreadthFirstSearch` class:

Scenario 1: Null Graph Input

Details:
  TestName: ThrowsArgumentNullExceptionWhenGraphIsNull
  Description: Verify that the method throws an ArgumentNullException when a null graph is provided.
Execution:
  Arrange: Create a BreadthFirstSearch instance and set up a null graph and a valid start vertex.
  Act: Call the Run method with the null graph and valid start vertex.
  Assert: Verify that an ArgumentNullException is thrown with the correct message.
Validation:
  This test ensures that the method properly handles null input for the graph parameter, maintaining robustness and preventing null reference exceptions later in the execution.

Scenario 2: Valid Graph with Single Vertex

Details:
  TestName: ProcessesSingleVertexGraphCorrectly
  Description: Ensure the method correctly processes a graph with only one vertex (the start vertex).
Execution:
  Arrange: Create a BreadthFirstSearch instance, a graph with a single vertex, and set this vertex as the start.
  Act: Call the Run method with the graph and start vertex.
  Assert: Verify that the start vertex is processed (Processed = true) and has a Distance of 0.
Validation:
  This test confirms that the method correctly initializes and processes the simplest possible graph, setting the base case for more complex scenarios.

Scenario 3: Graph with Multiple Vertices but No Edges

Details:
  TestName: ProcessesDisconnectedGraphCorrectly
  Description: Verify the method's behavior when given a graph with multiple vertices but no connecting edges.
Execution:
  Arrange: Create a BreadthFirstSearch instance, a graph with multiple vertices but no edges, and choose a start vertex.
  Act: Call the Run method with the graph and start vertex.
  Assert: Check that only the start vertex is processed and has a Distance of 0, while all other vertices remain unprocessed with Distance set to Int32.MaxValue.
Validation:
  This scenario tests the method's ability to handle disconnected graphs, ensuring it doesn't process unreachable vertices.

Scenario 4: Simple Connected Graph

Details:
  TestName: ProcessesSimpleConnectedGraphCorrectly
  Description: Test the method's functionality with a simple connected graph (e.g., a linear path of vertices).
Execution:
  Arrange: Create a BreadthFirstSearch instance, a graph with a linear path of vertices (e.g., A -> B -> C -> D), and set A as the start vertex.
  Act: Call the Run method with the graph and start vertex A.
  Assert: Verify that all vertices are processed, their distances are set correctly (A:0, B:1, C:2, D:3), and their predecessors are set appropriately.
Validation:
  This test ensures that the basic breadth-first search algorithm is working correctly for a simple connected graph, properly setting distances and predecessors.

Scenario 5: Graph with Cycles

Details:
  TestName: HandlesGraphWithCyclesCorrectly
  Description: Ensure the method correctly processes a graph containing cycles without getting stuck in an infinite loop.
Execution:
  Arrange: Create a BreadthFirstSearch instance, a graph with cycles (e.g., A -> B -> C -> A, with additional vertex D connected to B), and set A as the start vertex.
  Act: Call the Run method with the graph and start vertex A.
  Assert: Verify that all vertices are processed exactly once, distances are set correctly (A:0, B:1, C:1, D:2), and predecessors are set appropriately.
Validation:
  This scenario tests the method's ability to handle cycles in the graph, ensuring it doesn't reprocess vertices and assigns correct distances.

Scenario 6: Large Graph Performance

Details:
  TestName: ProcessesLargeGraphWithinReasonableTime
  Description: Test the performance of the method with a large graph to ensure it completes within a reasonable time frame.
Execution:
  Arrange: Create a BreadthFirstSearch instance and a large graph (e.g., 10,000 vertices with random connections).
  Act: Measure the time taken to call the Run method with the large graph and a randomly chosen start vertex.
  Assert: Verify that the method completes within a specified time limit and that all vertices are processed.
Validation:
  This test ensures that the implementation is efficient enough to handle large graphs, which is crucial for real-world applications.

These scenarios cover various aspects of the BreadthFirstSearch implementation, including edge cases, error handling, and performance considerations. They should provide a comprehensive test suite for the given method.


*/

// ********RoostGPT********
using NUnit.Framework;
using System;
using System.Collections.Generic;
using LunarDoggo.Datastructures.Graphs;
using LunarDoggo.Algorithms.Graphs.Pathfinding;

namespace LunarDoggo.Algorithms.Graphs.Pathfinding.Test
{
    [TestFixture]
    public class RunTest
    {
        private BreadthFirstSearch bfs;

        [SetUp]
        public void Setup()
        {
            bfs = new BreadthFirstSearch();
        }

        [Test, Category("invalid")]
        public void ThrowsArgumentNullExceptionWhenGraphIsNull()
        {
            var start = new Vertex<BFSVertex>(0, new BFSVertex());
            Assert.Throws<ArgumentNullException>(() => bfs.Run(null, start));
        }

        [Test, Category("valid")]
        public void ProcessesSingleVertexGraphCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertex = graph.AddVertex(new BFSVertex());

            bfs.Run(graph, vertex);

            Assert.IsTrue(vertex.Value.Processed);
            Assert.AreEqual(0, vertex.Value.Distance);
        }

        [Test, Category("valid")]
        public void ProcessesDisconnectedGraphCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var start = graph.AddVertex(new BFSVertex());
            var other1 = graph.AddVertex(new BFSVertex());
            var other2 = graph.AddVertex(new BFSVertex());

            bfs.Run(graph, start);

            Assert.IsTrue(start.Value.Processed);
            Assert.AreEqual(0, start.Value.Distance);
            Assert.IsFalse(other1.Value.Processed);
            Assert.AreEqual(int.MaxValue, other1.Value.Distance);
            Assert.IsFalse(other2.Value.Processed);
            Assert.AreEqual(int.MaxValue, other2.Value.Distance);
        }

        [Test, Category("valid")]
        public void ProcessesSimpleConnectedGraphCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var a = graph.AddVertex(new BFSVertex());
            var b = graph.AddVertex(new BFSVertex());
            var c = graph.AddVertex(new BFSVertex());
            var d = graph.AddVertex(new BFSVertex());

            graph.AddEdge(a, b);
            graph.AddEdge(b, c);
            graph.AddEdge(c, d);

            bfs.Run(graph, a);

            Assert.IsTrue(a.Value.Processed);
            Assert.AreEqual(0, a.Value.Distance);
            Assert.IsNull(a.Value.Predecessor);

            Assert.IsTrue(b.Value.Processed);
            Assert.AreEqual(1, b.Value.Distance);
            Assert.AreEqual(a, b.Value.Predecessor);

            Assert.IsTrue(c.Value.Processed);
            Assert.AreEqual(2, c.Value.Distance);
            Assert.AreEqual(b, c.Value.Predecessor);

            Assert.IsTrue(d.Value.Processed);
            Assert.AreEqual(3, d.Value.Distance);
            Assert.AreEqual(c, d.Value.Predecessor);
        }

        [Test, Category("valid")]
        public void HandlesGraphWithCyclesCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var a = graph.AddVertex(new BFSVertex());
            var b = graph.AddVertex(new BFSVertex());
            var c = graph.AddVertex(new BFSVertex());
            var d = graph.AddVertex(new BFSVertex());

            graph.AddEdge(a, b);
            graph.AddEdge(b, c);
            graph.AddEdge(c, a);
            graph.AddEdge(b, d);

            bfs.Run(graph, a);

            Assert.IsTrue(a.Value.Processed);
            Assert.AreEqual(0, a.Value.Distance);
            Assert.IsNull(a.Value.Predecessor);

            Assert.IsTrue(b.Value.Processed);
            Assert.AreEqual(1, b.Value.Distance);
            Assert.AreEqual(a, b.Value.Predecessor);

            Assert.IsTrue(c.Value.Processed);
            Assert.AreEqual(1, c.Value.Distance);
            Assert.AreEqual(a, c.Value.Predecessor);

            Assert.IsTrue(d.Value.Processed);
            Assert.AreEqual(2, d.Value.Distance);
            Assert.AreEqual(b, d.Value.Predecessor);
        }

        [Test, Category("valid")]
        public void ProcessesLargeGraphWithinReasonableTime()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertices = new List<Vertex<BFSVertex>>();

            // Create 10,000 vertices
            for (int i = 0; i < 10000; i++)
            {
                vertices.Add(graph.AddVertex(new BFSVertex()));
            }

            // Connect vertices randomly
            var random = new Random(42);
            for (int i = 0; i < 20000; i++)
            {
                int from = random.Next(vertices.Count);
                int to = random.Next(vertices.Count);
                if (from != to)
                {
                    graph.AddEdge(vertices[from], vertices[to]);
                }
            }

            var start = vertices[0];

            var stopwatch = System.Diagnostics.Stopwatch.StartNew();
            bfs.Run(graph, start);
            stopwatch.Stop();

            Assert.Less(stopwatch.ElapsedMilliseconds, 5000); // Assuming 5 seconds is reasonable
            Assert.IsTrue(vertices.TrueForAll(v => v.Value.Processed));
        }
    }
}
