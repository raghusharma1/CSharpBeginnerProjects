// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleCSharpEnv using AI Type  and AI Model 

ROOST_METHOD_HASH=Run_bbc3b7dcfd
ROOST_METHOD_SIG_HASH=Run_23f9485d25

   ########## Test-Scenarios ##########  

Based on the provided method and related code, here are several test scenarios for the `Run` method of the `BreadthFirstSearch` class:

Scenario 1: Null Graph Handling

Details:
  TestName: ThrowsArgumentNullExceptionWhenGraphIsNull
  Description: Verify that the method throws an ArgumentNullException when a null graph is passed.
Execution:
  Arrange: Create a BreadthFirstSearch instance and prepare a null graph and a valid start vertex.
  Act: Call the Run method with the null graph and valid start vertex.
  Assert: Expect an ArgumentNullException to be thrown.
Validation:
  This test ensures that the method properly handles null input for the graph parameter, maintaining robustness and preventing null reference exceptions later in the execution.

Scenario 2: Basic BFS Traversal

Details:
  TestName: CorrectlyTraversesSimpleGraph
  Description: Ensure that the BFS algorithm correctly traverses a simple graph and sets the correct distances and predecessors.
Execution:
  Arrange: Create a simple graph with known structure (e.g., a small tree or a simple connected graph).
  Act: Run the BFS algorithm on this graph starting from a specific vertex.
  Assert: Check that all vertices have been processed, and their distances and predecessors are set correctly.
Validation:
  This test verifies the core functionality of the BFS algorithm, ensuring it visits all nodes in the correct order and sets the appropriate metadata.

Scenario 3: Disconnected Graph Handling

Details:
  TestName: HandlesDisconnectedGraphCorrectly
  Description: Verify that the BFS algorithm correctly handles a disconnected graph, only processing the connected component of the start vertex.
Execution:
  Arrange: Create a graph with multiple disconnected components.
  Act: Run the BFS algorithm starting from a vertex in one of the components.
  Assert: Check that only vertices in the same component as the start vertex are processed, while others remain unprocessed.
Validation:
  This test ensures that the BFS algorithm behaves correctly when faced with a disconnected graph, which is an important edge case to consider.

Scenario 4: Single Vertex Graph

Details:
  TestName: CorrectlyProcessesSingleVertexGraph
  Description: Ensure that the BFS algorithm correctly handles a graph consisting of a single vertex.
Execution:
  Arrange: Create a graph with only one vertex.
  Act: Run the BFS algorithm on this single-vertex graph.
  Assert: Verify that the vertex is processed, its distance is set to 0, and it has no predecessor.
Validation:
  This test covers the edge case of a minimal graph, ensuring the algorithm behaves correctly in this scenario.

Scenario 5: Cyclic Graph Traversal

Details:
  TestName: CorrectlyTraversesCyclicGraph
  Description: Verify that the BFS algorithm correctly traverses a graph containing cycles without getting stuck in an infinite loop.
Execution:
  Arrange: Create a graph with known cycles.
  Act: Run the BFS algorithm on this cyclic graph.
  Assert: Check that all vertices are processed exactly once, with correct distances and predecessors.
Validation:
  This test ensures that the algorithm can handle graphs with cycles, which is crucial for its correctness and termination.

Scenario 6: Large Graph Performance

Details:
  TestName: PerformsEfficientlyOnLargeGraph
  Description: Ensure that the BFS algorithm performs efficiently on a large graph within a reasonable time frame.
Execution:
  Arrange: Create a large graph with many vertices and edges.
  Act: Run the BFS algorithm on this large graph and measure the execution time.
  Assert: Verify that the algorithm completes within an acceptable time limit and correctly processes all vertices.
Validation:
  This test checks the performance characteristics of the BFS implementation, ensuring it scales well to larger graphs.

Scenario 7: Correct Initialization

Details:
  TestName: CorrectlyInitializesVerticesBeforeTraversal
  Description: Verify that all vertices are properly initialized before the BFS traversal begins.
Execution:
  Arrange: Create a graph with multiple vertices.
  Act: Run the BFS algorithm.
  Assert: Check that immediately after initialization (before the main loop), all vertices except the start vertex have Distance set to Int32.MaxValue, null Predecessor, and Processed set to false.
Validation:
  This test ensures that the initialization step of the algorithm is working correctly, which is crucial for the subsequent traversal.

These test scenarios cover various aspects of the BFS algorithm implementation, including normal operation, edge cases, and potential issues. They should provide a comprehensive test suite for the given method.


*/

// ********RoostGPT********
using NUnit.Framework;
using LunarDoggo.Datastructures.Graphs;
using LunarDoggo.Algorithms.Graphs.Pathfinding;
using System;
using System.Linq;

namespace LunarDoggo.Algorithms.Graphs.Pathfinding.Test
{
    [TestFixture]
    public class RunTest
    {
        private BreadthFirstSearch bfs;
        private UndirectedUnweightedGraph<BFSVertex> graph;

        [SetUp]
        public void Setup()
        {
            bfs = new BreadthFirstSearch();
            graph = new UndirectedUnweightedGraph<BFSVertex>();
        }

        [Test]
        public void ThrowsArgumentNullExceptionWhenGraphIsNull()
        {
            var startVertex = new Vertex<BFSVertex>(0, new BFSVertex());
            Assert.Throws<ArgumentNullException>(() => bfs.Run(null, startVertex));
        }

        [Test]
        public void CorrectlyTraversesSimpleGraph()
        {
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);

            bfs.Run(graph, v1);

            Assert.That(v1.Value.Distance, Is.EqualTo(0));
            Assert.That(v2.Value.Distance, Is.EqualTo(1));
            Assert.That(v3.Value.Distance, Is.EqualTo(2));
            Assert.That(v1.Value.Predecessor, Is.Null);
            Assert.That(v2.Value.Predecessor, Is.EqualTo(v1));
            Assert.That(v3.Value.Predecessor, Is.EqualTo(v2));
        }

        [Test]
        public void HandlesDisconnectedGraphCorrectly()
        {
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);

            bfs.Run(graph, v1);

            Assert.That(v1.Value.Processed, Is.True);
            Assert.That(v2.Value.Processed, Is.True);
            Assert.That(v3.Value.Processed, Is.False);
        }

        [Test]
        public void CorrectlyProcessesSingleVertexGraph()
        {
            var v1 = graph.AddVertex(new BFSVertex());

            bfs.Run(graph, v1);

            Assert.That(v1.Value.Distance, Is.EqualTo(0));
            Assert.That(v1.Value.Predecessor, Is.Null);
            Assert.That(v1.Value.Processed, Is.True);
        }

        [Test]
        public void CorrectlyTraversesCyclicGraph()
        {
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);
            graph.AddEdge(v3, v1);

            bfs.Run(graph, v1);

            Assert.That(v1.Value.Distance, Is.EqualTo(0));
            Assert.That(v2.Value.Distance, Is.EqualTo(1));
            Assert.That(v3.Value.Distance, Is.EqualTo(1));
            Assert.That(v1.Value.Predecessor, Is.Null);
            Assert.That(v2.Value.Predecessor, Is.EqualTo(v1));
            Assert.That(v3.Value.Predecessor, Is.EqualTo(v1));
        }

        [Test]
        public void PerformsEfficientlyOnLargeGraph()
        {
            // TODO: Adjust the number of vertices based on the expected performance
            int vertexCount = 10000;
            for (int i = 0; i < vertexCount; i++)
            {
                graph.AddVertex(new BFSVertex());
            }

            for (int i = 0; i < vertexCount - 1; i++)
            {
                graph.AddEdge(graph.Vertices.ElementAt(i), graph.Vertices.ElementAt(i + 1));
            }

            var startTime = DateTime.Now;
            bfs.Run(graph, graph.Vertices.First());
            var endTime = DateTime.Now;

            var duration = (endTime - startTime).TotalSeconds;
            Assert.That(duration, Is.LessThan(5)); // Adjust the time limit as needed
            Assert.That(graph.Vertices.All(v => v.Value.Processed), Is.True);
        }

        [Test]
        public void CorrectlyInitializesVerticesBeforeTraversal()
        {
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);

            bfs.Run(graph, v1);

            Assert.That(v1.Value.Distance, Is.EqualTo(0));
            Assert.That(v1.Value.Predecessor, Is.Null);
            Assert.That(v1.Value.Processed, Is.True);

            Assert.That(v2.Value.Distance, Is.EqualTo(1));
            Assert.That(v2.Value.Predecessor, Is.EqualTo(v1));
            Assert.That(v2.Value.Processed, Is.True);

            Assert.That(v3.Value.Distance, Is.EqualTo(2));
            Assert.That(v3.Value.Predecessor, Is.EqualTo(v2));
            Assert.That(v3.Value.Processed, Is.True);
        }
    }
}
