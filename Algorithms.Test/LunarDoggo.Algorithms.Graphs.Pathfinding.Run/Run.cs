// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleCSharpEnv using AI Type  and AI Model 

ROOST_METHOD_HASH=Run_bbc3b7dcfd
ROOST_METHOD_SIG_HASH=Run_23f9485d25

   ########## Test-Scenarios ##########  

Based on the provided method and context, here are several test scenarios for the `Run` method of the `BreadthFirstSearch` class:

Scenario 1: Null Graph Handling

Details:
  TestName: ThrowsArgumentNullExceptionWhenGraphIsNull
  Description: Verify that the method throws an ArgumentNullException when a null graph is provided.
Execution:
  Arrange: Create a BreadthFirstSearch instance and set up a null graph and a valid start vertex.
  Act: Call the Run method with the null graph and valid start vertex.
  Assert: Verify that an ArgumentNullException is thrown with the correct message.
Validation:
  This test ensures that the method properly handles null input for the graph parameter, maintaining robustness and preventing null reference exceptions later in the execution.

Scenario 2: Basic BFS Traversal

Details:
  TestName: CorrectlyTraversesSimpleGraph
  Description: Ensure that the BFS algorithm correctly traverses a simple graph and sets the correct distances and predecessors.
Execution:
  Arrange: Create a simple graph with known structure (e.g., a small tree or a simple connected graph).
  Act: Run the BFS algorithm on this graph starting from a specific vertex.
  Assert: Check that all vertices have been processed, and their distances and predecessors are set correctly.
Validation:
  This test verifies the core functionality of the BFS algorithm, ensuring it correctly explores the graph in breadth-first order and sets the appropriate metadata for each vertex.

Scenario 3: Disconnected Graph Handling

Details:
  TestName: HandlesDisconnectedGraphCorrectly
  Description: Verify that the BFS algorithm correctly handles a disconnected graph, only processing reachable vertices.
Execution:
  Arrange: Create a graph with multiple disconnected components.
  Act: Run the BFS algorithm starting from a vertex in one of the components.
  Assert: Verify that only the vertices in the connected component of the start vertex are processed, while others remain unprocessed.
Validation:
  This test ensures that the BFS algorithm behaves correctly when faced with a disconnected graph, a common edge case in graph algorithms.

Scenario 4: Cyclic Graph Traversal

Details:
  TestName: CorrectlyTraversesCyclicGraph
  Description: Ensure that the BFS algorithm correctly handles cycles in the graph without getting stuck in infinite loops.
Execution:
  Arrange: Create a graph containing one or more cycles.
  Act: Run the BFS algorithm on this cyclic graph.
  Assert: Verify that all vertices are processed exactly once and have correct distance and predecessor values.
Validation:
  This test checks the algorithm's ability to handle cycles, which is crucial for its correctness and termination in general graph structures.

Scenario 5: Single Vertex Graph

Details:
  TestName: CorrectlyHandlesSingleVertexGraph
  Description: Verify that the BFS algorithm works correctly on a graph with only one vertex.
Execution:
  Arrange: Create a graph with a single vertex.
  Act: Run the BFS algorithm on this single-vertex graph.
  Assert: Check that the vertex is processed, has a distance of 0, and no predecessor.
Validation:
  This test covers the edge case of a minimal graph, ensuring the algorithm behaves correctly even in this simplest scenario.

Scenario 6: Large Graph Performance

Details:
  TestName: CompletesInReasonableTimeForLargeGraph
  Description: Ensure that the BFS algorithm completes within a reasonable time frame for a large graph.
Execution:
  Arrange: Create a large graph with many vertices and edges.
  Act: Run the BFS algorithm on this large graph and measure the execution time.
  Assert: Verify that the execution completes within an expected time frame and that all vertices are processed.
Validation:
  This test checks the performance characteristics of the implementation, ensuring it scales reasonably with larger inputs.

Scenario 7: Correct Initialization

Details:
  TestName: CorrectlyInitializesVerticesBeforeTraversal
  Description: Verify that all vertices are properly initialized before the BFS traversal begins.
Execution:
  Arrange: Create a graph with multiple vertices.
  Act: Run the BFS algorithm.
  Assert: Immediately after initialization (you may need to modify the method to allow this check), verify that all vertices except the start vertex have Distance set to Int32.MaxValue, Predecessor set to null, and Processed set to false.
Validation:
  This test ensures that the initialization step of the algorithm is working correctly, which is crucial for the overall correctness of the BFS.

These test scenarios cover various aspects of the BreadthFirstSearch.Run method, including normal operation, edge cases, and error handling. They should provide a comprehensive test suite for this method.


*/

// ********RoostGPT********
using NUnit.Framework;
using LunarDoggo.Datastructures.Graphs;
using LunarDoggo.Algorithms.Graphs.Pathfinding;
using System;
using System.Collections.Generic;
using System.Linq;

namespace LunarDoggo.Algorithms.Graphs.Pathfinding.Test
{
    [TestFixture]
    public class RunTest
    {
        private BreadthFirstSearch bfs;

        [SetUp]
        public void Setup()
        {
            bfs = new BreadthFirstSearch();
        }

        [Test, Category("invalid")]
        public void ThrowsArgumentNullExceptionWhenGraphIsNull()
        {
            var startVertex = new Vertex<BFSVertex>(0, new BFSVertex());

            Assert.Throws<ArgumentNullException>(() => bfs.Run(null, startVertex));
        }

        [Test, Category("valid")]
        public void CorrectlyTraversesSimpleGraph()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);

            bfs.Run(graph, v1);

            Assert.That(v1.Value.Distance, Is.EqualTo(0));
            Assert.That(v2.Value.Distance, Is.EqualTo(1));
            Assert.That(v3.Value.Distance, Is.EqualTo(2));
            Assert.That(v1.Value.Predecessor, Is.Null);
            Assert.That(v2.Value.Predecessor, Is.EqualTo(v1));
            Assert.That(v3.Value.Predecessor, Is.EqualTo(v2));
        }

        [Test, Category("valid")]
        public void HandlesDisconnectedGraphCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            var v4 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v3, v4);

            bfs.Run(graph, v1);

            Assert.That(v1.Value.Processed, Is.True);
            Assert.That(v2.Value.Processed, Is.True);
            Assert.That(v3.Value.Processed, Is.False);
            Assert.That(v4.Value.Processed, Is.False);
        }

        [Test, Category("valid")]
        public void CorrectlyTraversesCyclicGraph()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);
            graph.AddEdge(v3, v1);

            bfs.Run(graph, v1);

            Assert.That(v1.Value.Distance, Is.EqualTo(0));
            Assert.That(v2.Value.Distance, Is.EqualTo(1));
            Assert.That(v3.Value.Distance, Is.EqualTo(1));
            Assert.That(v1.Value.Predecessor, Is.Null);
            Assert.That(v2.Value.Predecessor, Is.EqualTo(v1));
            Assert.That(v3.Value.Predecessor, Is.EqualTo(v1));
        }

        [Test, Category("boundary")]
        public void CorrectlyHandlesSingleVertexGraph()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());

            bfs.Run(graph, v1);

            Assert.That(v1.Value.Distance, Is.EqualTo(0));
            Assert.That(v1.Value.Predecessor, Is.Null);
            Assert.That(v1.Value.Processed, Is.True);
        }

        [Test, Category("valid")]
        public void CompletesInReasonableTimeForLargeGraph()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertices = new List<Vertex<BFSVertex>>();
            for (int i = 0; i < 10000; i++)
            {
                vertices.Add(graph.AddVertex(new BFSVertex()));
            }
            for (int i = 0; i < 9999; i++)
            {
                graph.AddEdge(vertices[i], vertices[i + 1]);
            }

            Assert.That(() => bfs.Run(graph, vertices[0]), Throws.Nothing);
            Assert.That(vertices.All(v => v.Value.Processed), Is.True);
        }

        [Test, Category("valid")]
        public void CorrectlyInitializesVerticesBeforeTraversal()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);

            bfs.Run(graph, v1);

            Assert.That(v1.Value.Distance, Is.EqualTo(0));
            Assert.That(v1.Value.Predecessor, Is.Null);
            Assert.That(v1.Value.Processed, Is.True);
            Assert.That(v2.Value.Distance, Is.EqualTo(1));
            Assert.That(v2.Value.Predecessor, Is.EqualTo(v1));
            Assert.That(v2.Value.Processed, Is.True);
            Assert.That(v3.Value.Distance, Is.EqualTo(2));
            Assert.That(v3.Value.Predecessor, Is.EqualTo(v2));
            Assert.That(v3.Value.Processed, Is.True);
        }
    }
}
