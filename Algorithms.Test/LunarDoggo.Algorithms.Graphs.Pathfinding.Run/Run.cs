// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleCSharpEnv using AI Type Claude AI and AI Model claude-3-5-sonnet-20240620

ROOST_METHOD_HASH=Run_bbc3b7dcfd
ROOST_METHOD_SIG_HASH=Run_23f9485d25

   ########## Test-Scenarios ##########  

Based on the provided method and related code, here are several test scenarios for the `Run` method of the `BreadthFirstSearch` class:

Scenario 1: Null Graph Handling

Details:
  TestName: ThrowArgumentNullExceptionWhenGraphIsNull
  Description: Verify that the method throws an ArgumentNullException when a null graph is passed.
Execution:
  Arrange: Create a BreadthFirstSearch instance and set up a null graph and a valid start vertex.
  Act: Call the Run method with the null graph and valid start vertex.
  Assert: Expect an ArgumentNullException to be thrown.
Validation:
  This test ensures that the method properly handles null input for the graph parameter, maintaining robustness and preventing null reference exceptions later in the execution.

Scenario 2: Basic BFS Traversal

Details:
  TestName: CorrectlyTraversesSimpleGraph
  Description: Ensure that the BFS algorithm correctly traverses a simple graph and sets the correct distances and predecessors.
Execution:
  Arrange: Create a small graph with known structure (e.g., a simple tree or a small network).
  Act: Run the BFS algorithm on this graph starting from a specific vertex.
  Assert: Check that all vertices have been processed, and their distances and predecessors are set correctly.
Validation:
  This test verifies the core functionality of the BFS algorithm, ensuring it visits all nodes in the correct order and assigns proper distances and predecessors.

Scenario 3: Isolated Vertex Handling

Details:
  TestName: HandlesIsolatedVerticesCorrectly
  Description: Verify that the algorithm correctly handles graphs with isolated vertices.
Execution:
  Arrange: Create a graph with some connected vertices and one or more isolated vertices.
  Act: Run the BFS algorithm starting from a connected vertex.
  Assert: Check that isolated vertices remain unprocessed (Processed = false) and maintain their initial distance (Int32.MaxValue).
Validation:
  This test ensures that the BFS algorithm doesn't incorrectly process or modify isolated vertices that are unreachable from the start vertex.

Scenario 4: Cyclic Graph Traversal

Details:
  TestName: CorrectlyTraversesCyclicGraph
  Description: Ensure that the BFS algorithm correctly handles graphs containing cycles without getting stuck in infinite loops.
Execution:
  Arrange: Create a graph with one or more cycles.
  Act: Run the BFS algorithm on this cyclic graph.
  Assert: Verify that all vertices are processed exactly once and have correct distances and predecessors.
Validation:
  This test checks that the algorithm can handle cyclic structures without revisiting nodes or miscalculating distances.

Scenario 5: Large Graph Performance

Details:
  TestName: PerformsEfficientlyOnLargeGraph
  Description: Verify that the BFS algorithm can handle large graphs within a reasonable time frame.
Execution:
  Arrange: Create a large graph with many vertices and edges.
  Act: Run the BFS algorithm on this large graph and measure the execution time.
  Assert: Check that the algorithm completes within an acceptable time limit and correctly processes all vertices.
Validation:
  This test ensures that the implementation is efficient and can scale to larger graph structures without significant performance degradation.

Scenario 6: Start Vertex Initialization

Details:
  TestName: CorrectlyInitializesStartVertex
  Description: Verify that the start vertex is properly initialized with distance 0 and marked as processed.
Execution:
  Arrange: Create a graph and select a start vertex.
  Act: Run the BFS algorithm.
  Assert: Check that the start vertex has a distance of 0 and is marked as processed.
Validation:
  This test ensures that the starting point of the BFS is correctly set up, which is crucial for the rest of the traversal to work properly.

Scenario 7: Empty Graph Handling

Details:
  TestName: HandlesEmptyGraphGracefully
  Description: Ensure that the algorithm behaves correctly when given an empty graph (no vertices).
Execution:
  Arrange: Create an empty graph.
  Act: Run the BFS algorithm with a null start vertex (since there are no vertices).
  Assert: Verify that the method completes without errors and doesn't modify the empty graph.
Validation:
  This test checks the algorithm's ability to handle edge cases, specifically an empty graph, without throwing exceptions or entering invalid states.

These test scenarios cover various aspects of the BreadthFirstSearch algorithm, including normal operation, edge cases, and potential error conditions. They aim to ensure the correctness, robustness, and efficiency of the implementation.


*/

// ********RoostGPT********
using NUnit.Framework;
using LunarDoggo.Datastructures.Graphs;
using LunarDoggo.Algorithms.Graphs.Pathfinding;
using System;
using System.Linq;

namespace LunarDoggo.Algorithms.Graphs.Pathfinding.Test
{
    [TestFixture]
    public class RunTest
    {
        private BreadthFirstSearch bfs;
        private UndirectedUnweightedGraph<BFSVertex> graph;

        [SetUp]
        public void Setup()
        {
            bfs = new BreadthFirstSearch();
            graph = new UndirectedUnweightedGraph<BFSVertex>();
        }

        [Test, Category("invalid")]
        public void ThrowArgumentNullExceptionWhenGraphIsNull()
        {
            var start = new Vertex<BFSVertex>(0, new BFSVertex());
            Assert.Throws<ArgumentNullException>(() => bfs.Run(null, start));
        }

        [Test, Category("valid")]
        public void CorrectlyTraversesSimpleGraph()
        {
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);

            bfs.Run(graph, v1);

            Assert.That(v1.Value.Distance, Is.EqualTo(0));
            Assert.That(v2.Value.Distance, Is.EqualTo(1));
            Assert.That(v3.Value.Distance, Is.EqualTo(2));
            Assert.That(v1.Value.Predecessor, Is.Null);
            Assert.That(v2.Value.Predecessor, Is.EqualTo(v1));
            Assert.That(v3.Value.Predecessor, Is.EqualTo(v2));
        }

        [Test, Category("valid")]
        public void HandlesIsolatedVerticesCorrectly()
        {
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var isolated = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);

            bfs.Run(graph, v1);

            Assert.That(isolated.Value.Processed, Is.False);
            Assert.That(isolated.Value.Distance, Is.EqualTo(int.MaxValue));
            Assert.That(isolated.Value.Predecessor, Is.Null);
        }

        [Test, Category("valid")]
        public void CorrectlyTraversesCyclicGraph()
        {
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);
            graph.AddEdge(v3, v1);

            bfs.Run(graph, v1);

            Assert.That(v1.Value.Distance, Is.EqualTo(0));
            Assert.That(v2.Value.Distance, Is.EqualTo(1));
            Assert.That(v3.Value.Distance, Is.EqualTo(1));
            Assert.That(v1.Value.Predecessor, Is.Null);
            Assert.That(v2.Value.Predecessor, Is.EqualTo(v1));
            Assert.That(v3.Value.Predecessor, Is.EqualTo(v1));
        }

        [Test, Category("valid")]
        public void PerformsEfficientlyOnLargeGraph()
        {
            const int vertexCount = 10000;
            var vertices = Enumerable.Range(0, vertexCount)
                .Select(_ => graph.AddVertex(new BFSVertex()))
                .ToList();

            for (int i = 0; i < vertexCount - 1; i++)
            {
                graph.AddEdge(vertices[i], vertices[i + 1]);
            }

            var startTime = DateTime.Now;
            bfs.Run(graph, vertices[0]);
            var endTime = DateTime.Now;

            var duration = (endTime - startTime).TotalSeconds;
            Assert.That(duration, Is.LessThan(5)); // Adjust the time limit as needed
            Assert.That(vertices.Last().Value.Distance, Is.EqualTo(vertexCount - 1));
        }

        [Test, Category("valid")]
        public void CorrectlyInitializesStartVertex()
        {
            var start = graph.AddVertex(new BFSVertex());
            var other = graph.AddVertex(new BFSVertex());
            graph.AddEdge(start, other);

            bfs.Run(graph, start);

            Assert.That(start.Value.Distance, Is.EqualTo(0));
            Assert.That(start.Value.Processed, Is.True);
            Assert.That(start.Value.Predecessor, Is.Null);
        }

        [Test, Category("boundary")]
        public void HandlesEmptyGraphGracefully()
        {
            Assert.DoesNotThrow(() => bfs.Run(graph, null));
            Assert.That(graph.Vertices, Is.Empty);
        }
    }
}
