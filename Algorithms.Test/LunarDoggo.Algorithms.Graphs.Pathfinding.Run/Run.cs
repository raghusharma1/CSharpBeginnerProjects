// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleCSharpEnv using AI Type  and AI Model 

ROOST_METHOD_HASH=Run_bbc3b7dcfd
ROOST_METHOD_SIG_HASH=Run_23f9485d25

   ########## Test-Scenarios ##########  

Based on the provided method and related code, here are several test scenarios for the `Run` method of the `BreadthFirstSearch` class:

Scenario 1: Null Graph Handling

Details:
  TestName: ThrowsArgumentNullExceptionWhenGraphIsNull
  Description: Verify that the method throws an ArgumentNullException when a null graph is passed.
Execution:
  Arrange: Create a BreadthFirstSearch instance and prepare a null graph and a valid start vertex.
  Act: Call the Run method with the null graph and valid start vertex.
  Assert: Expect an ArgumentNullException to be thrown.
Validation:
  This test ensures that the method properly handles null input for the graph parameter, maintaining robustness and preventing null reference exceptions later in the execution.

Scenario 2: Basic BFS Traversal

Details:
  TestName: CorrectlyTraversesSimpleGraph
  Description: Ensure that the BFS algorithm correctly traverses a simple graph and sets the correct distances and predecessors.
Execution:
  Arrange: Create a simple graph with known structure, initialize BreadthFirstSearch instance.
  Act: Run the BFS algorithm on the graph starting from a specific vertex.
  Assert: Check that each vertex has the correct distance and predecessor set.
Validation:
  This test verifies the core functionality of the BFS algorithm, ensuring it correctly explores the graph in breadth-first order and sets the appropriate metadata for each vertex.

Scenario 3: Isolated Vertex Handling

Details:
  TestName: HandlesIsolatedVerticesCorrectly
  Description: Verify that the algorithm correctly handles isolated vertices in the graph.
Execution:
  Arrange: Create a graph with some connected vertices and one or more isolated vertices.
  Act: Run the BFS algorithm starting from a connected vertex.
  Assert: Check that isolated vertices remain unprocessed (distance should be Int32.MaxValue and predecessor should be null).
Validation:
  This test ensures that the BFS algorithm doesn't incorrectly process or modify isolated vertices that are unreachable from the starting point.

Scenario 4: Cyclic Graph Traversal

Details:
  TestName: CorrectlyTraversesCyclicGraph
  Description: Ensure that the BFS algorithm correctly handles cycles in the graph without getting stuck in infinite loops.
Execution:
  Arrange: Create a graph with one or more cycles, initialize BreadthFirstSearch instance.
  Act: Run the BFS algorithm on the cyclic graph.
  Assert: Verify that all vertices are processed exactly once and have correct distances and predecessors.
Validation:
  This test checks that the algorithm can handle cyclic structures in the graph without issues, which is crucial for its correctness and termination.

Scenario 5: Large Graph Performance

Details:
  TestName: PerformsEfficientlyOnLargeGraph
  Description: Verify that the BFS algorithm performs efficiently on a large graph within a reasonable time frame.
Execution:
  Arrange: Create a large graph with many vertices and edges, initialize BreadthFirstSearch instance.
  Act: Run the BFS algorithm on the large graph and measure the execution time.
  Assert: Check that the algorithm completes within an acceptable time limit and correctly processes all vertices.
Validation:
  This test ensures that the implementation is efficient and scales well with larger inputs, which is important for real-world usage scenarios.

Scenario 6: Start Vertex Initialization

Details:
  TestName: CorrectlyInitializesStartVertex
  Description: Verify that the start vertex is correctly initialized with distance 0 and marked as processed.
Execution:
  Arrange: Create a graph and choose a start vertex, initialize BreadthFirstSearch instance.
  Act: Run the BFS algorithm from the chosen start vertex.
  Assert: Check that the start vertex has a distance of 0 and is marked as processed.
Validation:
  This test ensures that the starting conditions for the BFS algorithm are correctly set, which is crucial for the overall correctness of the traversal.

These test scenarios cover various aspects of the BreadthFirstSearch implementation, including error handling, correctness of traversal, handling of different graph structures, and performance considerations.


*/

// ********RoostGPT********
using NUnit.Framework;
using LunarDoggo.Datastructures.Graphs;
using LunarDoggo.Algorithms.Graphs.Pathfinding;
using System;
using System.Collections.Generic;

namespace LunarDoggo.Algorithms.Graphs.Pathfinding.Test
{
    [TestFixture]
    public class RunTest
    {
        [Test, Category("invalid")]
        public void ThrowsArgumentNullExceptionWhenGraphIsNull()
        {
            // Arrange
            BreadthFirstSearch bfs = new BreadthFirstSearch();
            IGraph<BFSVertex> graph = null;
            Vertex<BFSVertex> start = new Vertex<BFSVertex>(0, new BFSVertex());

            // Act & Assert
            Assert.Throws<ArgumentNullException>(() => bfs.Run(graph, start));
        }

        [Test, Category("valid")]
        public void CorrectlyTraversesSimpleGraph()
        {
            // Arrange
            BreadthFirstSearch bfs = new BreadthFirstSearch();
            UndirectedUnweightedGraph<BFSVertex> graph = new UndirectedUnweightedGraph<BFSVertex>();
            Vertex<BFSVertex> v1 = graph.AddVertex(new BFSVertex());
            Vertex<BFSVertex> v2 = graph.AddVertex(new BFSVertex());
            Vertex<BFSVertex> v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);

            // Act
            bfs.Run(graph, v1);

            // Assert
            Assert.AreEqual(0, v1.Value.Distance);
            Assert.AreEqual(1, v2.Value.Distance);
            Assert.AreEqual(2, v3.Value.Distance);
            Assert.IsNull(v1.Value.Predecessor);
            Assert.AreEqual(v1, v2.Value.Predecessor);
            Assert.AreEqual(v2, v3.Value.Predecessor);
        }

        [Test, Category("valid")]
        public void HandlesIsolatedVerticesCorrectly()
        {
            // Arrange
            BreadthFirstSearch bfs = new BreadthFirstSearch();
            UndirectedUnweightedGraph<BFSVertex> graph = new UndirectedUnweightedGraph<BFSVertex>();
            Vertex<BFSVertex> v1 = graph.AddVertex(new BFSVertex());
            Vertex<BFSVertex> v2 = graph.AddVertex(new BFSVertex());
            Vertex<BFSVertex> isolated = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);

            // Act
            bfs.Run(graph, v1);

            // Assert
            Assert.AreEqual(Int32.MaxValue, isolated.Value.Distance);
            Assert.IsNull(isolated.Value.Predecessor);
            Assert.IsFalse(isolated.Value.Processed);
        }

        [Test, Category("valid")]
        public void CorrectlyTraversesCyclicGraph()
        {
            // Arrange
            BreadthFirstSearch bfs = new BreadthFirstSearch();
            UndirectedUnweightedGraph<BFSVertex> graph = new UndirectedUnweightedGraph<BFSVertex>();
            Vertex<BFSVertex> v1 = graph.AddVertex(new BFSVertex());
            Vertex<BFSVertex> v2 = graph.AddVertex(new BFSVertex());
            Vertex<BFSVertex> v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);
            graph.AddEdge(v3, v1);

            // Act
            bfs.Run(graph, v1);

            // Assert
            Assert.AreEqual(0, v1.Value.Distance);
            Assert.AreEqual(1, v2.Value.Distance);
            Assert.AreEqual(1, v3.Value.Distance);
            Assert.IsTrue(v1.Value.Processed);
            Assert.IsTrue(v2.Value.Processed);
            Assert.IsTrue(v3.Value.Processed);
        }

        [Test, Category("valid")]
        public void PerformsEfficientlyOnLargeGraph()
        {
            // Arrange
            BreadthFirstSearch bfs = new BreadthFirstSearch();
            UndirectedUnweightedGraph<BFSVertex> graph = new UndirectedUnweightedGraph<BFSVertex>();
            int vertexCount = 10000;
            List<Vertex<BFSVertex>> vertices = new List<Vertex<BFSVertex>>();

            for (int i = 0; i < vertexCount; i++)
            {
                vertices.Add(graph.AddVertex(new BFSVertex()));
            }

            for (int i = 0; i < vertexCount - 1; i++)
            {
                graph.AddEdge(vertices[i], vertices[i + 1]);
            }

            // Act
            DateTime start = DateTime.Now;
            bfs.Run(graph, vertices[0]);
            TimeSpan duration = DateTime.Now - start;

            // Assert
            Assert.Less(duration.TotalSeconds, 5); // Adjust this value based on the expected performance
            Assert.AreEqual(vertexCount - 1, vertices[vertexCount - 1].Value.Distance);
        }

        [Test, Category("valid")]
        public void CorrectlyInitializesStartVertex()
        {
            // Arrange
            BreadthFirstSearch bfs = new BreadthFirstSearch();
            UndirectedUnweightedGraph<BFSVertex> graph = new UndirectedUnweightedGraph<BFSVertex>();
            Vertex<BFSVertex> start = graph.AddVertex(new BFSVertex());

            // Act
            bfs.Run(graph, start);

            // Assert
            Assert.AreEqual(0, start.Value.Distance);
            Assert.IsTrue(start.Value.Processed);
            Assert.IsNull(start.Value.Predecessor);
        }
    }
}
