// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleCSharpEnv using AI Type  and AI Model 

ROOST_METHOD_HASH=Run_bbc3b7dcfd
ROOST_METHOD_SIG_HASH=Run_23f9485d25

   ########## Test-Scenarios ##########  

Based on the provided method and related code, I'll generate NUnit test scenarios for the `Run` method of the `BreadthFirstSearch` class. Here are the test scenarios:

Scenario 1: Null Graph Handling

Details:
  TestName: ThrowArgumentNullExceptionWhenGraphIsNull
  Description: Verify that the method throws an ArgumentNullException when a null graph is passed.

Execution:
  Arrange: Create a BreadthFirstSearch instance and set up a null graph and a valid start vertex.
  Act: Call the Run method with the null graph and valid start vertex.
  Assert: Expect an ArgumentNullException to be thrown.

Validation:
  This test ensures that the method properly handles null input for the graph parameter, maintaining robustness and preventing null reference exceptions later in the execution.

Scenario 2: Basic BFS Traversal

Details:
  TestName: CorrectlyTraversesSimpleGraph
  Description: Verify that the BFS algorithm correctly traverses a simple graph and sets the correct distances and predecessors.

Execution:
  Arrange: Create a simple graph with known structure, initialize a BreadthFirstSearch instance, and choose a start vertex.
  Act: Call the Run method with the created graph and start vertex.
  Assert: Check that each vertex has the correct distance and predecessor set.

Validation:
  This test confirms that the BFS algorithm correctly traverses the graph in breadth-first order, setting appropriate distances and predecessors for each vertex.

Scenario 3: Isolated Vertices Handling

Details:
  TestName: HandlesGraphWithIsolatedVertices
  Description: Ensure that the algorithm correctly handles graphs with isolated vertices.

Execution:
  Arrange: Create a graph with some connected vertices and some isolated vertices.
  Act: Run the BFS algorithm on this graph.
  Assert: Verify that isolated vertices have maximum distance and null predecessors.

Validation:
  This test checks if the algorithm correctly handles graphs that are not fully connected, ensuring isolated vertices are properly marked.

Scenario 4: Cyclic Graph Traversal

Details:
  TestName: CorrectlyTraversesCyclicGraph
  Description: Verify that the BFS algorithm correctly traverses a graph containing cycles.

Execution:
  Arrange: Create a graph with cycles, initialize BFS, and choose a start vertex.
  Act: Run the BFS algorithm.
  Assert: Check that all vertices are processed and have correct distances despite the presence of cycles.

Validation:
  This test ensures that the algorithm doesn't get stuck in infinite loops when encountering cycles and correctly assigns distances in cyclic structures.

Scenario 5: Large Graph Performance

Details:
  TestName: PerformsEfficientlyOnLargeGraph
  Description: Test the performance of the BFS algorithm on a large graph.

Execution:
  Arrange: Generate a large graph with many vertices and edges.
  Act: Run the BFS algorithm and measure the execution time.
  Assert: Verify that the execution time is within acceptable limits and all vertices are processed.

Validation:
  This test checks the efficiency and scalability of the algorithm when dealing with large datasets, ensuring it performs within expected time constraints.

Scenario 6: Start Vertex Initialization

Details:
  TestName: CorrectlyInitializesStartVertex
  Description: Verify that the start vertex is correctly initialized with distance 0 and marked as processed.

Execution:
  Arrange: Create a graph and choose a start vertex.
  Act: Run the BFS algorithm.
  Assert: Check that the start vertex has a distance of 0 and is marked as processed.

Validation:
  This test ensures that the starting point of the BFS is correctly set up, which is crucial for the rest of the traversal to work properly.

Scenario 7: Empty Graph Handling

Details:
  TestName: HandlesEmptyGraphGracefully
  Description: Ensure that the algorithm handles an empty graph (no vertices) without errors.

Execution:
  Arrange: Create an empty graph.
  Act: Run the BFS algorithm on the empty graph.
  Assert: Verify that the method completes without throwing exceptions.

Validation:
  This test checks the robustness of the algorithm when dealing with edge cases like empty graphs, ensuring it doesn't break or throw unexpected exceptions.

These test scenarios cover various aspects of the BreadthFirstSearch algorithm, including normal operation, edge cases, and error handling. They aim to ensure the correctness, efficiency, and robustness of the implementation.


*/

// ********RoostGPT********
using NUnit.Framework;
using LunarDoggo.Datastructures.Graphs;
using LunarDoggo.Algorithms.Graphs.Pathfinding;
using System;
using System.Collections.Generic;

namespace LunarDoggo.Algorithms.Graphs.Pathfinding.Test
{
    [TestFixture]
    public class RunTest
    {
        private BreadthFirstSearch bfs;

        [SetUp]
        public void Setup()
        {
            bfs = new BreadthFirstSearch();
        }

        [Test, Category("invalid")]
        public void ThrowArgumentNullExceptionWhenGraphIsNull()
        {
            var start = new Vertex<BFSVertex>(0, new BFSVertex());
            Assert.Throws<ArgumentNullException>(() => bfs.Run(null, start));
        }

        [Test, Category("valid")]
        public void CorrectlyTraversesSimpleGraph()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);

            bfs.Run(graph, v1);

            Assert.AreEqual(0, v1.Value.Distance);
            Assert.AreEqual(1, v2.Value.Distance);
            Assert.AreEqual(2, v3.Value.Distance);
            Assert.IsNull(v1.Value.Predecessor);
            Assert.AreEqual(v1, v2.Value.Predecessor);
            Assert.AreEqual(v2, v3.Value.Predecessor);
        }

        [Test, Category("valid")]
        public void HandlesGraphWithIsolatedVertices()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);

            bfs.Run(graph, v1);

            Assert.AreEqual(0, v1.Value.Distance);
            Assert.AreEqual(1, v2.Value.Distance);
            Assert.AreEqual(int.MaxValue, v3.Value.Distance);
            Assert.IsNull(v3.Value.Predecessor);
        }

        [Test, Category("valid")]
        public void CorrectlyTraversesCyclicGraph()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);
            graph.AddEdge(v3, v1);

            bfs.Run(graph, v1);

            Assert.AreEqual(0, v1.Value.Distance);
            Assert.AreEqual(1, v2.Value.Distance);
            Assert.AreEqual(1, v3.Value.Distance);
        }

        [Test, Category("valid")]
        public void PerformsEfficientlyOnLargeGraph()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertices = new List<Vertex<BFSVertex>>();
            for (int i = 0; i < 1000; i++)
            {
                vertices.Add(graph.AddVertex(new BFSVertex()));
            }
            for (int i = 0; i < 999; i++)
            {
                graph.AddEdge(vertices[i], vertices[i + 1]);
            }

            var startTime = DateTime.Now;
            bfs.Run(graph, vertices[0]);
            var endTime = DateTime.Now;

            Assert.Less((endTime - startTime).TotalSeconds, 1);
            Assert.AreEqual(999, vertices[999].Value.Distance);
        }

        [Test, Category("valid")]
        public void CorrectlyInitializesStartVertex()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var start = graph.AddVertex(new BFSVertex());

            bfs.Run(graph, start);

            Assert.AreEqual(0, start.Value.Distance);
            Assert.IsTrue(start.Value.Processed);
        }

        [Test, Category("boundary")]
        public void HandlesEmptyGraphGracefully()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var start = new Vertex<BFSVertex>(0, new BFSVertex());

            Assert.DoesNotThrow(() => bfs.Run(graph, start));
        }
    }
}
