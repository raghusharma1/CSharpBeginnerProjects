// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleCSharpEnv using AI Type  and AI Model 

ROOST_METHOD_HASH=Run_bbc3b7dcfd
ROOST_METHOD_SIG_HASH=Run_23f9485d25

   ########## Test-Scenarios ##########  

Based on the provided method and related code, here are several test scenarios for the `Run` method of the `BreadthFirstSearch` class:

Scenario 1: Null Graph Handling

Details:
  TestName: ThrowArgumentNullExceptionWhenGraphIsNull
  Description: Verify that the method throws an ArgumentNullException when a null graph is passed.
Execution:
  Arrange: Create a BreadthFirstSearch instance and set up a null graph and a valid start vertex.
  Act: Call the Run method with the null graph and valid start vertex.
  Assert: Expect an ArgumentNullException to be thrown.
Validation:
  This test ensures that the method properly handles null input for the graph parameter, maintaining robustness and preventing null reference exceptions later in the execution.

Scenario 2: Single Vertex Graph

Details:
  TestName: ProcessSingleVertexGraphCorrectly
  Description: Ensure the method correctly processes a graph with only one vertex.
Execution:
  Arrange: Create a graph with a single vertex and set it as the start vertex.
  Act: Run the BFS algorithm on this graph.
  Assert: Verify that the vertex is processed, its distance is 0, and it has no predecessor.
Validation:
  This test confirms that the BFS algorithm works correctly for the simplest possible graph, setting a baseline for more complex scenarios.

Scenario 3: Linear Graph Traversal

Details:
  TestName: TraverseLinearGraphCorrectly
  Description: Check if the BFS algorithm correctly traverses a linear graph (a chain of vertices).
Execution:
  Arrange: Create a linear graph with multiple vertices connected in a line.
  Act: Run the BFS algorithm starting from one end of the line.
  Assert: Verify that each vertex is processed in order, distances increase linearly, and predecessors are set correctly.
Validation:
  This test ensures that the BFS algorithm correctly handles a simple linear structure, properly setting distances and predecessors.

Scenario 4: Cyclic Graph Handling

Details:
  TestName: HandleCyclicGraphWithoutInfiniteLoop
  Description: Verify that the BFS algorithm correctly handles a graph with cycles without getting stuck in an infinite loop.
Execution:
  Arrange: Create a graph with a cycle (e.g., A -> B -> C -> A).
  Act: Run the BFS algorithm starting from any vertex in the cycle.
  Assert: Check that all vertices are processed exactly once, distances are set correctly, and the algorithm terminates.
Validation:
  This test confirms that the algorithm can handle cycles in the graph without revisiting vertices or getting stuck in an infinite loop.

Scenario 5: Disconnected Graph Components

Details:
  TestName: ProcessOnlyReachableVerticesInDisconnectedGraph
  Description: Ensure that only vertices reachable from the start vertex are processed in a disconnected graph.
Execution:
  Arrange: Create a graph with two disconnected components.
  Act: Run the BFS algorithm starting from a vertex in one component.
  Assert: Verify that only vertices in the same component as the start vertex are processed, while vertices in the other component remain unprocessed.
Validation:
  This test checks that the BFS algorithm correctly handles disconnected graphs, processing only the reachable vertices from the given start point.

Scenario 6: Correct Distance Calculation

Details:
  TestName: CalculateCorrectDistancesInComplexGraph
  Description: Verify that the BFS algorithm calculates correct distances in a more complex graph structure.
Execution:
  Arrange: Create a complex graph with multiple paths between vertices.
  Act: Run the BFS algorithm from a chosen start vertex.
  Assert: Check that the distances to all vertices are calculated correctly, representing the shortest path from the start vertex.
Validation:
  This test ensures that the BFS algorithm correctly calculates the shortest distances in a more complex graph structure, which is a key property of BFS.

Scenario 7: Proper Predecessor Assignment

Details:
  TestName: AssignPredecessorsCorrectlyDuringTraversal
  Description: Ensure that predecessors are correctly assigned during the BFS traversal.
Execution:
  Arrange: Set up a graph with a known structure.
  Act: Run the BFS algorithm from a specific start vertex.
  Assert: Verify that each processed vertex (except the start vertex) has its predecessor set to the vertex from which it was first discovered.
Validation:
  This test confirms that the predecessor assignments are correct, which is crucial for reconstructing paths in the graph after the BFS is complete.

These test scenarios cover various aspects of the BreadthFirstSearch.Run method, including edge cases, error handling, and core functionality across different graph structures.


*/

// ********RoostGPT********
using NUnit.Framework;
using LunarDoggo.Datastructures.Graphs;
using LunarDoggo.Algorithms.Graphs.Pathfinding;
using System;
using System.Linq;

namespace LunarDoggo.Algorithms.Graphs.Pathfinding.Test
{
    [TestFixture]
    public class RunTest
    {
        private BreadthFirstSearch bfs;
        private UndirectedUnweightedGraph<BFSVertex> graph;

        [SetUp]
        public void Setup()
        {
            bfs = new BreadthFirstSearch();
            graph = new UndirectedUnweightedGraph<BFSVertex>();
        }

        [Test, Category("invalid")]
        public void ThrowArgumentNullExceptionWhenGraphIsNull()
        {
            var start = new Vertex<BFSVertex>(0, new BFSVertex());
            Assert.Throws<ArgumentNullException>(() => bfs.Run(null, start));
        }

        [Test, Category("valid")]
        public void ProcessSingleVertexGraphCorrectly()
        {
            var vertex = graph.AddVertex(new BFSVertex());
            bfs.Run(graph, vertex);

            Assert.That(vertex.Value.Processed, Is.True);
            Assert.That(vertex.Value.Distance, Is.EqualTo(0));
            Assert.That(vertex.Value.Predecessor, Is.Null);
        }

        [Test, Category("valid")]
        public void TraverseLinearGraphCorrectly()
        {
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);

            bfs.Run(graph, v1);

            Assert.That(v1.Value.Distance, Is.EqualTo(0));
            Assert.That(v2.Value.Distance, Is.EqualTo(1));
            Assert.That(v3.Value.Distance, Is.EqualTo(2));
            Assert.That(v2.Value.Predecessor, Is.EqualTo(v1));
            Assert.That(v3.Value.Predecessor, Is.EqualTo(v2));
        }

        [Test, Category("valid")]
        public void HandleCyclicGraphWithoutInfiniteLoop()
        {
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);
            graph.AddEdge(v3, v1);

            bfs.Run(graph, v1);

            Assert.That(v1.Value.Distance, Is.EqualTo(0));
            Assert.That(v2.Value.Distance, Is.EqualTo(1));
            Assert.That(v3.Value.Distance, Is.EqualTo(1));
            Assert.That(v1.Value.Processed && v2.Value.Processed && v3.Value.Processed, Is.True);
        }

        [Test, Category("valid")]
        public void ProcessOnlyReachableVerticesInDisconnectedGraph()
        {
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            var v4 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v3, v4);

            bfs.Run(graph, v1);

            Assert.That(v1.Value.Processed && v2.Value.Processed, Is.True);
            Assert.That(v3.Value.Processed || v4.Value.Processed, Is.False);
        }

        [Test, Category("valid")]
        public void CalculateCorrectDistancesInComplexGraph()
        {
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            var v4 = graph.AddVertex(new BFSVertex());
            var v5 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v1, v3);
            graph.AddEdge(v2, v4);
            graph.AddEdge(v3, v4);
            graph.AddEdge(v4, v5);

            bfs.Run(graph, v1);

            Assert.That(v1.Value.Distance, Is.EqualTo(0));
            Assert.That(v2.Value.Distance, Is.EqualTo(1));
            Assert.That(v3.Value.Distance, Is.EqualTo(1));
            Assert.That(v4.Value.Distance, Is.EqualTo(2));
            Assert.That(v5.Value.Distance, Is.EqualTo(3));
        }

        [Test, Category("valid")]
        public void AssignPredecessorsCorrectlyDuringTraversal()
        {
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            var v4 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v1, v3);
            graph.AddEdge(v2, v4);
            graph.AddEdge(v3, v4);

            bfs.Run(graph, v1);

            Assert.That(v1.Value.Predecessor, Is.Null);
            Assert.That(v2.Value.Predecessor, Is.EqualTo(v1));
            Assert.That(v3.Value.Predecessor, Is.EqualTo(v1));
            Assert.That(v4.Value.Predecessor, Is.EqualTo(v2).Or.EqualTo(v3));
        }

        [TearDown]
        public void TearDown()
        {
            bfs = null;
            graph = null;
        }
    }
}
