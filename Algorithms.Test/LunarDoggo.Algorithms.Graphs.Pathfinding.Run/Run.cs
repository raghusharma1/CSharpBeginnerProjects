// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleCSharpEnv using AI Type  and AI Model 

ROOST_METHOD_HASH=Run_bbc3b7dcfd
ROOST_METHOD_SIG_HASH=Run_23f9485d25

   ########## Test-Scenarios ##########  

Based on the provided method and related code, I'll generate test scenarios for the `Run` method of the `BreadthFirstSearch` class. Here are the test scenarios:

Scenario 1: Null Graph Handling

Details:
  TestName: ThrowArgumentNullExceptionWhenGraphIsNull
  Description: Verify that the method throws an ArgumentNullException when a null graph is passed.

Execution:
  Arrange: Create a BreadthFirstSearch instance and set up a null graph and a valid start vertex.
  Act: Call the Run method with the null graph and valid start vertex.
  Assert: Verify that an ArgumentNullException is thrown with the correct message.

Validation:
  This test ensures that the method properly handles null input for the graph parameter, maintaining robustness and preventing null reference exceptions later in the execution.

Scenario 2: Basic BFS Traversal

Details:
  TestName: CorrectlyTraversesSimpleGraph
  Description: Ensure that the BFS algorithm correctly traverses a simple graph and sets the correct distances and predecessors.

Execution:
  Arrange: Create a simple graph with known structure using UndirectedUnweightedGraph<BFSVertex>.
  Act: Run the BFS algorithm on the created graph starting from a specific vertex.
  Assert: Check that each vertex has the correct distance and predecessor set.

Validation:
  This test verifies that the core BFS algorithm is working correctly for a basic case, ensuring proper traversal order and distance calculation.

Scenario 3: Disconnected Graph Handling

Details:
  TestName: HandlesDisconnectedGraphCorrectly
  Description: Verify that the BFS algorithm correctly handles a disconnected graph, only traversing the connected component of the start vertex.

Execution:
  Arrange: Create a disconnected graph with two or more components using UndirectedUnweightedGraph<BFSVertex>.
  Act: Run the BFS algorithm starting from a vertex in one component.
  Assert: Verify that vertices in the start component are processed (have distances set) while vertices in other components remain unprocessed.

Validation:
  This test ensures that the BFS algorithm correctly handles disconnected graphs, which is important for real-world scenarios where not all nodes may be reachable.

Scenario 4: Cyclic Graph Traversal

Details:
  TestName: CorrectlyTraversesCyclicGraph
  Description: Ensure that the BFS algorithm correctly handles cycles in the graph without getting stuck in infinite loops.

Execution:
  Arrange: Create a graph with at least one cycle using UndirectedUnweightedGraph<BFSVertex>.
  Act: Run the BFS algorithm on the cyclic graph.
  Assert: Verify that all vertices are processed exactly once and have correct distances set.

Validation:
  This test is crucial to ensure that the BFS algorithm can handle graphs with cycles, which are common in many real-world scenarios.

Scenario 5: Large Graph Performance

Details:
  TestName: PerformsEfficientlyOnLargeGraph
  Description: Verify that the BFS algorithm can handle a large graph within a reasonable time frame.

Execution:
  Arrange: Create a large graph with many vertices and edges using UndirectedUnweightedGraph<BFSVertex>.
  Act: Run the BFS algorithm on the large graph and measure the execution time.
  Assert: Verify that the algorithm completes within an acceptable time limit and that all vertices are processed correctly.

Validation:
  This test ensures that the BFS implementation is efficient and can handle large-scale graphs, which is important for real-world applications with extensive data sets.

Scenario 6: Single Vertex Graph

Details:
  TestName: CorrectlyHandlesSingleVertexGraph
  Description: Ensure that the BFS algorithm correctly handles a graph with only one vertex.

Execution:
  Arrange: Create a graph with a single vertex using UndirectedUnweightedGraph<BFSVertex>.
  Act: Run the BFS algorithm on this single-vertex graph.
  Assert: Verify that the single vertex is processed correctly with a distance of 0 and no predecessor.

Validation:
  This test checks the edge case of a graph with only one vertex, ensuring that the algorithm handles this minimal case correctly.

These test scenarios cover various aspects of the BreadthFirstSearch.Run method, including error handling, basic functionality, and edge cases. They should provide a comprehensive test suite for the given method.


*/

// ********RoostGPT********
using NUnit.Framework;
using LunarDoggo.Datastructures.Graphs;
using LunarDoggo.Algorithms.Graphs.Pathfinding;
using System;
using System.Linq;

namespace LunarDoggo.Algorithms.Graphs.Pathfinding.Test
{
    [TestFixture]
    public class RunTest
    {
        private BreadthFirstSearch bfs;

        [SetUp]
        public void Setup()
        {
            bfs = new BreadthFirstSearch();
        }

        [Test, Category("invalid")]
        public void ThrowArgumentNullExceptionWhenGraphIsNull()
        {
            // Arrange
            IGraph<BFSVertex> graph = null;
            Vertex<BFSVertex> start = new Vertex<BFSVertex>(0, new BFSVertex());

            // Act & Assert
            Assert.Throws<ArgumentNullException>(() => bfs.Run(graph, start));
        }

        [Test, Category("valid")]
        public void CorrectlyTraversesSimpleGraph()
        {
            // Arrange
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);

            // Act
            bfs.Run(graph, v1);

            // Assert
            Assert.AreEqual(0, v1.Value.Distance);
            Assert.AreEqual(1, v2.Value.Distance);
            Assert.AreEqual(2, v3.Value.Distance);
            Assert.IsNull(v1.Value.Predecessor);
            Assert.AreEqual(v1, v2.Value.Predecessor);
            Assert.AreEqual(v2, v3.Value.Predecessor);
        }

        [Test, Category("valid")]
        public void HandlesDisconnectedGraphCorrectly()
        {
            // Arrange
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            var v4 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v3, v4);

            // Act
            bfs.Run(graph, v1);

            // Assert
            Assert.AreEqual(0, v1.Value.Distance);
            Assert.AreEqual(1, v2.Value.Distance);
            Assert.AreEqual(int.MaxValue, v3.Value.Distance);
            Assert.AreEqual(int.MaxValue, v4.Value.Distance);
            Assert.IsFalse(v3.Value.Processed);
            Assert.IsFalse(v4.Value.Processed);
        }

        [Test, Category("valid")]
        public void CorrectlyTraversesCyclicGraph()
        {
            // Arrange
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            var v4 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);
            graph.AddEdge(v3, v4);
            graph.AddEdge(v4, v1);

            // Act
            bfs.Run(graph, v1);

            // Assert
            Assert.AreEqual(0, v1.Value.Distance);
            Assert.AreEqual(1, v2.Value.Distance);
            Assert.AreEqual(1, v4.Value.Distance);
            Assert.AreEqual(2, v3.Value.Distance);
            Assert.IsTrue(v1.Value.Processed);
            Assert.IsTrue(v2.Value.Processed);
            Assert.IsTrue(v3.Value.Processed);
            Assert.IsTrue(v4.Value.Processed);
        }

        [Test, Category("valid")]
        public void PerformsEfficientlyOnLargeGraph()
        {
            // Arrange
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertices = Enumerable.Range(0, 10000).Select(_ => graph.AddVertex(new BFSVertex())).ToList();
            for (int i = 0; i < vertices.Count - 1; i++)
            {
                graph.AddEdge(vertices[i], vertices[i + 1]);
            }

            // Act
            var startTime = DateTime.Now;
            bfs.Run(graph, vertices[0]);
            var endTime = DateTime.Now;

            // Assert
            Assert.Less((endTime - startTime).TotalSeconds, 5); // Assuming 5 seconds is a reasonable time limit
            Assert.IsTrue(vertices.All(v => v.Value.Processed));
            Assert.AreEqual(vertices.Count - 1, vertices.Last().Value.Distance);
        }

        [Test, Category("boundary")]
        public void CorrectlyHandlesSingleVertexGraph()
        {
            // Arrange
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertex = graph.AddVertex(new BFSVertex());

            // Act
            bfs.Run(graph, vertex);

            // Assert
            Assert.AreEqual(0, vertex.Value.Distance);
            Assert.IsNull(vertex.Value.Predecessor);
            Assert.IsTrue(vertex.Value.Processed);
        }
    }
}
