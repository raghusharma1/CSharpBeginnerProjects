// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleCSharpEnv using AI Type  and AI Model 

ROOST_METHOD_HASH=Run_bbc3b7dcfd
ROOST_METHOD_SIG_HASH=Run_23f9485d25

   ########## Test-Scenarios ##########  

Based on the provided method and context, here are several test scenarios for the BreadthFirstSearch.Run method:

Scenario 1: Null Graph Handling

Details:
  TestName: ThrowsArgumentNullExceptionWhenGraphIsNull
  Description: Verify that the method throws an ArgumentNullException when a null graph is passed.

Execution:
  Arrange: Create a BreadthFirstSearch instance and a null IGraph<BFSVertex>.
  Act: Call the Run method with the null graph and a valid start vertex.
  Assert: Expect an ArgumentNullException to be thrown.

Validation:
  This test ensures that the method properly handles null input for the graph parameter, maintaining robustness and preventing null reference exceptions later in the execution.

Scenario 2: Single Vertex Graph

Details:
  TestName: ProcessesSingleVertexGraphCorrectly
  Description: Ensure the method correctly processes a graph with only one vertex.

Execution:
  Arrange: Create a BreadthFirstSearch instance and an IGraph<BFSVertex> with a single vertex.
  Act: Call the Run method with the graph and the single vertex as the start.
  Assert: Verify that the vertex's Distance is 0 and Processed is true.

Validation:
  This test confirms that the method correctly initializes and processes a trivial graph case, setting appropriate values for the single vertex.

Scenario 3: Linear Graph Traversal

Details:
  TestName: TraversesLinearGraphCorrectly
  Description: Verify correct traversal of a linear graph (vertices connected in a line).

Execution:
  Arrange: Create a BreadthFirstSearch instance and an IGraph<BFSVertex> with vertices connected linearly.
  Act: Call the Run method with the graph and the first vertex as the start.
  Assert: Check that each vertex's Distance increases by 1 and Predecessor is set correctly.

Validation:
  This test ensures that the BFS algorithm correctly traverses a simple linear graph, assigning proper distances and predecessors.

Scenario 4: Cyclic Graph Handling

Details:
  TestName: HandlesCyclicGraphWithoutInfiniteLoop
  Description: Ensure the method correctly processes a graph with cycles without getting stuck in an infinite loop.

Execution:
  Arrange: Create a BreadthFirstSearch instance and an IGraph<BFSVertex> with a cycle.
  Act: Call the Run method with the graph and any vertex as the start.
  Assert: Verify that all vertices are processed and have correct Distance and Predecessor values.

Validation:
  This test confirms that the BFS algorithm can handle cycles in the graph without revisiting already processed vertices.

Scenario 5: Disconnected Graph Components

Details:
  TestName: ProcessesOnlyReachableVerticesInDisconnectedGraph
  Description: Verify that only vertices reachable from the start vertex are processed in a disconnected graph.

Execution:
  Arrange: Create a BreadthFirstSearch instance and an IGraph<BFSVertex> with disconnected components.
  Act: Call the Run method with the graph and a vertex from one component as the start.
  Assert: Check that vertices in the same component as the start are processed, while others remain unprocessed.

Validation:
  This test ensures that the BFS algorithm correctly handles disconnected graphs, processing only the reachable vertices.

Scenario 6: Large Graph Performance

Details:
  TestName: CompletesLargeGraphTraversalInReasonableTime
  Description: Ensure the method can process a large graph within an acceptable time frame.

Execution:
  Arrange: Create a BreadthFirstSearch instance and a large IGraph<BFSVertex> (e.g., 10000 vertices).
  Act: Measure the time taken to call and complete the Run method.
  Assert: Verify that the execution time is within an acceptable limit.

Validation:
  This test checks the performance characteristics of the BFS implementation, ensuring it scales reasonably with large inputs.

Scenario 7: Correct Initialization of Vertices

Details:
  TestName: InitializesAllVerticesCorrectlyBeforeTraversal
  Description: Verify that all vertices are properly initialized before the BFS traversal begins.

Execution:
  Arrange: Create a BreadthFirstSearch instance and an IGraph<BFSVertex> with multiple vertices.
  Act: Call the Run method with the graph and a start vertex.
  Assert: Check that all vertices (except the start) initially had Distance set to Int32.MaxValue and Processed set to false.

Validation:
  This test ensures that the initialization step of the BFS algorithm correctly sets up all vertices before the traversal begins.

These test scenarios cover various aspects of the BreadthFirstSearch.Run method, including edge cases, error handling, and different graph structures. They aim to validate the correctness and robustness of the BFS implementation.


*/

// ********RoostGPT********
using NUnit.Framework;
using LunarDoggo.Datastructures.Graphs;
using LunarDoggo.Algorithms.Graphs.Pathfinding;
using System;
using System.Collections.Generic;
using System.Linq;

namespace LunarDoggo.Algorithms.Graphs.Pathfinding.Test
{
    [TestFixture]
    public class RunTest
    {
        private BreadthFirstSearch bfs;

        [SetUp]
        public void Setup()
        {
            bfs = new BreadthFirstSearch();
        }

        [Test, Category("invalid")]
        public void ThrowsArgumentNullExceptionWhenGraphIsNull()
        {
            IGraph<BFSVertex> nullGraph = null;
            Vertex<BFSVertex> startVertex = new Vertex<BFSVertex>(0, new BFSVertex());

            Assert.Throws<ArgumentNullException>(() => bfs.Run(nullGraph, startVertex));
        }

        [Test, Category("valid")]
        public void ProcessesSingleVertexGraphCorrectly()
        {
            UndirectedUnweightedGraph<BFSVertex> graph = new UndirectedUnweightedGraph<BFSVertex>();
            Vertex<BFSVertex> singleVertex = graph.AddVertex(new BFSVertex());

            bfs.Run(graph, singleVertex);

            Assert.That(singleVertex.Value.Distance, Is.EqualTo(0));
            Assert.That(singleVertex.Value.Processed, Is.True);
        }

        [Test, Category("valid")]
        public void TraversesLinearGraphCorrectly()
        {
            UndirectedUnweightedGraph<BFSVertex> graph = new UndirectedUnweightedGraph<BFSVertex>();
            Vertex<BFSVertex> v1 = graph.AddVertex(new BFSVertex());
            Vertex<BFSVertex> v2 = graph.AddVertex(new BFSVertex());
            Vertex<BFSVertex> v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);

            bfs.Run(graph, v1);

            Assert.That(v1.Value.Distance, Is.EqualTo(0));
            Assert.That(v2.Value.Distance, Is.EqualTo(1));
            Assert.That(v3.Value.Distance, Is.EqualTo(2));
            Assert.That(v2.Value.Predecessor, Is.EqualTo(v1));
            Assert.That(v3.Value.Predecessor, Is.EqualTo(v2));
        }

        [Test, Category("valid")]
        public void HandlesCyclicGraphWithoutInfiniteLoop()
        {
            UndirectedUnweightedGraph<BFSVertex> graph = new UndirectedUnweightedGraph<BFSVertex>();
            Vertex<BFSVertex> v1 = graph.AddVertex(new BFSVertex());
            Vertex<BFSVertex> v2 = graph.AddVertex(new BFSVertex());
            Vertex<BFSVertex> v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);
            graph.AddEdge(v3, v1);

            bfs.Run(graph, v1);

            Assert.That(v1.Value.Distance, Is.EqualTo(0));
            Assert.That(v2.Value.Distance, Is.EqualTo(1));
            Assert.That(v3.Value.Distance, Is.EqualTo(1));
            Assert.That(v1.Value.Processed && v2.Value.Processed && v3.Value.Processed, Is.True);
        }

        [Test, Category("valid")]
        public void ProcessesOnlyReachableVerticesInDisconnectedGraph()
        {
            UndirectedUnweightedGraph<BFSVertex> graph = new UndirectedUnweightedGraph<BFSVertex>();
            Vertex<BFSVertex> v1 = graph.AddVertex(new BFSVertex());
            Vertex<BFSVertex> v2 = graph.AddVertex(new BFSVertex());
            Vertex<BFSVertex> v3 = graph.AddVertex(new BFSVertex());
            Vertex<BFSVertex> v4 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v3, v4);

            bfs.Run(graph, v1);

            Assert.That(v1.Value.Processed && v2.Value.Processed, Is.True);
            Assert.That(v3.Value.Processed || v4.Value.Processed, Is.False);
        }

        [Test, Category("valid")]
        public void CompletesLargeGraphTraversalInReasonableTime()
        {
            UndirectedUnweightedGraph<BFSVertex> graph = new UndirectedUnweightedGraph<BFSVertex>();
            Vertex<BFSVertex> start = graph.AddVertex(new BFSVertex());
            for (int i = 0; i < 9999; i++)
            {
                Vertex<BFSVertex> v = graph.AddVertex(new BFSVertex());
                graph.AddEdge(start, v);
            }

            DateTime startTime = DateTime.Now;
            bfs.Run(graph, start);
            TimeSpan duration = DateTime.Now - startTime;

            Assert.That(duration.TotalSeconds, Is.LessThan(5)); // Adjust the time limit as needed
            Assert.That(graph.Vertices.All(v => v.Value.Processed), Is.True);
        }

        [Test, Category("valid")]
        public void InitializesAllVerticesCorrectlyBeforeTraversal()
        {
            UndirectedUnweightedGraph<BFSVertex> graph = new UndirectedUnweightedGraph<BFSVertex>();
            Vertex<BFSVertex> v1 = graph.AddVertex(new BFSVertex());
            Vertex<BFSVertex> v2 = graph.AddVertex(new BFSVertex());
            Vertex<BFSVertex> v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);

            bfs.Run(graph, v1);

            Assert.That(v1.Value.Distance, Is.EqualTo(0));
            Assert.That(v2.Value.Distance, Is.EqualTo(1));
            Assert.That(v3.Value.Distance, Is.EqualTo(2));
            Assert.That(v1.Value.Predecessor, Is.Null);
            Assert.That(v2.Value.Predecessor, Is.EqualTo(v1));
            Assert.That(v3.Value.Predecessor, Is.EqualTo(v2));
        }
    }
}
