// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleCSharpEnv using AI Type  and AI Model 

ROOST_METHOD_HASH=Run_bbc3b7dcfd
ROOST_METHOD_SIG_HASH=Run_23f9485d25

   ########## Test-Scenarios ##########  

Based on the provided method and related code, here are several test scenarios for the `Run` method of the `BreadthFirstSearch` class:

Scenario 1: Null Graph Handling

Details:
  TestName: ThrowArgumentNullExceptionWhenGraphIsNull
  Description: Verify that the method throws an ArgumentNullException when a null graph is provided.
Execution:
  Arrange: Create a BreadthFirstSearch instance and set up a null graph and a valid start vertex.
  Act: Call the Run method with the null graph and valid start vertex.
  Assert: Verify that an ArgumentNullException is thrown with the correct message.
Validation:
  This test ensures that the method properly handles null input for the graph parameter, maintaining robustness and preventing null reference exceptions later in the execution.

Scenario 2: Single Vertex Graph

Details:
  TestName: ProcessSingleVertexGraphCorrectly
  Description: Ensure the method correctly processes a graph with only one vertex.
Execution:
  Arrange: Create a graph with a single vertex and set it as the start vertex.
  Act: Run the BFS algorithm on this graph.
  Assert: Check that the vertex is processed, its distance is 0, and it has no predecessor.
Validation:
  This test verifies that the BFS algorithm works correctly for the simplest possible graph, setting a baseline for more complex scenarios.

Scenario 3: Linear Graph Traversal

Details:
  TestName: TraverseLinearGraphCorrectly
  Description: Verify correct traversal and distance calculation in a linear graph (A -> B -> C -> D).
Execution:
  Arrange: Create a linear graph with 4 vertices and set the first vertex as the start.
  Act: Run the BFS algorithm on this graph.
  Assert: Check that all vertices are processed, distances are correctly set (0, 1, 2, 3), and predecessors are properly assigned.
Validation:
  This test ensures that the BFS algorithm correctly traverses a simple linear path, assigning correct distances and predecessors.

Scenario 4: Branching Graph Traversal

Details:
  TestName: TraverseBranchingGraphCorrectly
  Description: Verify correct traversal and distance calculation in a branching graph (A -> B -> C, A -> D -> E).
Execution:
  Arrange: Create a branching graph and set the root (A) as the start vertex.
  Act: Run the BFS algorithm on this graph.
  Assert: Verify that all vertices are processed, distances are correct (A:0, B:1, C:2, D:1, E:2), and predecessors are properly assigned.
Validation:
  This test checks if the BFS algorithm correctly handles branching paths, ensuring breadth-first order is maintained.

Scenario 5: Cyclic Graph Handling

Details:
  TestName: HandleCyclicGraphCorrectly
  Description: Ensure the algorithm correctly processes a graph with cycles without getting stuck in an infinite loop.
Execution:
  Arrange: Create a cyclic graph (e.g., A -> B -> C -> A) and set any vertex as the start.
  Act: Run the BFS algorithm on this graph.
  Assert: Check that all vertices are processed exactly once, distances are correct, and the algorithm terminates.
Validation:
  This test verifies that the BFS algorithm can handle cycles in the graph without issues, which is crucial for its correctness and termination.

Scenario 6: Disconnected Graph Components

Details:
  TestName: ProcessOnlyReachableVerticesInDisconnectedGraph
  Description: Verify that only vertices reachable from the start vertex are processed in a disconnected graph.
Execution:
  Arrange: Create a graph with two disconnected components and set a start vertex in one component.
  Act: Run the BFS algorithm on this graph.
  Assert: Check that only vertices in the component with the start vertex are processed, while others remain unprocessed.
Validation:
  This test ensures that the BFS algorithm correctly handles disconnected graphs, processing only the reachable portion from the start vertex.

Scenario 7: Large Graph Performance

Details:
  TestName: CompleteTraversalOfLargeGraphWithinReasonableTime
  Description: Ensure the algorithm can process a large graph (e.g., 10000 vertices) within a reasonable time frame.
Execution:
  Arrange: Generate a large graph with many vertices and edges.
  Act: Run the BFS algorithm on this large graph and measure the execution time.
  Assert: Verify that all vertices are processed and the execution completes within an acceptable time limit.
Validation:
  This test checks the performance and scalability of the BFS implementation for large graphs, ensuring it remains efficient for practical use cases.

These test scenarios cover various aspects of the BreadthFirstSearch.Run method, including error handling, correct traversal in different graph structures, cycle handling, and performance considerations.


*/

// ********RoostGPT********
using NUnit.Framework;
using LunarDoggo.Datastructures.Graphs;
using LunarDoggo.Algorithms.Graphs.Pathfinding;
using System;
using System.Linq;

namespace LunarDoggo.Algorithms.Graphs.Pathfinding.Test
{
    [TestFixture]
    public class RunTest
    {
        [Test, Category("invalid")]
        public void ThrowArgumentNullExceptionWhenGraphIsNull()
        {
            var bfs = new BreadthFirstSearch();
            var startVertex = new Vertex<BFSVertex>(0, new BFSVertex());

            Assert.Throws<ArgumentNullException>(() => bfs.Run(null, startVertex));
        }

        [Test, Category("valid")]
        public void ProcessSingleVertexGraphCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertex = graph.AddVertex(new BFSVertex());
            var bfs = new BreadthFirstSearch();

            bfs.Run(graph, vertex);

            Assert.That(vertex.Value.Processed, Is.True);
            Assert.That(vertex.Value.Distance, Is.EqualTo(0));
            Assert.That(vertex.Value.Predecessor, Is.Null);
        }

        [Test, Category("valid")]
        public void TraverseLinearGraphCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertexA = graph.AddVertex(new BFSVertex());
            var vertexB = graph.AddVertex(new BFSVertex());
            var vertexC = graph.AddVertex(new BFSVertex());
            var vertexD = graph.AddVertex(new BFSVertex());

            graph.AddEdge(vertexA, vertexB);
            graph.AddEdge(vertexB, vertexC);
            graph.AddEdge(vertexC, vertexD);

            var bfs = new BreadthFirstSearch();
            bfs.Run(graph, vertexA);

            Assert.That(vertexA.Value.Distance, Is.EqualTo(0));
            Assert.That(vertexB.Value.Distance, Is.EqualTo(1));
            Assert.That(vertexC.Value.Distance, Is.EqualTo(2));
            Assert.That(vertexD.Value.Distance, Is.EqualTo(3));

            Assert.That(vertexA.Value.Predecessor, Is.Null);
            Assert.That(vertexB.Value.Predecessor, Is.EqualTo(vertexA));
            Assert.That(vertexC.Value.Predecessor, Is.EqualTo(vertexB));
            Assert.That(vertexD.Value.Predecessor, Is.EqualTo(vertexC));
        }

        [Test, Category("valid")]
        public void TraverseBranchingGraphCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertexA = graph.AddVertex(new BFSVertex());
            var vertexB = graph.AddVertex(new BFSVertex());
            var vertexC = graph.AddVertex(new BFSVertex());
            var vertexD = graph.AddVertex(new BFSVertex());
            var vertexE = graph.AddVertex(new BFSVertex());

            graph.AddEdge(vertexA, vertexB);
            graph.AddEdge(vertexB, vertexC);
            graph.AddEdge(vertexA, vertexD);
            graph.AddEdge(vertexD, vertexE);

            var bfs = new BreadthFirstSearch();
            bfs.Run(graph, vertexA);

            Assert.That(vertexA.Value.Distance, Is.EqualTo(0));
            Assert.That(vertexB.Value.Distance, Is.EqualTo(1));
            Assert.That(vertexC.Value.Distance, Is.EqualTo(2));
            Assert.That(vertexD.Value.Distance, Is.EqualTo(1));
            Assert.That(vertexE.Value.Distance, Is.EqualTo(2));

            Assert.That(vertexA.Value.Predecessor, Is.Null);
            Assert.That(vertexB.Value.Predecessor, Is.EqualTo(vertexA));
            Assert.That(vertexC.Value.Predecessor, Is.EqualTo(vertexB));
            Assert.That(vertexD.Value.Predecessor, Is.EqualTo(vertexA));
            Assert.That(vertexE.Value.Predecessor, Is.EqualTo(vertexD));
        }

        [Test, Category("valid")]
        public void HandleCyclicGraphCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertexA = graph.AddVertex(new BFSVertex());
            var vertexB = graph.AddVertex(new BFSVertex());
            var vertexC = graph.AddVertex(new BFSVertex());

            graph.AddEdge(vertexA, vertexB);
            graph.AddEdge(vertexB, vertexC);
            graph.AddEdge(vertexC, vertexA);

            var bfs = new BreadthFirstSearch();
            bfs.Run(graph, vertexA);

            Assert.That(vertexA.Value.Distance, Is.EqualTo(0));
            Assert.That(vertexB.Value.Distance, Is.EqualTo(1));
            Assert.That(vertexC.Value.Distance, Is.EqualTo(1));

            Assert.That(vertexA.Value.Predecessor, Is.Null);
            Assert.That(vertexB.Value.Predecessor, Is.EqualTo(vertexA));
            Assert.That(vertexC.Value.Predecessor, Is.EqualTo(vertexA));
        }

        [Test, Category("valid")]
        public void ProcessOnlyReachableVerticesInDisconnectedGraph()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertexA = graph.AddVertex(new BFSVertex());
            var vertexB = graph.AddVertex(new BFSVertex());
            var vertexC = graph.AddVertex(new BFSVertex());
            var vertexD = graph.AddVertex(new BFSVertex());
            var vertexE = graph.AddVertex(new BFSVertex());

            graph.AddEdge(vertexA, vertexB);
            graph.AddEdge(vertexB, vertexC);
            graph.AddEdge(vertexD, vertexE);

            var bfs = new BreadthFirstSearch();
            bfs.Run(graph, vertexA);

            Assert.That(vertexA.Value.Processed, Is.True);
            Assert.That(vertexB.Value.Processed, Is.True);
            Assert.That(vertexC.Value.Processed, Is.True);
            Assert.That(vertexD.Value.Processed, Is.False);
            Assert.That(vertexE.Value.Processed, Is.False);
        }

        [Test, Category("valid")]
        public void CompleteTraversalOfLargeGraphWithinReasonableTime()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertices = new Vertex<BFSVertex>[10000];

            for (int i = 0; i < 10000; i++)
            {
                vertices[i] = graph.AddVertex(new BFSVertex());
            }

            for (int i = 0; i < 9999; i++)
            {
                graph.AddEdge(vertices[i], vertices[i + 1]);
            }

            var bfs = new BreadthFirstSearch();
            var startTime = DateTime.Now;
            bfs.Run(graph, vertices[0]);
            var endTime = DateTime.Now;

            Assert.That((endTime - startTime).TotalSeconds, Is.LessThan(5));
            Assert.That(graph.Vertices.All(v => v.Value.Processed), Is.True);
        }
    }
}
