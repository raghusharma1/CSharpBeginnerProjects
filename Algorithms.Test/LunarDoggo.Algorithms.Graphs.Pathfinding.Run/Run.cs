// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleCSharpEnv using AI Type  and AI Model 

ROOST_METHOD_HASH=Run_bbc3b7dcfd
ROOST_METHOD_SIG_HASH=Run_23f9485d25

   ########## Test-Scenarios ##########  

Based on the provided method and context, here are several test scenarios for the `Run` method of the `BreadthFirstSearch` class:

Scenario 1: Null Graph Input

Details:
  TestName: ThrowsArgumentNullExceptionWhenGraphIsNull
  Description: Verify that the method throws an ArgumentNullException when a null graph is provided.
Execution:
  Arrange: Create a BreadthFirstSearch instance and set up a null graph and a valid start vertex.
  Act: Call the Run method with the null graph and valid start vertex.
  Assert: Verify that an ArgumentNullException is thrown with the correct message.
Validation:
  This test ensures that the method properly handles null input for the graph parameter, maintaining robustness and preventing null reference exceptions later in the execution.

Scenario 2: Valid Graph with Single Vertex

Details:
  TestName: ProcessesSingleVertexGraphCorrectly
  Description: Ensure the method correctly processes a graph with only one vertex (the start vertex).
Execution:
  Arrange: Create a BreadthFirstSearch instance, a graph with a single vertex, and set this vertex as the start vertex.
  Act: Call the Run method with the graph and start vertex.
  Assert: Verify that the start vertex is processed (Processed = true) and has a Distance of 0.
Validation:
  This test confirms that the method correctly initializes and processes the simplest possible graph, setting the base case for more complex scenarios.

Scenario 3: Graph with Multiple Vertices but No Edges

Details:
  TestName: ProcessesDisconnectedGraphCorrectly
  Description: Verify that the method correctly handles a graph with multiple vertices but no connecting edges.
Execution:
  Arrange: Create a BreadthFirstSearch instance, a graph with multiple vertices but no edges, and select one vertex as the start.
  Act: Call the Run method with the graph and start vertex.
  Assert: Verify that only the start vertex is processed and has a Distance of 0, while all other vertices remain unprocessed with Distance set to Int32.MaxValue.
Validation:
  This test ensures that the method correctly handles disconnected graphs, processing only the reachable vertices (in this case, just the start vertex).

Scenario 4: Simple Connected Graph

Details:
  TestName: ProcessesSimpleConnectedGraphCorrectly
  Description: Ensure the method correctly processes a simple connected graph with a few vertices and edges.
Execution:
  Arrange: Create a BreadthFirstSearch instance, a small connected graph (e.g., 3-4 vertices with connecting edges), and select a start vertex.
  Act: Call the Run method with the graph and start vertex.
  Assert: Verify that all vertices are processed, have correct Distance values (increasing by 1 for each level away from the start), and have correct Predecessor assignments.
Validation:
  This test confirms that the basic breadth-first search algorithm is working correctly for a simple, fully connected graph.

Scenario 5: Graph with Cycles

Details:
  TestName: HandlesGraphWithCyclesCorrectly
  Description: Verify that the method correctly processes a graph containing cycles without getting stuck in an infinite loop.
Execution:
  Arrange: Create a BreadthFirstSearch instance, a graph with cycles (e.g., A -> B -> C -> A), and select a start vertex.
  Act: Call the Run method with the graph and start vertex.
  Assert: Verify that all vertices are processed exactly once, have correct Distance values, and have correct Predecessor assignments.
Validation:
  This test ensures that the method can handle graphs with cycles without revisiting already processed vertices, which is crucial for the correctness of the breadth-first search algorithm.

Scenario 6: Large Graph Performance

Details:
  TestName: ProcessesLargeGraphWithinReasonableTime
  Description: Ensure the method can process a large graph within a reasonable time frame.
Execution:
  Arrange: Create a BreadthFirstSearch instance, generate a large graph (e.g., 10000+ vertices with random connections), and select a start vertex.
  Act: Measure the time taken to call and complete the Run method with the large graph and start vertex.
  Assert: Verify that the method completes within a specified time limit and that all vertices are processed correctly.
Validation:
  This test checks the performance and scalability of the implementation, ensuring it can handle large graphs efficiently.

These scenarios cover various aspects of the BreadthFirstSearch.Run method, including error handling, correctness for different graph structures, and performance considerations.


*/

// ********RoostGPT********
using NUnit.Framework;
using LunarDoggo.Datastructures.Graphs;
using LunarDoggo.Algorithms.Graphs.Pathfinding;
using System;
using System.Linq;

namespace LunarDoggo.Algorithms.Graphs.Pathfinding.Test
{
    [TestFixture]
    public class RunTest
    {
        private BreadthFirstSearch bfs;

        [SetUp]
        public void Setup()
        {
            bfs = new BreadthFirstSearch();
        }

        [Test, Category("invalid")]
        public void ThrowsArgumentNullExceptionWhenGraphIsNull()
        {
            var startVertex = new Vertex<BFSVertex>(0, new BFSVertex());

            Assert.Throws<ArgumentNullException>(() => bfs.Run(null, startVertex));
        }

        [Test, Category("valid")]
        public void ProcessesSingleVertexGraphCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var startVertex = graph.AddVertex(new BFSVertex());

            bfs.Run(graph, startVertex);

            Assert.IsTrue(startVertex.Value.Processed);
            Assert.AreEqual(0, startVertex.Value.Distance);
        }

        [Test, Category("valid")]
        public void ProcessesDisconnectedGraphCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var startVertex = graph.AddVertex(new BFSVertex());
            var disconnectedVertex = graph.AddVertex(new BFSVertex());

            bfs.Run(graph, startVertex);

            Assert.IsTrue(startVertex.Value.Processed);
            Assert.AreEqual(0, startVertex.Value.Distance);
            Assert.IsFalse(disconnectedVertex.Value.Processed);
            Assert.AreEqual(int.MaxValue, disconnectedVertex.Value.Distance);
        }

        [Test, Category("valid")]
        public void ProcessesSimpleConnectedGraphCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertexA = graph.AddVertex(new BFSVertex());
            var vertexB = graph.AddVertex(new BFSVertex());
            var vertexC = graph.AddVertex(new BFSVertex());
            graph.AddEdge(vertexA, vertexB);
            graph.AddEdge(vertexB, vertexC);

            bfs.Run(graph, vertexA);

            Assert.IsTrue(vertexA.Value.Processed);
            Assert.IsTrue(vertexB.Value.Processed);
            Assert.IsTrue(vertexC.Value.Processed);
            Assert.AreEqual(0, vertexA.Value.Distance);
            Assert.AreEqual(1, vertexB.Value.Distance);
            Assert.AreEqual(2, vertexC.Value.Distance);
            Assert.AreEqual(vertexA, vertexB.Value.Predecessor);
            Assert.AreEqual(vertexB, vertexC.Value.Predecessor);
        }

        [Test, Category("valid")]
        public void HandlesGraphWithCyclesCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertexA = graph.AddVertex(new BFSVertex());
            var vertexB = graph.AddVertex(new BFSVertex());
            var vertexC = graph.AddVertex(new BFSVertex());
            graph.AddEdge(vertexA, vertexB);
            graph.AddEdge(vertexB, vertexC);
            graph.AddEdge(vertexC, vertexA);

            bfs.Run(graph, vertexA);

            Assert.IsTrue(vertexA.Value.Processed);
            Assert.IsTrue(vertexB.Value.Processed);
            Assert.IsTrue(vertexC.Value.Processed);
            Assert.AreEqual(0, vertexA.Value.Distance);
            Assert.AreEqual(1, vertexB.Value.Distance);
            Assert.AreEqual(1, vertexC.Value.Distance);
            Assert.AreEqual(vertexA, vertexB.Value.Predecessor);
            Assert.AreEqual(vertexA, vertexC.Value.Predecessor);
        }

        [Test, Category("valid")]
        public void ProcessesLargeGraphWithinReasonableTime()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertices = Enumerable.Range(0, 10000).Select(_ => graph.AddVertex(new BFSVertex())).ToList();
            
            // Add random connections
            var random = new Random(42);
            for (int i = 0; i < 20000; i++)
            {
                int from = random.Next(vertices.Count);
                int to = random.Next(vertices.Count);
                if (from != to)
                {
                    graph.AddEdge(vertices[from], vertices[to]);
                }
            }

            var startTime = DateTime.Now;
            bfs.Run(graph, vertices[0]);
            var duration = DateTime.Now - startTime;

            Assert.Less(duration.TotalSeconds, 5, "BFS took too long to process the large graph");
            Assert.IsTrue(vertices.All(v => v.Value.Processed), "Not all vertices were processed");
        }
    }
}
