// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleCSharpEnv using AI Type  and AI Model 

ROOST_METHOD_HASH=Run_bbc3b7dcfd
ROOST_METHOD_SIG_HASH=Run_23f9485d25

   ########## Test-Scenarios ##########  

Based on the provided method and context, here are several test scenarios for the BreadthFirstSearch.Run method:

Scenario 1: Null Graph Handling

Details:
  TestName: ThrowsArgumentNullExceptionWhenGraphIsNull
  Description: Verify that the method throws an ArgumentNullException when a null graph is passed.

Execution:
  Arrange: Create a BreadthFirstSearch instance and a null IGraph<BFSVertex>.
  Act: Call the Run method with the null graph and a valid start vertex.
  Assert: Expect an ArgumentNullException to be thrown.

Validation:
  This test ensures that the method properly handles null input for the graph parameter, maintaining robustness and preventing null reference exceptions later in the execution.

Scenario 2: Single Vertex Graph

Details:
  TestName: ProcessesSingleVertexGraphCorrectly
  Description: Ensure the method correctly processes a graph with only one vertex.

Execution:
  Arrange: Create a BreadthFirstSearch instance and an IGraph<BFSVertex> with a single vertex.
  Act: Call the Run method with the graph and the single vertex as the start.
  Assert: Verify that the vertex's Distance is 0 and Processed is true.

Validation:
  This test confirms that the algorithm works correctly for the simplest possible graph, setting the correct distance and processed state for the start vertex.

Scenario 3: Linear Graph Traversal

Details:
  TestName: TraversesLinearGraphCorrectly
  Description: Verify correct traversal of a linear graph (vertices connected in a line).

Execution:
  Arrange: Create a BreadthFirstSearch instance and an IGraph<BFSVertex> with vertices connected linearly (A -> B -> C -> D).
  Act: Call the Run method with the graph and vertex A as the start.
  Assert: Check that each vertex has the correct Distance (0, 1, 2, 3) and Predecessor.

Validation:
  This test ensures that the BFS algorithm correctly traverses a simple linear graph, assigning proper distances and predecessors.

Scenario 4: Cyclic Graph Handling

Details:
  TestName: HandlesCyclicGraphWithoutInfiniteLoop
  Description: Ensure the method correctly processes a graph with cycles without getting stuck in an infinite loop.

Execution:
  Arrange: Create a BreadthFirstSearch instance and an IGraph<BFSVertex> with a cycle (A -> B -> C -> A).
  Act: Call the Run method with the graph and any vertex as the start.
  Assert: Verify that all vertices are processed and have correct distances.

Validation:
  This test confirms that the algorithm can handle cycles in the graph without revisiting already processed nodes, which is crucial for preventing infinite loops.

Scenario 5: Disconnected Graph Components

Details:
  TestName: ProcessesOnlyReachableVerticesInDisconnectedGraph
  Description: Verify that only vertices reachable from the start vertex are processed in a disconnected graph.

Execution:
  Arrange: Create a BreadthFirstSearch instance and an IGraph<BFSVertex> with two disconnected components.
  Act: Call the Run method with the graph and a vertex from one component as the start.
  Assert: Check that vertices in the start component are processed and have distances set, while vertices in the other component remain unprocessed with max distance.

Validation:
  This test ensures that the BFS algorithm correctly handles disconnected graphs, processing only the reachable vertices from the start point.

Scenario 6: Large Graph Performance

Details:
  TestName: CompletesLargeGraphTraversalInReasonableTime
  Description: Ensure the method can process a large graph within an acceptable time frame.

Execution:
  Arrange: Create a BreadthFirstSearch instance and a large IGraph<BFSVertex> (e.g., 10000 vertices).
  Act: Measure the time taken to call and complete the Run method.
  Assert: Verify that the execution time is within an acceptable limit.

Validation:
  This test checks the performance characteristics of the BFS implementation, ensuring it can handle large graphs efficiently.

Scenario 7: Correct Predecessor Assignment

Details:
  TestName: AssignsCorrectPredecessorsInComplexGraph
  Description: Verify that the method correctly assigns predecessors in a complex graph structure.

Execution:
  Arrange: Create a BreadthFirstSearch instance and an IGraph<BFSVertex> with a complex structure (including multiple paths between vertices).
  Act: Call the Run method with the graph and a chosen start vertex.
  Assert: Check that each vertex (except the start) has a predecessor that is one step closer to the start vertex.

Validation:
  This test ensures that the BFS algorithm correctly builds the shortest path tree by assigning appropriate predecessors to each vertex.

These test scenarios cover various aspects of the BreadthFirstSearch.Run method, including error handling, correctness for different graph structures, and performance considerations.


*/

// ********RoostGPT********
using NUnit.Framework;
using LunarDoggo.Datastructures.Graphs;
using LunarDoggo.Algorithms.Graphs.Pathfinding;
using System;
using System.Linq;

namespace LunarDoggo.Algorithms.Graphs.Pathfinding.Test
{
    [TestFixture]
    public class RunTest
    {
        private BreadthFirstSearch bfs;

        [SetUp]
        public void Setup()
        {
            bfs = new BreadthFirstSearch();
        }

        [Test, Category("invalid")]
        public void ThrowsArgumentNullExceptionWhenGraphIsNull()
        {
            IGraph<BFSVertex> nullGraph = null;
            Vertex<BFSVertex> startVertex = new Vertex<BFSVertex>(0, new BFSVertex());

            Assert.Throws<ArgumentNullException>(() => bfs.Run(nullGraph, startVertex));
        }

        [Test, Category("valid")]
        public void ProcessesSingleVertexGraphCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertex = graph.AddVertex(new BFSVertex());

            bfs.Run(graph, vertex);

            Assert.That(vertex.Value.Distance, Is.EqualTo(0));
            Assert.That(vertex.Value.Processed, Is.True);
        }

        [Test, Category("valid")]
        public void TraversesLinearGraphCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertexA = graph.AddVertex(new BFSVertex());
            var vertexB = graph.AddVertex(new BFSVertex());
            var vertexC = graph.AddVertex(new BFSVertex());
            var vertexD = graph.AddVertex(new BFSVertex());

            graph.AddEdge(vertexA, vertexB);
            graph.AddEdge(vertexB, vertexC);
            graph.AddEdge(vertexC, vertexD);

            bfs.Run(graph, vertexA);

            Assert.That(vertexA.Value.Distance, Is.EqualTo(0));
            Assert.That(vertexB.Value.Distance, Is.EqualTo(1));
            Assert.That(vertexC.Value.Distance, Is.EqualTo(2));
            Assert.That(vertexD.Value.Distance, Is.EqualTo(3));

            Assert.That(vertexB.Value.Predecessor, Is.EqualTo(vertexA));
            Assert.That(vertexC.Value.Predecessor, Is.EqualTo(vertexB));
            Assert.That(vertexD.Value.Predecessor, Is.EqualTo(vertexC));
        }

        [Test, Category("valid")]
        public void HandlesCyclicGraphWithoutInfiniteLoop()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertexA = graph.AddVertex(new BFSVertex());
            var vertexB = graph.AddVertex(new BFSVertex());
            var vertexC = graph.AddVertex(new BFSVertex());

            graph.AddEdge(vertexA, vertexB);
            graph.AddEdge(vertexB, vertexC);
            graph.AddEdge(vertexC, vertexA);

            bfs.Run(graph, vertexA);

            Assert.That(vertexA.Value.Distance, Is.EqualTo(0));
            Assert.That(vertexB.Value.Distance, Is.EqualTo(1));
            Assert.That(vertexC.Value.Distance, Is.EqualTo(1));

            Assert.That(vertexA.Value.Processed, Is.True);
            Assert.That(vertexB.Value.Processed, Is.True);
            Assert.That(vertexC.Value.Processed, Is.True);
        }

        [Test, Category("valid")]
        public void ProcessesOnlyReachableVerticesInDisconnectedGraph()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertexA = graph.AddVertex(new BFSVertex());
            var vertexB = graph.AddVertex(new BFSVertex());
            var vertexC = graph.AddVertex(new BFSVertex());
            var vertexD = graph.AddVertex(new BFSVertex());

            graph.AddEdge(vertexA, vertexB);
            graph.AddEdge(vertexC, vertexD);

            bfs.Run(graph, vertexA);

            Assert.That(vertexA.Value.Distance, Is.EqualTo(0));
            Assert.That(vertexB.Value.Distance, Is.EqualTo(1));
            Assert.That(vertexC.Value.Distance, Is.EqualTo(int.MaxValue));
            Assert.That(vertexD.Value.Distance, Is.EqualTo(int.MaxValue));

            Assert.That(vertexA.Value.Processed, Is.True);
            Assert.That(vertexB.Value.Processed, Is.True);
            Assert.That(vertexC.Value.Processed, Is.False);
            Assert.That(vertexD.Value.Processed, Is.False);
        }

        [Test, Category("valid")]
        public void CompletesLargeGraphTraversalInReasonableTime()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertices = Enumerable.Range(0, 10000).Select(_ => graph.AddVertex(new BFSVertex())).ToList();

            for (int i = 0; i < vertices.Count - 1; i++)
            {
                graph.AddEdge(vertices[i], vertices[i + 1]);
            }

            var startTime = DateTime.Now;
            bfs.Run(graph, vertices[0]);
            var endTime = DateTime.Now;

            var duration = (endTime - startTime).TotalSeconds;
            Assert.That(duration, Is.LessThan(5), "BFS took too long to complete");

            Assert.That(vertices.All(v => v.Value.Processed), Is.True);
        }

        [Test, Category("valid")]
        public void AssignsCorrectPredecessorsInComplexGraph()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertexA = graph.AddVertex(new BFSVertex());
            var vertexB = graph.AddVertex(new BFSVertex());
            var vertexC = graph.AddVertex(new BFSVertex());
            var vertexD = graph.AddVertex(new BFSVertex());
            var vertexE = graph.AddVertex(new BFSVertex());

            graph.AddEdge(vertexA, vertexB);
            graph.AddEdge(vertexA, vertexC);
            graph.AddEdge(vertexB, vertexD);
            graph.AddEdge(vertexC, vertexD);
            graph.AddEdge(vertexD, vertexE);

            bfs.Run(graph, vertexA);

            Assert.That(vertexB.Value.Predecessor, Is.EqualTo(vertexA));
            Assert.That(vertexC.Value.Predecessor, Is.EqualTo(vertexA));
            Assert.That(vertexD.Value.Predecessor, Is.AnyOf(vertexB, vertexC));
            Assert.That(vertexE.Value.Predecessor, Is.EqualTo(vertexD));
        }
    }
}
