// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleCSharpEnv using AI Type  and AI Model 

ROOST_METHOD_HASH=Run_bbc3b7dcfd
ROOST_METHOD_SIG_HASH=Run_23f9485d25

   ########## Test-Scenarios ##########  

Based on the provided method and related code, I'll generate test scenarios for the `Run` method of the `BreadthFirstSearch` class. Here are the test scenarios:

Scenario 1: Null Graph Handling

Details:
  TestName: ThrowArgumentNullExceptionWhenGraphIsNull
  Description: Verify that the method throws an ArgumentNullException when a null graph is passed.

Execution:
  Arrange: Create a BreadthFirstSearch instance and set up a null graph and a valid start vertex.
  Act: Call the Run method with the null graph and valid start vertex.
  Assert: Verify that an ArgumentNullException is thrown with the correct message.

Validation:
  This test ensures that the method properly handles null input for the graph parameter, maintaining robustness and preventing null reference exceptions later in the execution.

Scenario 2: Basic BFS Traversal

Details:
  TestName: CorrectlyTraversesSimpleGraph
  Description: Ensure that the BFS algorithm correctly traverses a simple graph and sets the correct distances and predecessors.

Execution:
  Arrange: Create a simple graph with known structure using UndirectedUnweightedGraph<BFSVertex>.
  Act: Run the BFS algorithm on the created graph.
  Assert: Check that each vertex has the correct distance and predecessor set.

Validation:
  This test verifies that the core BFS algorithm is working correctly for a basic case, ensuring proper distance calculation and predecessor assignment.

Scenario 3: Isolated Vertices Handling

Details:
  TestName: HandlesGraphWithIsolatedVertices
  Description: Verify that the BFS algorithm correctly handles graphs with isolated vertices.

Execution:
  Arrange: Create a graph with some connected vertices and some isolated vertices.
  Act: Run the BFS algorithm on this graph.
  Assert: Check that isolated vertices have maximum distance and null predecessors, while connected vertices have correct distances and predecessors.

Validation:
  This test ensures that the algorithm correctly handles graphs that are not fully connected, which is a common edge case in graph problems.

Scenario 4: Single Vertex Graph

Details:
  TestName: CorrectlyHandlesSingleVertexGraph
  Description: Ensure that the BFS algorithm works correctly on a graph with only one vertex.

Execution:
  Arrange: Create a graph with a single vertex.
  Act: Run the BFS algorithm on this graph.
  Assert: Verify that the single vertex has a distance of 0 and null predecessor.

Validation:
  This test checks the algorithm's behavior in the minimal possible graph, which is an important edge case.

Scenario 5: Cyclic Graph Traversal

Details:
  TestName: CorrectlyTraversesCyclicGraph
  Description: Verify that the BFS algorithm correctly handles graphs with cycles.

Execution:
  Arrange: Create a graph with known cycles.
  Act: Run the BFS algorithm on the cyclic graph.
  Assert: Check that despite the cycles, each vertex is processed only once and has the correct minimum distance from the start vertex.

Validation:
  This test ensures that the algorithm doesn't get stuck in infinite loops and correctly handles cyclic structures in graphs.

Scenario 6: Large Graph Performance

Details:
  TestName: PerformsEfficientlyOnLargeGraph
  Description: Ensure that the BFS algorithm performs efficiently on a large graph.

Execution:
  Arrange: Create a large graph with many vertices and edges.
  Act: Run the BFS algorithm on the large graph and measure the execution time.
  Assert: Verify that the execution time is within acceptable bounds and that all vertices are correctly processed.

Validation:
  This test checks the algorithm's performance and scalability, which is crucial for real-world applications dealing with large datasets.

Scenario 7: Start Vertex Initialization

Details:
  TestName: CorrectlyInitializesStartVertex
  Description: Verify that the start vertex is correctly initialized with distance 0 and processed state.

Execution:
  Arrange: Create a graph and choose a start vertex.
  Act: Run the BFS algorithm.
  Assert: Check that the start vertex has a distance of 0 and is marked as processed.

Validation:
  This test ensures that the starting conditions for the BFS algorithm are correctly set, which is crucial for the rest of the traversal.

These test scenarios cover various aspects of the BreadthFirstSearch.Run method, including normal operation, edge cases, and error handling. They should provide good coverage for testing the implementation of the BFS algorithm.


*/

// ********RoostGPT********
using NUnit.Framework;
using LunarDoggo.Datastructures.Graphs;
using LunarDoggo.Algorithms.Graphs.Pathfinding;
using System;
using System.Collections.Generic;

namespace LunarDoggo.Algorithms.Graphs.Pathfinding.Test
{
    [TestFixture]
    public class RunTest
    {
        private BreadthFirstSearch bfs;

        [SetUp]
        public void Setup()
        {
            bfs = new BreadthFirstSearch();
        }

        [Test, Category("invalid")]
        public void ThrowArgumentNullExceptionWhenGraphIsNull()
        {
            Vertex<BFSVertex> start = new Vertex<BFSVertex>(0, new BFSVertex());
            Assert.Throws<ArgumentNullException>(() => bfs.Run(null, start));
        }

        [Test, Category("valid")]
        public void CorrectlyTraversesSimpleGraph()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);

            bfs.Run(graph, v1);

            Assert.AreEqual(0, v1.Value.Distance);
            Assert.AreEqual(1, v2.Value.Distance);
            Assert.AreEqual(2, v3.Value.Distance);
            Assert.IsNull(v1.Value.Predecessor);
            Assert.AreEqual(v1, v2.Value.Predecessor);
            Assert.AreEqual(v2, v3.Value.Predecessor);
        }

        [Test, Category("valid")]
        public void HandlesGraphWithIsolatedVertices()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            var v4 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);

            bfs.Run(graph, v1);

            Assert.AreEqual(0, v1.Value.Distance);
            Assert.AreEqual(1, v2.Value.Distance);
            Assert.AreEqual(int.MaxValue, v3.Value.Distance);
            Assert.AreEqual(int.MaxValue, v4.Value.Distance);
            Assert.IsNull(v3.Value.Predecessor);
            Assert.IsNull(v4.Value.Predecessor);
        }

        [Test, Category("boundary")]
        public void CorrectlyHandlesSingleVertexGraph()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());

            bfs.Run(graph, v1);

            Assert.AreEqual(0, v1.Value.Distance);
            Assert.IsNull(v1.Value.Predecessor);
        }

        [Test, Category("valid")]
        public void CorrectlyTraversesCyclicGraph()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            var v4 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);
            graph.AddEdge(v3, v4);
            graph.AddEdge(v4, v1);

            bfs.Run(graph, v1);

            Assert.AreEqual(0, v1.Value.Distance);
            Assert.AreEqual(1, v2.Value.Distance);
            Assert.AreEqual(1, v4.Value.Distance);
            Assert.AreEqual(2, v3.Value.Distance);
        }

        [Test, Category("integration")]
        public void PerformsEfficientlyOnLargeGraph()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertices = new List<Vertex<BFSVertex>>();
            for (int i = 0; i < 10000; i++)
            {
                vertices.Add(graph.AddVertex(new BFSVertex()));
            }
            for (int i = 0; i < 9999; i++)
            {
                graph.AddEdge(vertices[i], vertices[i + 1]);
            }

            var startTime = DateTime.Now;
            bfs.Run(graph, vertices[0]);
            var endTime = DateTime.Now;

            Assert.Less((endTime - startTime).TotalSeconds, 5);
            Assert.AreEqual(9999, vertices[9999].Value.Distance);
        }

        [Test, Category("valid")]
        public void CorrectlyInitializesStartVertex()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var start = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(start, v2);

            bfs.Run(graph, start);

            Assert.AreEqual(0, start.Value.Distance);
            Assert.IsTrue(start.Value.Processed);
            Assert.IsNull(start.Value.Predecessor);
        }
    }
}
