// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleCSharpEnv using AI Type  and AI Model 

ROOST_METHOD_HASH=Run_bbc3b7dcfd
ROOST_METHOD_SIG_HASH=Run_23f9485d25

   ########## Test-Scenarios ##########  

Based on the provided method and context, here are several test scenarios for the BreadthFirstSearch.Run method:

Scenario 1: Null Graph Handling

Details:
  TestName: ThrowsArgumentNullExceptionWhenGraphIsNull
  Description: Verify that the method throws an ArgumentNullException when a null graph is passed.

Execution:
  Arrange: Create a BreadthFirstSearch instance and a null IGraph<BFSVertex>.
  Act: Call the Run method with the null graph and a valid start vertex.
  Assert: Expect an ArgumentNullException to be thrown.

Validation:
  This test ensures that the method properly handles null input for the graph parameter, maintaining robustness and preventing null reference exceptions later in the execution.

Scenario 2: Single Vertex Graph

Details:
  TestName: ProcessesSingleVertexGraphCorrectly
  Description: Ensure the method correctly processes a graph with only one vertex.

Execution:
  Arrange: Create a BreadthFirstSearch instance and an IGraph<BFSVertex> with a single vertex.
  Act: Call the Run method with the graph and the single vertex as the start.
  Assert: Verify that the vertex's Distance is 0 and Processed is true.

Validation:
  This test confirms that the method correctly initializes and processes a trivial graph case, setting the correct distance and processed state for the start vertex.

Scenario 3: Linear Graph Traversal

Details:
  TestName: CorrectlyTraversesLinearGraph
  Description: Verify that the method correctly traverses a linear graph (a chain of vertices).

Execution:
  Arrange: Create a BreadthFirstSearch instance and an IGraph<BFSVertex> with a linear structure (e.g., A -> B -> C -> D).
  Act: Call the Run method with the graph and the first vertex as the start.
  Assert: Check that each vertex has the correct Distance (0, 1, 2, 3) and Predecessor.

Validation:
  This test ensures that the BFS algorithm correctly calculates distances and sets predecessors in a simple linear graph structure.

Scenario 4: Branching Graph Traversal

Details:
  TestName: CorrectlyTraversesBranchingGraph
  Description: Verify that the method correctly traverses a graph with multiple branches.

Execution:
  Arrange: Create a BreadthFirstSearch instance and an IGraph<BFSVertex> with a branching structure (e.g., A -> B -> C, A -> D -> E).
  Act: Call the Run method with the graph and vertex A as the start.
  Assert: Verify that all vertices are processed and have correct Distance and Predecessor values.

Validation:
  This test confirms that the BFS algorithm correctly handles branching paths, processing vertices in the correct order and assigning appropriate distances.

Scenario 5: Cyclic Graph Handling

Details:
  TestName: CorrectlyHandlesCyclicGraph
  Description: Ensure the method correctly processes a graph containing cycles without entering infinite loops.

Execution:
  Arrange: Create a BreadthFirstSearch instance and an IGraph<BFSVertex> with a cyclic structure (e.g., A -> B -> C -> A).
  Act: Call the Run method with the graph and any vertex as the start.
  Assert: Verify that all vertices are processed exactly once and have correct Distance and Predecessor values.

Validation:
  This test checks that the BFS algorithm can handle cycles in the graph without getting stuck or processing vertices multiple times.

Scenario 6: Disconnected Graph Components

Details:
  TestName: ProcessesOnlyReachableVerticesInDisconnectedGraph
  Description: Verify that the method only processes vertices reachable from the start vertex in a disconnected graph.

Execution:
  Arrange: Create a BreadthFirstSearch instance and an IGraph<BFSVertex> with disconnected components (e.g., (A -> B, C -> D) where there's no path between AB and CD).
  Act: Call the Run method with the graph and vertex A as the start.
  Assert: Check that vertices A and B are processed and have correct Distance and Predecessor values, while C and D remain unprocessed.

Validation:
  This test ensures that the BFS algorithm correctly handles disconnected graphs, only processing the component reachable from the start vertex.

Scenario 7: Large Graph Performance

Details:
  TestName: CompletesLargeGraphTraversalInReasonableTime
  Description: Verify that the method can process a large graph within an acceptable time frame.

Execution:
  Arrange: Create a BreadthFirstSearch instance and a large IGraph<BFSVertex> (e.g., 10000 vertices).
  Act: Measure the time taken to call and complete the Run method.
  Assert: Verify that the execution time is within an acceptable range and all vertices are correctly processed.

Validation:
  This test checks the performance and scalability of the BFS implementation, ensuring it can handle large graphs efficiently.

These test scenarios cover various aspects of the BreadthFirstSearch.Run method, including error handling, correct traversal in different graph structures, and performance considerations.


*/

// ********RoostGPT********
using NUnit.Framework;
using LunarDoggo.Datastructures.Graphs;
using LunarDoggo.Algorithms.Graphs.Pathfinding;
using System;
using System.Collections.Generic;

namespace LunarDoggo.Algorithms.Graphs.Pathfinding.Test
{
    [TestFixture]
    public class RunTest
    {
        private BreadthFirstSearch bfs;

        [SetUp]
        public void Setup()
        {
            bfs = new BreadthFirstSearch();
        }

        [Test, Category("invalid")]
        public void ThrowsArgumentNullExceptionWhenGraphIsNull()
        {
            IGraph<BFSVertex> nullGraph = null;
            Vertex<BFSVertex> startVertex = new Vertex<BFSVertex>(0, new BFSVertex());

            Assert.Throws<ArgumentNullException>(() => bfs.Run(nullGraph, startVertex));
        }

        [Test, Category("valid")]
        public void ProcessesSingleVertexGraphCorrectly()
        {
            UndirectedUnweightedGraph<BFSVertex> graph = new UndirectedUnweightedGraph<BFSVertex>();
            Vertex<BFSVertex> singleVertex = graph.AddVertex(new BFSVertex());

            bfs.Run(graph, singleVertex);

            Assert.That(singleVertex.Value.Distance, Is.EqualTo(0));
            Assert.That(singleVertex.Value.Processed, Is.True);
        }

        [Test, Category("valid")]
        public void CorrectlyTraversesLinearGraph()
        {
            UndirectedUnweightedGraph<BFSVertex> graph = new UndirectedUnweightedGraph<BFSVertex>();
            Vertex<BFSVertex> vertexA = graph.AddVertex(new BFSVertex());
            Vertex<BFSVertex> vertexB = graph.AddVertex(new BFSVertex());
            Vertex<BFSVertex> vertexC = graph.AddVertex(new BFSVertex());
            Vertex<BFSVertex> vertexD = graph.AddVertex(new BFSVertex());

            graph.AddEdge(vertexA, vertexB);
            graph.AddEdge(vertexB, vertexC);
            graph.AddEdge(vertexC, vertexD);

            bfs.Run(graph, vertexA);

            Assert.That(vertexA.Value.Distance, Is.EqualTo(0));
            Assert.That(vertexB.Value.Distance, Is.EqualTo(1));
            Assert.That(vertexC.Value.Distance, Is.EqualTo(2));
            Assert.That(vertexD.Value.Distance, Is.EqualTo(3));

            Assert.That(vertexB.Value.Predecessor, Is.EqualTo(vertexA));
            Assert.That(vertexC.Value.Predecessor, Is.EqualTo(vertexB));
            Assert.That(vertexD.Value.Predecessor, Is.EqualTo(vertexC));
        }

        [Test, Category("valid")]
        public void CorrectlyTraversesBranchingGraph()
        {
            UndirectedUnweightedGraph<BFSVertex> graph = new UndirectedUnweightedGraph<BFSVertex>();
            Vertex<BFSVertex> vertexA = graph.AddVertex(new BFSVertex());
            Vertex<BFSVertex> vertexB = graph.AddVertex(new BFSVertex());
            Vertex<BFSVertex> vertexC = graph.AddVertex(new BFSVertex());
            Vertex<BFSVertex> vertexD = graph.AddVertex(new BFSVertex());
            Vertex<BFSVertex> vertexE = graph.AddVertex(new BFSVertex());

            graph.AddEdge(vertexA, vertexB);
            graph.AddEdge(vertexB, vertexC);
            graph.AddEdge(vertexA, vertexD);
            graph.AddEdge(vertexD, vertexE);

            bfs.Run(graph, vertexA);

            Assert.That(vertexA.Value.Distance, Is.EqualTo(0));
            Assert.That(vertexB.Value.Distance, Is.EqualTo(1));
            Assert.That(vertexC.Value.Distance, Is.EqualTo(2));
            Assert.That(vertexD.Value.Distance, Is.EqualTo(1));
            Assert.That(vertexE.Value.Distance, Is.EqualTo(2));

            Assert.That(vertexB.Value.Predecessor, Is.EqualTo(vertexA));
            Assert.That(vertexC.Value.Predecessor, Is.EqualTo(vertexB));
            Assert.That(vertexD.Value.Predecessor, Is.EqualTo(vertexA));
            Assert.That(vertexE.Value.Predecessor, Is.EqualTo(vertexD));
        }

        [Test, Category("valid")]
        public void CorrectlyHandlesCyclicGraph()
        {
            UndirectedUnweightedGraph<BFSVertex> graph = new UndirectedUnweightedGraph<BFSVertex>();
            Vertex<BFSVertex> vertexA = graph.AddVertex(new BFSVertex());
            Vertex<BFSVertex> vertexB = graph.AddVertex(new BFSVertex());
            Vertex<BFSVertex> vertexC = graph.AddVertex(new BFSVertex());

            graph.AddEdge(vertexA, vertexB);
            graph.AddEdge(vertexB, vertexC);
            graph.AddEdge(vertexC, vertexA);

            bfs.Run(graph, vertexA);

            Assert.That(vertexA.Value.Distance, Is.EqualTo(0));
            Assert.That(vertexB.Value.Distance, Is.EqualTo(1));
            Assert.That(vertexC.Value.Distance, Is.EqualTo(1));

            Assert.That(vertexB.Value.Predecessor, Is.EqualTo(vertexA));
            Assert.That(vertexC.Value.Predecessor, Is.EqualTo(vertexA));
        }

        [Test, Category("valid")]
        public void ProcessesOnlyReachableVerticesInDisconnectedGraph()
        {
            UndirectedUnweightedGraph<BFSVertex> graph = new UndirectedUnweightedGraph<BFSVertex>();
            Vertex<BFSVertex> vertexA = graph.AddVertex(new BFSVertex());
            Vertex<BFSVertex> vertexB = graph.AddVertex(new BFSVertex());
            Vertex<BFSVertex> vertexC = graph.AddVertex(new BFSVertex());
            Vertex<BFSVertex> vertexD = graph.AddVertex(new BFSVertex());

            graph.AddEdge(vertexA, vertexB);
            graph.AddEdge(vertexC, vertexD);

            bfs.Run(graph, vertexA);

            Assert.That(vertexA.Value.Distance, Is.EqualTo(0));
            Assert.That(vertexB.Value.Distance, Is.EqualTo(1));
            Assert.That(vertexC.Value.Distance, Is.EqualTo(int.MaxValue));
            Assert.That(vertexD.Value.Distance, Is.EqualTo(int.MaxValue));

            Assert.That(vertexA.Value.Processed, Is.True);
            Assert.That(vertexB.Value.Processed, Is.True);
            Assert.That(vertexC.Value.Processed, Is.False);
            Assert.That(vertexD.Value.Processed, Is.False);
        }

        [Test, Category("valid")]
        public void CompletesLargeGraphTraversalInReasonableTime()
        {
            UndirectedUnweightedGraph<BFSVertex> graph = new UndirectedUnweightedGraph<BFSVertex>();
            List<Vertex<BFSVertex>> vertices = new List<Vertex<BFSVertex>>();

            for (int i = 0; i < 10000; i++)
            {
                vertices.Add(graph.AddVertex(new BFSVertex()));
            }

            for (int i = 0; i < 9999; i++)
            {
                graph.AddEdge(vertices[i], vertices[i + 1]);
            }

            DateTime start = DateTime.Now;
            bfs.Run(graph, vertices[0]);
            TimeSpan duration = DateTime.Now - start;

            Assert.That(duration.TotalSeconds, Is.LessThan(5)); // Adjust the time limit as needed
            Assert.That(vertices[9999].Value.Distance, Is.EqualTo(9999));
            Assert.That(vertices[9999].Value.Processed, Is.True);
        }
    }
}
