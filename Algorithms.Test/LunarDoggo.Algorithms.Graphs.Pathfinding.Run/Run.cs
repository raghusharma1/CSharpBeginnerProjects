// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleCSharpEnv using AI Type  and AI Model 

ROOST_METHOD_HASH=Run_bbc3b7dcfd
ROOST_METHOD_SIG_HASH=Run_23f9485d25

   ########## Test-Scenarios ##########  

Based on the provided method and related code, here are several test scenarios for the `Run` method of the `BreadthFirstSearch` class:

Scenario 1: Null Graph Handling

Details:
  TestName: ThrowsArgumentNullExceptionWhenGraphIsNull
  Description: Verify that the method throws an ArgumentNullException when a null graph is passed.
Execution:
  Arrange: Create a BreadthFirstSearch instance and prepare a null graph and a valid start vertex.
  Act: Call the Run method with the null graph and valid start vertex.
  Assert: Expect an ArgumentNullException to be thrown.
Validation:
  This test ensures that the method properly handles null input for the graph parameter, maintaining robustness and preventing null reference exceptions later in the execution.

Scenario 2: Single Vertex Graph

Details:
  TestName: ProcessesSingleVertexGraphCorrectly
  Description: Ensure the method correctly processes a graph with only one vertex (the start vertex).
Execution:
  Arrange: Create a graph with a single vertex, set it as the start vertex, and initialize a BreadthFirstSearch instance.
  Act: Call the Run method with the graph and start vertex.
  Assert: Verify that the start vertex's distance is 0 and it has no predecessor.
Validation:
  This test confirms that the method correctly initializes and processes the simplest possible graph, setting the base case for more complex scenarios.

Scenario 3: Linear Graph Traversal

Details:
  TestName: TraversesLinearGraphCorrectly
  Description: Verify correct traversal and distance calculation in a linear graph (A -> B -> C -> D).
Execution:
  Arrange: Create a linear graph with 4 vertices, set the first vertex as the start, and initialize a BreadthFirstSearch instance.
  Act: Call the Run method with the graph and start vertex.
  Assert: Check that each vertex has the correct distance (0, 1, 2, 3) and predecessor.
Validation:
  This test ensures that the BFS algorithm correctly traverses a simple linear path, updating distances and predecessors appropriately.

Scenario 4: Branching Graph Traversal

Details:
  TestName: TraversesBranchingGraphCorrectly
  Description: Verify correct traversal and distance calculation in a branching graph (A -> B -> C, A -> D -> E).
Execution:
  Arrange: Create a branching graph, set the root as the start vertex, and initialize a BreadthFirstSearch instance.
  Act: Call the Run method with the graph and start vertex.
  Assert: Verify that all vertices have correct distances (A:0, B:1, D:1, C:2, E:2) and predecessors.
Validation:
  This test confirms that the BFS algorithm correctly handles branching paths, maintaining correct distances and predecessors for all vertices.

Scenario 5: Cyclic Graph Handling

Details:
  TestName: HandlesCyclicGraphWithoutInfiniteLoop
  Description: Ensure the method correctly processes a graph with cycles without getting stuck in an infinite loop.
Execution:
  Arrange: Create a cyclic graph (e.g., A -> B -> C -> A), set a start vertex, and initialize a BreadthFirstSearch instance.
  Act: Call the Run method with the graph and start vertex.
  Assert: Verify that all vertices are processed, have correct distances, and the method terminates.
Validation:
  This test checks that the BFS algorithm can handle cycles in the graph without revisiting already processed vertices or entering an infinite loop.

Scenario 6: Disconnected Graph Components

Details:
  TestName: ProcessesOnlyReachableVerticesInDisconnectedGraph
  Description: Verify that only vertices reachable from the start vertex are processed in a disconnected graph.
Execution:
  Arrange: Create a graph with two disconnected components, set a start vertex in one component, and initialize a BreadthFirstSearch instance.
  Act: Call the Run method with the graph and start vertex.
  Assert: Check that vertices in the same component as the start are processed (have distances set) while others remain unprocessed.
Validation:
  This test ensures that the BFS algorithm correctly handles disconnected graphs, processing only the reachable vertices from the given start vertex.

Scenario 7: Large Graph Performance

Details:
  TestName: CompletesLargeGraphTraversalInReasonableTime
  Description: Verify that the method can process a large graph within an acceptable time frame.
Execution:
  Arrange: Generate a large graph (e.g., 10000 vertices), set a start vertex, and initialize a BreadthFirstSearch instance.
  Act: Measure the time taken to call and complete the Run method.
  Assert: Verify that the execution time is within an acceptable limit and all vertices are processed.
Validation:
  This test checks the performance and scalability of the BFS implementation, ensuring it can handle large graphs efficiently.

These test scenarios cover various aspects of the BreadthFirstSearch.Run method, including error handling, correct traversal in different graph structures, cycle handling, and performance with large datasets. They aim to ensure the robustness and correctness of the BFS implementation across different scenarios.


*/

// ********RoostGPT********
using NUnit.Framework;
using LunarDoggo.Datastructures.Graphs;
using LunarDoggo.Algorithms.Graphs.Pathfinding;
using System;
using System.Linq;

namespace LunarDoggo.Algorithms.Graphs.Pathfinding.Test
{
    [TestFixture]
    public class RunTest
    {
        private BreadthFirstSearch bfs;

        [SetUp]
        public void Setup()
        {
            bfs = new BreadthFirstSearch();
        }

        [Test, Category("invalid")]
        public void ThrowsArgumentNullExceptionWhenGraphIsNull()
        {
            // Arrange
            IGraph<BFSVertex> nullGraph = null;
            Vertex<BFSVertex> startVertex = new Vertex<BFSVertex>(0, new BFSVertex());

            // Act & Assert
            Assert.Throws<ArgumentNullException>(() => bfs.Run(nullGraph, startVertex));
        }

        [Test, Category("valid")]
        public void ProcessesSingleVertexGraphCorrectly()
        {
            // Arrange
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var startVertex = graph.AddVertex(new BFSVertex());

            // Act
            bfs.Run(graph, startVertex);

            // Assert
            Assert.That(startVertex.Value.Distance, Is.EqualTo(0));
            Assert.That(startVertex.Value.Predecessor, Is.Null);
            Assert.That(startVertex.Value.Processed, Is.True);
        }

        [Test, Category("valid")]
        public void TraversesLinearGraphCorrectly()
        {
            // Arrange
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertexA = graph.AddVertex(new BFSVertex());
            var vertexB = graph.AddVertex(new BFSVertex());
            var vertexC = graph.AddVertex(new BFSVertex());
            var vertexD = graph.AddVertex(new BFSVertex());

            graph.AddEdge(vertexA, vertexB);
            graph.AddEdge(vertexB, vertexC);
            graph.AddEdge(vertexC, vertexD);

            // Act
            bfs.Run(graph, vertexA);

            // Assert
            Assert.That(vertexA.Value.Distance, Is.EqualTo(0));
            Assert.That(vertexB.Value.Distance, Is.EqualTo(1));
            Assert.That(vertexC.Value.Distance, Is.EqualTo(2));
            Assert.That(vertexD.Value.Distance, Is.EqualTo(3));

            Assert.That(vertexA.Value.Predecessor, Is.Null);
            Assert.That(vertexB.Value.Predecessor, Is.EqualTo(vertexA));
            Assert.That(vertexC.Value.Predecessor, Is.EqualTo(vertexB));
            Assert.That(vertexD.Value.Predecessor, Is.EqualTo(vertexC));
        }

        [Test, Category("valid")]
        public void TraversesBranchingGraphCorrectly()
        {
            // Arrange
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertexA = graph.AddVertex(new BFSVertex());
            var vertexB = graph.AddVertex(new BFSVertex());
            var vertexC = graph.AddVertex(new BFSVertex());
            var vertexD = graph.AddVertex(new BFSVertex());
            var vertexE = graph.AddVertex(new BFSVertex());

            graph.AddEdge(vertexA, vertexB);
            graph.AddEdge(vertexA, vertexD);
            graph.AddEdge(vertexB, vertexC);
            graph.AddEdge(vertexD, vertexE);

            // Act
            bfs.Run(graph, vertexA);

            // Assert
            Assert.That(vertexA.Value.Distance, Is.EqualTo(0));
            Assert.That(vertexB.Value.Distance, Is.EqualTo(1));
            Assert.That(vertexC.Value.Distance, Is.EqualTo(2));
            Assert.That(vertexD.Value.Distance, Is.EqualTo(1));
            Assert.That(vertexE.Value.Distance, Is.EqualTo(2));

            Assert.That(vertexA.Value.Predecessor, Is.Null);
            Assert.That(vertexB.Value.Predecessor, Is.EqualTo(vertexA));
            Assert.That(vertexC.Value.Predecessor, Is.EqualTo(vertexB));
            Assert.That(vertexD.Value.Predecessor, Is.EqualTo(vertexA));
            Assert.That(vertexE.Value.Predecessor, Is.EqualTo(vertexD));
        }

        [Test, Category("valid")]
        public void HandlesCyclicGraphWithoutInfiniteLoop()
        {
            // Arrange
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertexA = graph.AddVertex(new BFSVertex());
            var vertexB = graph.AddVertex(new BFSVertex());
            var vertexC = graph.AddVertex(new BFSVertex());

            graph.AddEdge(vertexA, vertexB);
            graph.AddEdge(vertexB, vertexC);
            graph.AddEdge(vertexC, vertexA);

            // Act
            bfs.Run(graph, vertexA);

            // Assert
            Assert.That(vertexA.Value.Distance, Is.EqualTo(0));
            Assert.That(vertexB.Value.Distance, Is.EqualTo(1));
            Assert.That(vertexC.Value.Distance, Is.EqualTo(1));

            Assert.That(vertexA.Value.Predecessor, Is.Null);
            Assert.That(vertexB.Value.Predecessor, Is.EqualTo(vertexA));
            Assert.That(vertexC.Value.Predecessor, Is.EqualTo(vertexA));

            Assert.That(vertexA.Value.Processed, Is.True);
            Assert.That(vertexB.Value.Processed, Is.True);
            Assert.That(vertexC.Value.Processed, Is.True);
        }

        [Test, Category("valid")]
        public void ProcessesOnlyReachableVerticesInDisconnectedGraph()
        {
            // Arrange
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertexA = graph.AddVertex(new BFSVertex());
            var vertexB = graph.AddVertex(new BFSVertex());
            var vertexC = graph.AddVertex(new BFSVertex());
            var vertexD = graph.AddVertex(new BFSVertex());
            var vertexE = graph.AddVertex(new BFSVertex());

            graph.AddEdge(vertexA, vertexB);
            graph.AddEdge(vertexB, vertexC);
            graph.AddEdge(vertexD, vertexE);

            // Act
            bfs.Run(graph, vertexA);

            // Assert
            Assert.That(vertexA.Value.Processed, Is.True);
            Assert.That(vertexB.Value.Processed, Is.True);
            Assert.That(vertexC.Value.Processed, Is.True);
            Assert.That(vertexD.Value.Processed, Is.False);
            Assert.That(vertexE.Value.Processed, Is.False);

            Assert.That(vertexA.Value.Distance, Is.EqualTo(0));
            Assert.That(vertexB.Value.Distance, Is.EqualTo(1));
            Assert.That(vertexC.Value.Distance, Is.EqualTo(2));
            Assert.That(vertexD.Value.Distance, Is.EqualTo(int.MaxValue));
            Assert.That(vertexE.Value.Distance, Is.EqualTo(int.MaxValue));
        }

        [Test, Category("valid")]
        public void CompletesLargeGraphTraversalInReasonableTime()
        {
            // Arrange
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertices = new Vertex<BFSVertex>[10000];
            for (int i = 0; i < 10000; i++)
            {
                vertices[i] = graph.AddVertex(new BFSVertex());
                if (i > 0)
                {
                    graph.AddEdge(vertices[i - 1], vertices[i]);
                }
            }

            // Act
            var startTime = DateTime.Now;
            bfs.Run(graph, vertices[0]);
            var endTime = DateTime.Now;

            // Assert
            var executionTime = (endTime - startTime).TotalSeconds;
            Assert.That(executionTime, Is.LessThan(5), "BFS took too long to complete");

            Assert.That(vertices.All(v => v.Value.Processed), Is.True, "Not all vertices were processed");
            Assert.That(vertices[9999].Value.Distance, Is.EqualTo(9999), "Incorrect distance for the last vertex");
        }
    }
}
