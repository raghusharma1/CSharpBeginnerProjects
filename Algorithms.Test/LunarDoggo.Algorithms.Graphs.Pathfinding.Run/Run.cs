// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleCSharpEnv using AI Type  and AI Model 

ROOST_METHOD_HASH=Run_bbc3b7dcfd
ROOST_METHOD_SIG_HASH=Run_23f9485d25

   ########## Test-Scenarios ##########  

Based on the provided method and related code, here are several test scenarios for the `Run` method of the `BreadthFirstSearch` class:

Scenario 1: Null Graph Input

Details:
  TestName: ThrowArgumentNullExceptionWhenGraphIsNull
  Description: Verify that the method throws an ArgumentNullException when a null graph is provided.
Execution:
  Arrange: Create a BreadthFirstSearch instance and set up a null graph and a valid start vertex.
  Act: Call the Run method with the null graph and valid start vertex.
  Assert: Verify that an ArgumentNullException is thrown with the correct message.
Validation:
  This test ensures that the method properly handles null input for the graph parameter, maintaining robustness and preventing null reference exceptions later in the execution.

Scenario 2: Valid Graph with Single Vertex

Details:
  TestName: ProcessSingleVertexGraphCorrectly
  Description: Ensure the method correctly processes a graph with only one vertex (the start vertex).
Execution:
  Arrange: Create a BreadthFirstSearch instance, a graph with a single vertex, and set this vertex as the start vertex.
  Act: Call the Run method with the graph and start vertex.
  Assert: Verify that the start vertex has been processed (Processed = true, Distance = 0, Predecessor = null).
Validation:
  This test confirms that the method correctly initializes and processes the simplest possible graph scenario, setting the base case for more complex graphs.

Scenario 3: Graph with Multiple Vertices in a Line

Details:
  TestName: ProcessLinearGraphCorrectly
  Description: Verify that the method correctly processes a graph where vertices are connected in a linear fashion.
Execution:
  Arrange: Create a BreadthFirstSearch instance and a graph with vertices connected linearly (A -> B -> C -> D).
  Act: Call the Run method with the graph and vertex A as the start.
  Assert: Check that all vertices are processed, distances are set correctly (A:0, B:1, C:2, D:3), and predecessors are set appropriately.
Validation:
  This test ensures that the BFS algorithm correctly traverses a simple linear graph, properly setting distances and predecessors.

Scenario 4: Graph with Branching Paths

Details:
  TestName: ProcessBranchingGraphCorrectly
  Description: Ensure the method correctly handles a graph with multiple branching paths from the start vertex.
Execution:
  Arrange: Create a BreadthFirstSearch instance and a graph with branching paths (A -> B, A -> C, B -> D, C -> E).
  Act: Call the Run method with the graph and vertex A as the start.
  Assert: Verify that all vertices are processed in the correct order, distances are set correctly (A:0, B:1, C:1, D:2, E:2), and predecessors are set appropriately.
Validation:
  This test confirms that the BFS algorithm correctly handles branching paths, maintaining the breadth-first order of traversal.

Scenario 5: Cyclic Graph

Details:
  TestName: ProcessCyclicGraphWithoutInfiniteLoop
  Description: Verify that the method can process a graph containing cycles without entering an infinite loop.
Execution:
  Arrange: Create a BreadthFirstSearch instance and a graph with a cycle (A -> B -> C -> A).
  Act: Call the Run method with the graph and vertex A as the start.
  Assert: Check that all vertices are processed exactly once, distances are set correctly (A:0, B:1, C:1), and the algorithm terminates.
Validation:
  This test ensures that the BFS algorithm can handle cyclic graphs without getting stuck in an infinite loop, which is crucial for graph traversal robustness.

Scenario 6: Disconnected Graph

Details:
  TestName: ProcessOnlyReachableVerticesInDisconnectedGraph
  Description: Ensure the method only processes vertices reachable from the start vertex in a disconnected graph.
Execution:
  Arrange: Create a BreadthFirstSearch instance and a graph with two disconnected components (A -> B, C -> D).
  Act: Call the Run method with the graph and vertex A as the start.
  Assert: Verify that only A and B are processed, while C and D remain unprocessed (Processed = false, Distance = Int32.MaxValue).
Validation:
  This test confirms that the BFS algorithm correctly handles disconnected graphs, only processing the component reachable from the start vertex.

Scenario 7: Empty Graph

Details:
  TestName: HandleEmptyGraphGracefully
  Description: Verify that the method handles an empty graph (no vertices) without errors.
Execution:
  Arrange: Create a BreadthFirstSearch instance and an empty graph.
  Act: Call the Run method with the empty graph and a null start vertex.
  Assert: Verify that the method completes without throwing exceptions and doesn't modify the empty graph.
Validation:
  This test ensures that the BFS algorithm can handle edge cases such as empty graphs without crashing or producing unexpected results.

These test scenarios cover various aspects of the BreadthFirstSearch.Run method, including error handling, different graph structures, and edge cases. They aim to ensure the correctness and robustness of the BFS implementation across different scenarios.


*/

// ********RoostGPT********
using NUnit.Framework;
using LunarDoggo.Datastructures.Graphs;
using LunarDoggo.Algorithms.Graphs.Pathfinding;
using System;
using System.Linq;

namespace LunarDoggo.Algorithms.Graphs.Pathfinding.Test
{
    [TestFixture]
    public class RunTest
    {
        private BreadthFirstSearch bfs;

        [SetUp]
        public void Setup()
        {
            bfs = new BreadthFirstSearch();
        }

        [Test, Category("invalid")]
        public void ThrowArgumentNullExceptionWhenGraphIsNull()
        {
            var start = new Vertex<BFSVertex>(0, new BFSVertex());
            Assert.Throws<ArgumentNullException>(() => bfs.Run(null, start));
        }

        [Test, Category("valid")]
        public void ProcessSingleVertexGraphCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertex = graph.AddVertex(new BFSVertex());

            bfs.Run(graph, vertex);

            Assert.IsTrue(vertex.Value.Processed);
            Assert.AreEqual(0, vertex.Value.Distance);
            Assert.IsNull(vertex.Value.Predecessor);
        }

        [Test, Category("valid")]
        public void ProcessLinearGraphCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var a = graph.AddVertex(new BFSVertex());
            var b = graph.AddVertex(new BFSVertex());
            var c = graph.AddVertex(new BFSVertex());
            var d = graph.AddVertex(new BFSVertex());

            graph.AddEdge(a, b);
            graph.AddEdge(b, c);
            graph.AddEdge(c, d);

            bfs.Run(graph, a);

            Assert.IsTrue(a.Value.Processed);
            Assert.IsTrue(b.Value.Processed);
            Assert.IsTrue(c.Value.Processed);
            Assert.IsTrue(d.Value.Processed);

            Assert.AreEqual(0, a.Value.Distance);
            Assert.AreEqual(1, b.Value.Distance);
            Assert.AreEqual(2, c.Value.Distance);
            Assert.AreEqual(3, d.Value.Distance);

            Assert.IsNull(a.Value.Predecessor);
            Assert.AreEqual(a, b.Value.Predecessor);
            Assert.AreEqual(b, c.Value.Predecessor);
            Assert.AreEqual(c, d.Value.Predecessor);
        }

        [Test, Category("valid")]
        public void ProcessBranchingGraphCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var a = graph.AddVertex(new BFSVertex());
            var b = graph.AddVertex(new BFSVertex());
            var c = graph.AddVertex(new BFSVertex());
            var d = graph.AddVertex(new BFSVertex());
            var e = graph.AddVertex(new BFSVertex());

            graph.AddEdge(a, b);
            graph.AddEdge(a, c);
            graph.AddEdge(b, d);
            graph.AddEdge(c, e);

            bfs.Run(graph, a);

            Assert.IsTrue(a.Value.Processed);
            Assert.IsTrue(b.Value.Processed);
            Assert.IsTrue(c.Value.Processed);
            Assert.IsTrue(d.Value.Processed);
            Assert.IsTrue(e.Value.Processed);

            Assert.AreEqual(0, a.Value.Distance);
            Assert.AreEqual(1, b.Value.Distance);
            Assert.AreEqual(1, c.Value.Distance);
            Assert.AreEqual(2, d.Value.Distance);
            Assert.AreEqual(2, e.Value.Distance);

            Assert.IsNull(a.Value.Predecessor);
            Assert.AreEqual(a, b.Value.Predecessor);
            Assert.AreEqual(a, c.Value.Predecessor);
            Assert.AreEqual(b, d.Value.Predecessor);
            Assert.AreEqual(c, e.Value.Predecessor);
        }

        [Test, Category("valid")]
        public void ProcessCyclicGraphWithoutInfiniteLoop()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var a = graph.AddVertex(new BFSVertex());
            var b = graph.AddVertex(new BFSVertex());
            var c = graph.AddVertex(new BFSVertex());

            graph.AddEdge(a, b);
            graph.AddEdge(b, c);
            graph.AddEdge(c, a);

            bfs.Run(graph, a);

            Assert.IsTrue(a.Value.Processed);
            Assert.IsTrue(b.Value.Processed);
            Assert.IsTrue(c.Value.Processed);

            Assert.AreEqual(0, a.Value.Distance);
            Assert.AreEqual(1, b.Value.Distance);
            Assert.AreEqual(1, c.Value.Distance);

            Assert.IsNull(a.Value.Predecessor);
            Assert.AreEqual(a, b.Value.Predecessor);
            Assert.AreEqual(a, c.Value.Predecessor);
        }

        [Test, Category("valid")]
        public void ProcessOnlyReachableVerticesInDisconnectedGraph()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var a = graph.AddVertex(new BFSVertex());
            var b = graph.AddVertex(new BFSVertex());
            var c = graph.AddVertex(new BFSVertex());
            var d = graph.AddVertex(new BFSVertex());

            graph.AddEdge(a, b);
            graph.AddEdge(c, d);

            bfs.Run(graph, a);

            Assert.IsTrue(a.Value.Processed);
            Assert.IsTrue(b.Value.Processed);
            Assert.IsFalse(c.Value.Processed);
            Assert.IsFalse(d.Value.Processed);

            Assert.AreEqual(0, a.Value.Distance);
            Assert.AreEqual(1, b.Value.Distance);
            Assert.AreEqual(int.MaxValue, c.Value.Distance);
            Assert.AreEqual(int.MaxValue, d.Value.Distance);

            Assert.IsNull(a.Value.Predecessor);
            Assert.AreEqual(a, b.Value.Predecessor);
            Assert.IsNull(c.Value.Predecessor);
            Assert.IsNull(d.Value.Predecessor);
        }

        [Test, Category("boundary")]
        public void HandleEmptyGraphGracefully()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();

            Assert.DoesNotThrow(() => bfs.Run(graph, null));
        }
    }
}
