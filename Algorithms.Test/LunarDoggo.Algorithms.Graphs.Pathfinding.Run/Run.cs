// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleCSharpEnv using AI Type  and AI Model 

ROOST_METHOD_HASH=Run_bbc3b7dcfd
ROOST_METHOD_SIG_HASH=Run_23f9485d25

   ########## Test-Scenarios ##########  

Based on the provided method and context, here are several test scenarios for the BreadthFirstSearch.Run method:

Scenario 1: Valid Graph and Start Vertex

Details:
  TestName: RunBFSWithValidGraphAndStartVertex
  Description: Test the BFS algorithm with a valid graph and start vertex to ensure correct traversal and distance calculation.

Execution:
  Arrange: Create a valid graph with multiple vertices and edges, and select a start vertex.
  Act: Call the Run method with the created graph and start vertex.
  Assert: Check that all vertices are processed, distances are correctly calculated, and predecessors are properly set.

Validation:
  This test verifies that the BFS algorithm correctly traverses the graph, updating distances and predecessors for each vertex. It ensures the core functionality of the algorithm works as expected for a typical use case.

Scenario 2: Null Graph Input

Details:
  TestName: RunBFSWithNullGraphThrowsArgumentNullException
  Description: Verify that the method throws an ArgumentNullException when a null graph is provided.

Execution:
  Arrange: Prepare a null IGraph<BFSVertex> object and a valid start vertex.
  Act: Call the Run method with the null graph and valid start vertex.
  Assert: Expect an ArgumentNullException to be thrown.

Validation:
  This test ensures that the method properly handles invalid input by throwing an exception when a null graph is provided, maintaining the integrity of the algorithm and preventing null reference exceptions.

Scenario 3: Disconnected Graph

Details:
  TestName: RunBFSOnDisconnectedGraph
  Description: Test the BFS algorithm on a graph with disconnected components to ensure correct behavior.

Execution:
  Arrange: Create a graph with multiple disconnected components and select a start vertex from one component.
  Act: Call the Run method with the created graph and start vertex.
  Assert: Verify that vertices in the same component as the start vertex are processed and have correct distances, while vertices in other components remain unprocessed with maximum distance.

Validation:
  This test checks if the BFS algorithm correctly handles disconnected graphs, processing only the reachable vertices and leaving unreachable vertices untouched.

Scenario 4: Single Vertex Graph

Details:
  TestName: RunBFSOnSingleVertexGraph
  Description: Test the BFS algorithm on a graph containing only one vertex.

Execution:
  Arrange: Create a graph with a single vertex and use it as the start vertex.
  Act: Call the Run method with the single-vertex graph and its only vertex as the start.
  Assert: Check that the vertex is processed, has a distance of 0, and no predecessor.

Validation:
  This test verifies that the BFS algorithm works correctly for the edge case of a graph with only one vertex, ensuring proper initialization and termination of the algorithm.

Scenario 5: Cyclic Graph

Details:
  TestName: RunBFSOnCyclicGraph
  Description: Test the BFS algorithm on a graph containing cycles to ensure correct traversal and distance calculation.

Execution:
  Arrange: Create a graph with cycles and select a start vertex.
  Act: Call the Run method with the cyclic graph and start vertex.
  Assert: Verify that all vertices are processed, distances are correctly calculated (shortest path), and the algorithm doesn't enter an infinite loop.

Validation:
  This test ensures that the BFS algorithm correctly handles cyclic graphs, avoiding infinite loops and calculating the shortest distances even in the presence of multiple paths between vertices.

Scenario 6: Large Graph Performance

Details:
  TestName: RunBFSOnLargeGraphPerformance
  Description: Test the performance of the BFS algorithm on a large graph to ensure it completes within a reasonable time.

Execution:
  Arrange: Create a large graph with many vertices and edges, and select a start vertex.
  Act: Measure the time taken to call and complete the Run method with the large graph and start vertex.
  Assert: Verify that the method completes within an acceptable time limit and that all vertices are processed correctly.

Validation:
  This test checks the efficiency and scalability of the BFS implementation, ensuring it can handle large graphs without excessive time complexity.

These test scenarios cover various aspects of the BreadthFirstSearch.Run method, including normal operation, edge cases, error handling, and performance considerations.


*/

// ********RoostGPT********
using NUnit.Framework;
using LunarDoggo.Datastructures.Graphs;
using LunarDoggo.Algorithms.Graphs.Pathfinding;
using System;
using System.Collections.Generic;
using System.Linq;

namespace LunarDoggo.Algorithms.Graphs.Pathfinding.Test
{
    [TestFixture]
    public class RunTest
    {
        private BreadthFirstSearch bfs;
        private UndirectedUnweightedGraph<BFSVertex> graph;

        [SetUp]
        public void Setup()
        {
            bfs = new BreadthFirstSearch();
            graph = new UndirectedUnweightedGraph<BFSVertex>();
        }

        [Test]
        [Category("valid")]
        public void RunBFSWithValidGraphAndStartVertex()
        {
            // Arrange
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);

            // Act
            bfs.Run(graph, v1);

            // Assert
            Assert.That(v1.Value.Distance, Is.EqualTo(0));
            Assert.That(v2.Value.Distance, Is.EqualTo(1));
            Assert.That(v3.Value.Distance, Is.EqualTo(2));
            Assert.That(v1.Value.Predecessor, Is.Null);
            Assert.That(v2.Value.Predecessor, Is.EqualTo(v1));
            Assert.That(v3.Value.Predecessor, Is.EqualTo(v2));
        }

        [Test]
        [Category("invalid")]
        public void RunBFSWithNullGraphThrowsArgumentNullException()
        {
            // Arrange
            var startVertex = new Vertex<BFSVertex>(0, new BFSVertex());

            // Act & Assert
            Assert.Throws<ArgumentNullException>(() => bfs.Run(null, startVertex));
        }

        [Test]
        [Category("valid")]
        public void RunBFSOnDisconnectedGraph()
        {
            // Arrange
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            var v4 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v3, v4);

            // Act
            bfs.Run(graph, v1);

            // Assert
            Assert.That(v1.Value.Distance, Is.EqualTo(0));
            Assert.That(v2.Value.Distance, Is.EqualTo(1));
            Assert.That(v3.Value.Distance, Is.EqualTo(int.MaxValue));
            Assert.That(v4.Value.Distance, Is.EqualTo(int.MaxValue));
        }

        [Test]
        [Category("boundary")]
        public void RunBFSOnSingleVertexGraph()
        {
            // Arrange
            var v1 = graph.AddVertex(new BFSVertex());

            // Act
            bfs.Run(graph, v1);

            // Assert
            Assert.That(v1.Value.Distance, Is.EqualTo(0));
            Assert.That(v1.Value.Predecessor, Is.Null);
        }

        [Test]
        [Category("valid")]
        public void RunBFSOnCyclicGraph()
        {
            // Arrange
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);
            graph.AddEdge(v3, v1);

            // Act
            bfs.Run(graph, v1);

            // Assert
            Assert.That(v1.Value.Distance, Is.EqualTo(0));
            Assert.That(v2.Value.Distance, Is.EqualTo(1));
            Assert.That(v3.Value.Distance, Is.EqualTo(1));
            Assert.That(v1.Value.Predecessor, Is.Null);
            Assert.That(v2.Value.Predecessor, Is.EqualTo(v1));
            Assert.That(v3.Value.Predecessor, Is.EqualTo(v1));
        }

        [Test]
        [Category("integration")]
        public void RunBFSOnLargeGraphPerformance()
        {
            // Arrange
            const int vertexCount = 10000;
            var vertices = new List<Vertex<BFSVertex>>();
            for (int i = 0; i < vertexCount; i++)
            {
                vertices.Add(graph.AddVertex(new BFSVertex()));
            }

            for (int i = 0; i < vertexCount - 1; i++)
            {
                graph.AddEdge(vertices[i], vertices[i + 1]);
            }

            // Act
            var startTime = DateTime.Now;
            bfs.Run(graph, vertices[0]);
            var endTime = DateTime.Now;

            // Assert
            var duration = (endTime - startTime).TotalSeconds;
            Assert.That(duration, Is.LessThan(5), "BFS took too long to complete");
            Assert.That(vertices.Last().Value.Distance, Is.EqualTo(vertexCount - 1));
        }
    }
}
