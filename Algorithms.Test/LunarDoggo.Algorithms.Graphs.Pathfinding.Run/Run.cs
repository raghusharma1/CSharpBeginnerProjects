// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleCSharpEnv using AI Type  and AI Model 

ROOST_METHOD_HASH=Run_bbc3b7dcfd
ROOST_METHOD_SIG_HASH=Run_23f9485d25

   ########## Test-Scenarios ##########  

Based on the provided method and context, here are several test scenarios for the BreadthFirstSearch.Run method:

Scenario 1: Valid Graph and Start Vertex

Details:
  TestName: RunBFSWithValidGraphAndStartVertex
  Description: Test the BFS algorithm with a valid graph and start vertex to ensure correct traversal and distance calculation.

Execution:
  Arrange: Create a valid graph with multiple vertices and edges, and select a start vertex.
  Act: Call the Run method with the created graph and start vertex.
  Assert: Verify that all vertices are processed, distances are correctly calculated, and predecessors are properly set.

Validation:
  This test ensures that the BFS algorithm correctly traverses the graph, updating distances and predecessors for each vertex. It validates the core functionality of the BFS implementation.

Scenario 2: Null Graph Input

Details:
  TestName: RunBFSWithNullGraphThrowsArgumentNullException
  Description: Verify that the method throws an ArgumentNullException when a null graph is provided.

Execution:
  Arrange: Prepare a null graph and a valid start vertex.
  Act: Call the Run method with the null graph and valid start vertex.
  Assert: Verify that an ArgumentNullException is thrown with the correct error message.

Validation:
  This test ensures that the method properly handles invalid input by throwing the correct exception, maintaining robustness and preventing null reference errors.

Scenario 3: Disconnected Graph

Details:
  TestName: RunBFSOnDisconnectedGraph
  Description: Test the BFS algorithm on a graph with disconnected components to ensure correct behavior.

Execution:
  Arrange: Create a graph with multiple disconnected components and select a start vertex from one component.
  Act: Call the Run method with the disconnected graph and chosen start vertex.
  Assert: Verify that vertices in the same component as the start vertex are processed, while others remain unprocessed.

Validation:
  This test checks if the BFS algorithm correctly handles disconnected graphs, processing only the reachable vertices and leaving others untouched.

Scenario 4: Single Vertex Graph

Details:
  TestName: RunBFSOnSingleVertexGraph
  Description: Verify the behavior of BFS on a graph containing only one vertex.

Execution:
  Arrange: Create a graph with a single vertex and use it as the start vertex.
  Act: Call the Run method with the single-vertex graph and its only vertex as start.
  Assert: Check that the vertex is processed, has a distance of 0, and no predecessor.

Validation:
  This test ensures that the BFS algorithm correctly handles the edge case of a graph with only one vertex, validating its behavior in minimal graph scenarios.

Scenario 5: Cyclic Graph

Details:
  TestName: RunBFSOnCyclicGraph
  Description: Test the BFS algorithm on a graph containing cycles to ensure correct traversal and distance calculation.

Execution:
  Arrange: Create a graph with cycles and select a start vertex.
  Act: Call the Run method with the cyclic graph and chosen start vertex.
  Assert: Verify that all vertices are processed once, distances are correct, and the cycle doesn't cause infinite loops.

Validation:
  This test checks if the BFS algorithm correctly handles cycles in the graph, ensuring that each vertex is processed only once and distances are calculated correctly despite the presence of cycles.

Scenario 6: Large Graph Performance

Details:
  TestName: RunBFSOnLargeGraphPerformance
  Description: Evaluate the performance of the BFS algorithm on a large graph.

Execution:
  Arrange: Generate a large graph with many vertices and edges, and select a start vertex.
  Act: Measure the execution time of the Run method with the large graph and start vertex.
  Assert: Verify that the execution time is within acceptable limits and all vertices are processed correctly.

Validation:
  This test assesses the efficiency and scalability of the BFS implementation, ensuring it can handle large graphs within reasonable time constraints while maintaining correctness.

These test scenarios cover various aspects of the BreadthFirstSearch.Run method, including normal operation, edge cases, error handling, and performance considerations.


*/

// ********RoostGPT********
using NUnit.Framework;
using LunarDoggo.Datastructures.Graphs;
using LunarDoggo.Algorithms.Graphs.Pathfinding;
using System;
using System.Collections.Generic;
using System.Linq;

namespace LunarDoggo.Algorithms.Graphs.Pathfinding.Test
{
    [TestFixture]
    public class RunTest
    {
        private BreadthFirstSearch bfs;

        [SetUp]
        public void Setup()
        {
            bfs = new BreadthFirstSearch();
        }

        [Test, Category("valid")]
        public void RunBFSWithValidGraphAndStartVertex()
        {
            // Arrange
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            var v4 = graph.AddVertex(new BFSVertex());

            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);
            graph.AddEdge(v3, v4);

            // Act
            bfs.Run(graph, v1);

            // Assert
            Assert.That(v1.Value.Distance, Is.EqualTo(0));
            Assert.That(v2.Value.Distance, Is.EqualTo(1));
            Assert.That(v3.Value.Distance, Is.EqualTo(2));
            Assert.That(v4.Value.Distance, Is.EqualTo(3));

            Assert.That(v1.Value.Predecessor, Is.Null);
            Assert.That(v2.Value.Predecessor, Is.EqualTo(v1));
            Assert.That(v3.Value.Predecessor, Is.EqualTo(v2));
            Assert.That(v4.Value.Predecessor, Is.EqualTo(v3));

            Assert.That(v1.Value.Processed, Is.True);
            Assert.That(v2.Value.Processed, Is.True);
            Assert.That(v3.Value.Processed, Is.True);
            Assert.That(v4.Value.Processed, Is.True);
        }

        [Test, Category("invalid")]
        public void RunBFSWithNullGraphThrowsArgumentNullException()
        {
            // Arrange
            IGraph<BFSVertex> nullGraph = null;
            var startVertex = new Vertex<BFSVertex>(0, new BFSVertex());

            // Act & Assert
            Assert.Throws<ArgumentNullException>(() => bfs.Run(nullGraph, startVertex));
        }

        [Test, Category("valid")]
        public void RunBFSOnDisconnectedGraph()
        {
            // Arrange
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            var v4 = graph.AddVertex(new BFSVertex());

            graph.AddEdge(v1, v2);
            // v3 and v4 are disconnected

            // Act
            bfs.Run(graph, v1);

            // Assert
            Assert.That(v1.Value.Distance, Is.EqualTo(0));
            Assert.That(v2.Value.Distance, Is.EqualTo(1));
            Assert.That(v3.Value.Distance, Is.EqualTo(int.MaxValue));
            Assert.That(v4.Value.Distance, Is.EqualTo(int.MaxValue));

            Assert.That(v1.Value.Processed, Is.True);
            Assert.That(v2.Value.Processed, Is.True);
            Assert.That(v3.Value.Processed, Is.False);
            Assert.That(v4.Value.Processed, Is.False);
        }

        [Test, Category("boundary")]
        public void RunBFSOnSingleVertexGraph()
        {
            // Arrange
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());

            // Act
            bfs.Run(graph, v1);

            // Assert
            Assert.That(v1.Value.Distance, Is.EqualTo(0));
            Assert.That(v1.Value.Predecessor, Is.Null);
            Assert.That(v1.Value.Processed, Is.True);
        }

        [Test, Category("valid")]
        public void RunBFSOnCyclicGraph()
        {
            // Arrange
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            var v4 = graph.AddVertex(new BFSVertex());

            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);
            graph.AddEdge(v3, v4);
            graph.AddEdge(v4, v1);

            // Act
            bfs.Run(graph, v1);

            // Assert
            Assert.That(v1.Value.Distance, Is.EqualTo(0));
            Assert.That(v2.Value.Distance, Is.EqualTo(1));
            Assert.That(v3.Value.Distance, Is.EqualTo(2));
            Assert.That(v4.Value.Distance, Is.EqualTo(1));

            Assert.That(v1.Value.Predecessor, Is.Null);
            Assert.That(v2.Value.Predecessor, Is.EqualTo(v1));
            Assert.That(v3.Value.Predecessor, Is.EqualTo(v2));
            Assert.That(v4.Value.Predecessor, Is.EqualTo(v1));

            Assert.That(v1.Value.Processed, Is.True);
            Assert.That(v2.Value.Processed, Is.True);
            Assert.That(v3.Value.Processed, Is.True);
            Assert.That(v4.Value.Processed, Is.True);
        }

        [Test, Category("valid")]
        public void RunBFSOnLargeGraphPerformance()
        {
            // Arrange
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertices = new List<Vertex<BFSVertex>>();
            int vertexCount = 10000;
            int edgeCount = 50000;

            for (int i = 0; i < vertexCount; i++)
            {
                vertices.Add(graph.AddVertex(new BFSVertex()));
            }

            Random random = new Random(42);
            for (int i = 0; i < edgeCount; i++)
            {
                int from = random.Next(vertexCount);
                int to = random.Next(vertexCount);
                if (from != to)
                {
                    graph.AddEdge(vertices[from], vertices[to]);
                }
            }

            var startVertex = vertices[0];

            // Act
            var stopwatch = System.Diagnostics.Stopwatch.StartNew();
            bfs.Run(graph, startVertex);
            stopwatch.Stop();

            // Assert
            Assert.That(stopwatch.ElapsedMilliseconds, Is.LessThan(1000), "BFS took too long to execute");
            Assert.That(vertices.All(v => v.Value.Processed), Is.True, "Not all vertices were processed");
        }
    }
}
