// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleCSharpEnv using AI Type  and AI Model 

ROOST_METHOD_HASH=Run_bbc3b7dcfd
ROOST_METHOD_SIG_HASH=Run_23f9485d25

   ########## Test-Scenarios ##########  

Based on the provided method and context, here are several test scenarios for the `Run` method of the `BreadthFirstSearch` class:

Scenario 1: Null Graph Input

Details:
  TestName: ThrowArgumentNullExceptionWhenGraphIsNull
  Description: Verify that the method throws an ArgumentNullException when a null graph is provided.
Execution:
  Arrange: Create a BreadthFirstSearch instance and set up a null graph and a valid start vertex.
  Act: Call the Run method with the null graph and valid start vertex.
  Assert: Verify that an ArgumentNullException is thrown with the correct message.
Validation:
  This test ensures that the method properly handles null input for the graph parameter, maintaining robustness and preventing null reference exceptions later in the execution.

Scenario 2: Valid Graph with Single Vertex

Details:
  TestName: ProcessSingleVertexGraphCorrectly
  Description: Ensure the method correctly processes a graph with only one vertex (the start vertex).
Execution:
  Arrange: Create a BreadthFirstSearch instance, a graph with a single vertex, and set this vertex as the start vertex.
  Act: Call the Run method with the graph and start vertex.
  Assert: Verify that the start vertex's distance is 0 and it's marked as processed.
Validation:
  This test confirms that the method correctly initializes and processes the simplest possible graph, setting the foundation for more complex scenarios.

Scenario 3: Graph with Multiple Vertices but No Edges

Details:
  TestName: HandleGraphWithMultipleDisconnectedVertices
  Description: Verify the method's behavior when processing a graph with multiple vertices but no connecting edges.
Execution:
  Arrange: Create a BreadthFirstSearch instance, a graph with multiple vertices but no edges, and select one vertex as the start.
  Act: Call the Run method with the graph and start vertex.
  Assert: Check that only the start vertex is processed and has a distance of 0, while all other vertices remain unprocessed with maximum distance.
Validation:
  This scenario tests the method's ability to handle disconnected graphs, ensuring it doesn't process unreachable vertices.

Scenario 4: Simple Connected Graph

Details:
  TestName: ProcessSimpleConnectedGraphCorrectly
  Description: Test the method's ability to correctly process a simple connected graph with a few vertices and edges.
Execution:
  Arrange: Create a BreadthFirstSearch instance, a small connected graph (e.g., 3-4 vertices with connecting edges), and choose a start vertex.
  Act: Call the Run method with the graph and start vertex.
  Assert: Verify that all vertices are processed, have correct distances set, and have appropriate predecessors assigned.
Validation:
  This test ensures the core functionality of the BFS algorithm works correctly for a basic connected graph.

Scenario 5: Graph with Cycles

Details:
  TestName: HandleGraphWithCyclesCorrectly
  Description: Verify that the method correctly processes a graph containing cycles without getting stuck in an infinite loop.
Execution:
  Arrange: Create a BreadthFirstSearch instance, a graph with cycles (e.g., a square with diagonal), and select a start vertex.
  Act: Call the Run method with the graph and start vertex.
  Assert: Check that all vertices are processed exactly once, have correct distances, and appropriate predecessors.
Validation:
  This scenario tests the method's ability to handle cycles in the graph, which is crucial for the correctness of the BFS algorithm.

Scenario 6: Large Graph Performance

Details:
  TestName: ProcessLargeGraphWithinReasonableTime
  Description: Test the method's performance with a large graph to ensure it completes within a reasonable time frame.
Execution:
  Arrange: Create a BreadthFirstSearch instance, generate a large graph (e.g., 10000+ vertices with random connections), and select a start vertex.
  Act: Measure the time taken to call and complete the Run method.
  Assert: Verify that the method completes within an acceptable time limit and that all vertices are processed correctly.
Validation:
  This test ensures the method's performance scales reasonably with large inputs, which is important for real-world applications.

Scenario 7: Graph with Isolated Subgraphs

Details:
  TestName: HandleGraphWithIsolatedSubgraphs
  Description: Verify the method's behavior when the graph contains multiple isolated subgraphs.
Execution:
  Arrange: Create a BreadthFirstSearch instance, a graph with multiple isolated subgraphs, and select a start vertex in one of the subgraphs.
  Act: Call the Run method with the graph and start vertex.
  Assert: Check that only the vertices in the subgraph containing the start vertex are processed, while vertices in other subgraphs remain unprocessed.
Validation:
  This test ensures the method correctly handles graphs with disconnected components, processing only the reachable vertices.

These scenarios cover various aspects of the BreadthFirstSearch.Run method, including edge cases, error handling, and performance considerations. They aim to thoroughly test the method's functionality and robustness.


*/

// ********RoostGPT********
using NUnit.Framework;
using System;
using System.Collections.Generic;
using LunarDoggo.Datastructures.Graphs;
using LunarDoggo.Algorithms.Graphs.Pathfinding;

namespace LunarDoggo.Algorithms.Graphs.Pathfinding.Test
{
    [TestFixture]
    public class RunTest
    {
        [Test, Category("invalid")]
        public void ThrowArgumentNullExceptionWhenGraphIsNull()
        {
            var bfs = new BreadthFirstSearch();
            var startVertex = new Vertex<BFSVertex>(0, new BFSVertex());

            Assert.Throws<ArgumentNullException>(() => bfs.Run(null, startVertex));
        }

        [Test, Category("valid")]
        public void ProcessSingleVertexGraphCorrectly()
        {
            var bfs = new BreadthFirstSearch();
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var startVertex = graph.AddVertex(new BFSVertex());

            bfs.Run(graph, startVertex);

            Assert.That(startVertex.Value.Distance, Is.EqualTo(0));
            Assert.That(startVertex.Value.Processed, Is.True);
        }

        [Test, Category("valid")]
        public void HandleGraphWithMultipleDisconnectedVertices()
        {
            var bfs = new BreadthFirstSearch();
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var startVertex = graph.AddVertex(new BFSVertex());
            var otherVertex1 = graph.AddVertex(new BFSVertex());
            var otherVertex2 = graph.AddVertex(new BFSVertex());

            bfs.Run(graph, startVertex);

            Assert.That(startVertex.Value.Distance, Is.EqualTo(0));
            Assert.That(startVertex.Value.Processed, Is.True);
            Assert.That(otherVertex1.Value.Distance, Is.EqualTo(int.MaxValue));
            Assert.That(otherVertex1.Value.Processed, Is.False);
            Assert.That(otherVertex2.Value.Distance, Is.EqualTo(int.MaxValue));
            Assert.That(otherVertex2.Value.Processed, Is.False);
        }

        [Test, Category("valid")]
        public void ProcessSimpleConnectedGraphCorrectly()
        {
            var bfs = new BreadthFirstSearch();
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertex1 = graph.AddVertex(new BFSVertex());
            var vertex2 = graph.AddVertex(new BFSVertex());
            var vertex3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(vertex1, vertex2);
            graph.AddEdge(vertex2, vertex3);

            bfs.Run(graph, vertex1);

            Assert.That(vertex1.Value.Distance, Is.EqualTo(0));
            Assert.That(vertex2.Value.Distance, Is.EqualTo(1));
            Assert.That(vertex3.Value.Distance, Is.EqualTo(2));
            Assert.That(vertex1.Value.Processed, Is.True);
            Assert.That(vertex2.Value.Processed, Is.True);
            Assert.That(vertex3.Value.Processed, Is.True);
            Assert.That(vertex2.Value.Predecessor, Is.EqualTo(vertex1));
            Assert.That(vertex3.Value.Predecessor, Is.EqualTo(vertex2));
        }

        [Test, Category("valid")]
        public void HandleGraphWithCyclesCorrectly()
        {
            var bfs = new BreadthFirstSearch();
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertex1 = graph.AddVertex(new BFSVertex());
            var vertex2 = graph.AddVertex(new BFSVertex());
            var vertex3 = graph.AddVertex(new BFSVertex());
            var vertex4 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(vertex1, vertex2);
            graph.AddEdge(vertex2, vertex3);
            graph.AddEdge(vertex3, vertex4);
            graph.AddEdge(vertex4, vertex1);
            graph.AddEdge(vertex1, vertex3);

            bfs.Run(graph, vertex1);

            Assert.That(vertex1.Value.Distance, Is.EqualTo(0));
            Assert.That(vertex2.Value.Distance, Is.EqualTo(1));
            Assert.That(vertex3.Value.Distance, Is.EqualTo(1));
            Assert.That(vertex4.Value.Distance, Is.EqualTo(1));
            Assert.That(vertex1.Value.Processed, Is.True);
            Assert.That(vertex2.Value.Processed, Is.True);
            Assert.That(vertex3.Value.Processed, Is.True);
            Assert.That(vertex4.Value.Processed, Is.True);
        }

        [Test, Category("valid")]
        public void ProcessLargeGraphWithinReasonableTime()
        {
            var bfs = new BreadthFirstSearch();
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var random = new Random();
            var vertices = new List<Vertex<BFSVertex>>();

            for (int i = 0; i < 10000; i++)
            {
                vertices.Add(graph.AddVertex(new BFSVertex()));
            }

            for (int i = 0; i < 20000; i++)
            {
                int from = random.Next(vertices.Count);
                int to = random.Next(vertices.Count);
                if (from != to)
                {
                    graph.AddEdge(vertices[from], vertices[to]);
                }
            }

            var startTime = DateTime.Now;
            bfs.Run(graph, vertices[0]);
            var endTime = DateTime.Now;

            Assert.That((endTime - startTime).TotalSeconds, Is.LessThan(5));
            Assert.That(vertices.TrueForAll(v => v.Value.Processed), Is.True);
        }

        [Test, Category("valid")]
        public void HandleGraphWithIsolatedSubgraphs()
        {
            var bfs = new BreadthFirstSearch();
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            
            var subgraph1Vertex1 = graph.AddVertex(new BFSVertex());
            var subgraph1Vertex2 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(subgraph1Vertex1, subgraph1Vertex2);

            var subgraph2Vertex1 = graph.AddVertex(new BFSVertex());
            var subgraph2Vertex2 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(subgraph2Vertex1, subgraph2Vertex2);

            bfs.Run(graph, subgraph1Vertex1);

            Assert.That(subgraph1Vertex1.Value.Processed, Is.True);
            Assert.That(subgraph1Vertex2.Value.Processed, Is.True);
            Assert.That(subgraph2Vertex1.Value.Processed, Is.False);
            Assert.That(subgraph2Vertex2.Value.Processed, Is.False);
            Assert.That(subgraph1Vertex1.Value.Distance, Is.EqualTo(0));
            Assert.That(subgraph1Vertex2.Value.Distance, Is.EqualTo(1));
            Assert.That(subgraph2Vertex1.Value.Distance, Is.EqualTo(int.MaxValue));
            Assert.That(subgraph2Vertex2.Value.Distance, Is.EqualTo(int.MaxValue));
        }
    }
}
