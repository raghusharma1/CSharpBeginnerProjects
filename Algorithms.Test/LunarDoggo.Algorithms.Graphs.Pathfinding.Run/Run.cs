// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleCSharpEnv using AI Type  and AI Model 

ROOST_METHOD_HASH=Run_bbc3b7dcfd
ROOST_METHOD_SIG_HASH=Run_23f9485d25

   ########## Test-Scenarios ##########  

Based on the provided method and related code, here are several test scenarios for the `Run` method of the `BreadthFirstSearch` class:

Scenario 1: Valid Graph and Start Vertex

Details:
  TestName: RunBFSWithValidGraphAndStartVertex
  Description: Test the BFS algorithm with a valid graph and start vertex to ensure correct traversal and distance calculation.

Execution:
  Arrange: Create a valid graph with multiple vertices and edges, and select a start vertex.
  Act: Call the Run method with the created graph and start vertex.
  Assert: Check that all vertices are processed, distances are correctly calculated, and predecessors are properly set.

Validation:
  This test verifies that the BFS algorithm correctly traverses the graph, assigns proper distances from the start vertex, and sets correct predecessors for each vertex. It ensures the core functionality of the BFS algorithm is working as expected.

Scenario 2: Null Graph Input

Details:
  TestName: RunBFSWithNullGraphThrowsArgumentNullException
  Description: Test that the Run method throws an ArgumentNullException when given a null graph.

Execution:
  Arrange: Prepare a null graph and a valid start vertex.
  Act: Call the Run method with the null graph and valid start vertex.
  Assert: Verify that an ArgumentNullException is thrown with the correct error message.

Validation:
  This test ensures that the method properly handles invalid input by throwing the correct exception when a null graph is provided, maintaining the integrity of the method's input validation.

Scenario 3: Empty Graph

Details:
  TestName: RunBFSWithEmptyGraph
  Description: Test the BFS algorithm with an empty graph to ensure it handles this edge case correctly.

Execution:
  Arrange: Create an empty graph (no vertices or edges) and a start vertex.
  Act: Call the Run method with the empty graph and start vertex.
  Assert: Verify that no exceptions are thrown and the method completes without error.

Validation:
  This test checks that the BFS algorithm can handle the edge case of an empty graph without crashing or throwing unexpected exceptions, ensuring robustness in various scenarios.

Scenario 4: Graph with Isolated Vertices

Details:
  TestName: RunBFSWithGraphContainingIsolatedVertices
  Description: Test the BFS algorithm on a graph with some isolated vertices (vertices with no edges).

Execution:
  Arrange: Create a graph with both connected and isolated vertices, and select a start vertex from the connected portion.
  Act: Call the Run method with this graph and the selected start vertex.
  Assert: Verify that connected vertices are processed correctly and isolated vertices remain unprocessed (maximum distance and null predecessor).

Validation:
  This test ensures that the BFS algorithm correctly handles graphs with disconnected components, processing only the reachable vertices from the start vertex and leaving others untouched.

Scenario 5: Cyclic Graph

Details:
  TestName: RunBFSOnCyclicGraph
  Description: Test the BFS algorithm on a graph containing cycles to ensure it doesn't enter an infinite loop.

Execution:
  Arrange: Create a graph with at least one cycle and select a start vertex.
  Act: Call the Run method with this cyclic graph and start vertex.
  Assert: Verify that all vertices are processed exactly once, with correct distances and predecessors set.

Validation:
  This test checks that the BFS algorithm correctly handles cyclic graphs without getting stuck in infinite loops, ensuring that each vertex is processed only once regardless of the graph's structure.

Scenario 6: Large Graph Performance

Details:
  TestName: RunBFSOnLargeGraphPerformanceTest
  Description: Test the performance of the BFS algorithm on a large graph to ensure it completes within a reasonable time.

Execution:
  Arrange: Create a large graph with many vertices and edges, and select a start vertex.
  Act: Measure the time taken to execute the Run method on this large graph.
  Assert: Verify that the execution completes within an acceptable time limit and that all vertices are correctly processed.

Validation:
  This test ensures that the BFS algorithm remains efficient and performant even when dealing with large graphs, which is crucial for real-world applications where graph sizes can be substantial.

These test scenarios cover various aspects of the BreadthFirstSearch.Run method, including normal operation, edge cases, error handling, and performance considerations.


*/

// ********RoostGPT********
using NUnit.Framework;
using LunarDoggo.Datastructures.Graphs;
using LunarDoggo.Algorithms.Graphs.Pathfinding;
using System;
using System.Linq;

namespace LunarDoggo.Algorithms.Graphs.Pathfinding.Test
{
    [TestFixture]
    public class RunTest
    {
        [Test, Category("valid")]
        public void RunBFSWithValidGraphAndStartVertex()
        {
            // Arrange
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);

            var bfs = new BreadthFirstSearch();

            // Act
            bfs.Run(graph, v1);

            // Assert
            Assert.That(v1.Value.Distance, Is.EqualTo(0));
            Assert.That(v2.Value.Distance, Is.EqualTo(1));
            Assert.That(v3.Value.Distance, Is.EqualTo(2));
            Assert.That(v1.Value.Predecessor, Is.Null);
            Assert.That(v2.Value.Predecessor, Is.EqualTo(v1));
            Assert.That(v3.Value.Predecessor, Is.EqualTo(v2));
        }

        [Test, Category("invalid")]
        public void RunBFSWithNullGraphThrowsArgumentNullException()
        {
            // Arrange
            var bfs = new BreadthFirstSearch();
            var startVertex = new Vertex<BFSVertex>(0, new BFSVertex());

            // Act & Assert
            Assert.Throws<ArgumentNullException>(() => bfs.Run(null, startVertex));
        }

        [Test, Category("boundary")]
        public void RunBFSWithEmptyGraph()
        {
            // Arrange
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var startVertex = new Vertex<BFSVertex>(0, new BFSVertex());
            var bfs = new BreadthFirstSearch();

            // Act & Assert
            Assert.DoesNotThrow(() => bfs.Run(graph, startVertex));
        }

        [Test, Category("valid")]
        public void RunBFSWithGraphContainingIsolatedVertices()
        {
            // Arrange
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            var v4 = graph.AddVertex(new BFSVertex()); // Isolated vertex
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);

            var bfs = new BreadthFirstSearch();

            // Act
            bfs.Run(graph, v1);

            // Assert
            Assert.That(v1.Value.Distance, Is.EqualTo(0));
            Assert.That(v2.Value.Distance, Is.EqualTo(1));
            Assert.That(v3.Value.Distance, Is.EqualTo(2));
            Assert.That(v4.Value.Distance, Is.EqualTo(int.MaxValue));
            Assert.That(v4.Value.Predecessor, Is.Null);
        }

        [Test, Category("valid")]
        public void RunBFSOnCyclicGraph()
        {
            // Arrange
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);
            graph.AddEdge(v3, v1);

            var bfs = new BreadthFirstSearch();

            // Act
            bfs.Run(graph, v1);

            // Assert
            Assert.That(v1.Value.Distance, Is.EqualTo(0));
            Assert.That(v2.Value.Distance, Is.EqualTo(1));
            Assert.That(v3.Value.Distance, Is.EqualTo(1));
            Assert.That(v1.Value.Predecessor, Is.Null);
            Assert.That(v2.Value.Predecessor, Is.EqualTo(v1));
            Assert.That(v3.Value.Predecessor, Is.EqualTo(v1));
        }

        [Test, Category("valid")]
        public void RunBFSOnLargeGraphPerformanceTest()
        {
            // Arrange
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertices = Enumerable.Range(0, 10000).Select(_ => graph.AddVertex(new BFSVertex())).ToList();
            for (int i = 0; i < vertices.Count - 1; i++)
            {
                graph.AddEdge(vertices[i], vertices[i + 1]);
            }

            var bfs = new BreadthFirstSearch();
            var startVertex = vertices[0];

            // Act
            var startTime = DateTime.Now;
            bfs.Run(graph, startVertex);
            var duration = DateTime.Now - startTime;

            // Assert
            Assert.That(duration.TotalSeconds, Is.LessThan(5), "BFS took too long to complete");
            Assert.That(vertices.All(v => v.Value.Processed), Is.True, "Not all vertices were processed");
            Assert.That(vertices.Last().Value.Distance, Is.EqualTo(9999), "Incorrect distance for the last vertex");
        }
    }
}
