// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleCSharpEnv using AI Type  and AI Model 

ROOST_METHOD_HASH=Run_bbc3b7dcfd
ROOST_METHOD_SIG_HASH=Run_23f9485d25

   ########## Test-Scenarios ##########  

Based on the provided method and related code, here are several test scenarios for the `Run` method of the `BreadthFirstSearch` class:

Scenario 1: Null Graph Handling

Details:
  TestName: ThrowsArgumentNullExceptionWhenGraphIsNull
  Description: Verify that the method throws an ArgumentNullException when a null graph is passed.
Execution:
  Arrange: Create a BreadthFirstSearch instance and prepare a null graph and a valid start vertex.
  Act: Call the Run method with the null graph and valid start vertex.
  Assert: Expect an ArgumentNullException to be thrown.
Validation:
  This test ensures that the method properly handles null input for the graph parameter, maintaining robustness and preventing null reference exceptions later in the execution.

Scenario 2: Basic BFS Traversal

Details:
  TestName: CorrectlyTraversesSimpleGraph
  Description: Ensure that the BFS algorithm correctly traverses a simple graph and sets the correct distances and predecessors.
Execution:
  Arrange: Create a small graph with known structure (e.g., a simple tree or a small network).
  Act: Run the BFS algorithm on this graph starting from a specific vertex.
  Assert: Check that all vertices have been processed, and their distances and predecessors are set correctly.
Validation:
  This test verifies the core functionality of the BFS algorithm, ensuring it visits all nodes in the correct order and assigns proper distances and predecessors.

Scenario 3: Isolated Vertex Handling

Details:
  TestName: HandlesIsolatedVerticesCorrectly
  Description: Verify that the algorithm correctly handles graphs with isolated vertices.
Execution:
  Arrange: Create a graph with some connected vertices and one or more isolated vertices.
  Act: Run the BFS algorithm starting from a connected vertex.
  Assert: Check that isolated vertices remain unprocessed (Processed = false) and maintain their initial distance (Int32.MaxValue).
Validation:
  This test ensures that the BFS algorithm doesn't incorrectly process or modify isolated vertices that are unreachable from the start vertex.

Scenario 4: Cyclic Graph Traversal

Details:
  TestName: CorrectlyTraversesCyclicGraph
  Description: Ensure that the BFS algorithm correctly handles graphs containing cycles without getting stuck in infinite loops.
Execution:
  Arrange: Create a graph with one or more cycles.
  Act: Run the BFS algorithm on this cyclic graph.
  Assert: Verify that all vertices are processed exactly once and have correct distances and predecessors.
Validation:
  This test checks that the algorithm can handle cyclic structures without revisiting nodes or falling into infinite loops, which is crucial for graph traversal algorithms.

Scenario 5: Large Graph Performance

Details:
  TestName: PerformsEfficientlyOnLargeGraph
  Description: Verify that the BFS algorithm performs efficiently on a large graph within a reasonable time frame.
Execution:
  Arrange: Create a large graph with many vertices and edges.
  Act: Run the BFS algorithm on this large graph and measure the execution time.
  Assert: Check that the algorithm completes within an acceptable time limit and correctly processes all vertices.
Validation:
  This test ensures that the implementation is efficient and scales well with larger graphs, which is important for real-world applications.

Scenario 6: Start Vertex Initialization

Details:
  TestName: CorrectlyInitializesStartVertex
  Description: Verify that the start vertex is correctly initialized with distance 0 and marked as processed.
Execution:
  Arrange: Create a graph and select a start vertex.
  Act: Run the BFS algorithm.
  Assert: Check that the start vertex has a distance of 0 and is marked as processed.
Validation:
  This test ensures that the starting point of the BFS is correctly set up, which is crucial for the rest of the traversal to work properly.

Scenario 7: Disconnected Graph Traversal

Details:
  TestName: CorrectlyHandlesDisconnectedGraph
  Description: Ensure that the BFS algorithm correctly traverses a disconnected graph, processing only the component reachable from the start vertex.
Execution:
  Arrange: Create a graph with multiple disconnected components.
  Act: Run the BFS algorithm starting from a vertex in one of the components.
  Assert: Verify that only vertices in the same component as the start vertex are processed, while vertices in other components remain unprocessed.
Validation:
  This test checks that the algorithm respects the graph's structure and doesn't incorrectly process unreachable parts of a disconnected graph.

These test scenarios cover various aspects of the BreadthFirstSearch algorithm, including edge cases, error handling, and performance considerations. They should provide a comprehensive suite for validating the correctness and robustness of the implementation.


*/

// ********RoostGPT********
using NUnit.Framework;
using LunarDoggo.Datastructures.Graphs;
using LunarDoggo.Algorithms.Graphs.Pathfinding;
using System;
using System.Linq;

namespace LunarDoggo.Algorithms.Graphs.Pathfinding.Test
{
    [TestFixture]
    public class RunTest
    {
        [Test, Category("invalid")]
        public void ThrowsArgumentNullExceptionWhenGraphIsNull()
        {
            var bfs = new BreadthFirstSearch();
            var startVertex = new Vertex<BFSVertex>(0, new BFSVertex());

            Assert.Throws<ArgumentNullException>(() => bfs.Run(null, startVertex));
        }

        [Test, Category("valid")]
        public void CorrectlyTraversesSimpleGraph()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);

            var bfs = new BreadthFirstSearch();
            bfs.Run(graph, v1);

            Assert.IsTrue(v1.Value.Processed);
            Assert.IsTrue(v2.Value.Processed);
            Assert.IsTrue(v3.Value.Processed);
            Assert.AreEqual(0, v1.Value.Distance);
            Assert.AreEqual(1, v2.Value.Distance);
            Assert.AreEqual(2, v3.Value.Distance);
            Assert.IsNull(v1.Value.Predecessor);
            Assert.AreEqual(v1, v2.Value.Predecessor);
            Assert.AreEqual(v2, v3.Value.Predecessor);
        }

        [Test, Category("valid")]
        public void HandlesIsolatedVerticesCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var isolated = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);

            var bfs = new BreadthFirstSearch();
            bfs.Run(graph, v1);

            Assert.IsTrue(v1.Value.Processed);
            Assert.IsTrue(v2.Value.Processed);
            Assert.IsFalse(isolated.Value.Processed);
            Assert.AreEqual(Int32.MaxValue, isolated.Value.Distance);
            Assert.IsNull(isolated.Value.Predecessor);
        }

        [Test, Category("valid")]
        public void CorrectlyTraversesCyclicGraph()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);
            graph.AddEdge(v3, v1);

            var bfs = new BreadthFirstSearch();
            bfs.Run(graph, v1);

            Assert.IsTrue(v1.Value.Processed);
            Assert.IsTrue(v2.Value.Processed);
            Assert.IsTrue(v3.Value.Processed);
            Assert.AreEqual(0, v1.Value.Distance);
            Assert.AreEqual(1, v2.Value.Distance);
            Assert.AreEqual(1, v3.Value.Distance);
        }

        [Test, Category("valid")]
        public void PerformsEfficientlyOnLargeGraph()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertices = Enumerable.Range(0, 10000).Select(_ => graph.AddVertex(new BFSVertex())).ToList();
            for (int i = 0; i < vertices.Count - 1; i++)
            {
                graph.AddEdge(vertices[i], vertices[i + 1]);
            }

            var bfs = new BreadthFirstSearch();
            var startTime = DateTime.Now;
            bfs.Run(graph, vertices[0]);
            var endTime = DateTime.Now;

            Assert.Less((endTime - startTime).TotalSeconds, 5);
            Assert.IsTrue(vertices.All(v => v.Value.Processed));
        }

        [Test, Category("valid")]
        public void CorrectlyInitializesStartVertex()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var start = graph.AddVertex(new BFSVertex());
            var other = graph.AddVertex(new BFSVertex());
            graph.AddEdge(start, other);

            var bfs = new BreadthFirstSearch();
            bfs.Run(graph, start);

            Assert.IsTrue(start.Value.Processed);
            Assert.AreEqual(0, start.Value.Distance);
            Assert.IsNull(start.Value.Predecessor);
        }

        [Test, Category("valid")]
        public void CorrectlyHandlesDisconnectedGraph()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            var v4 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v3, v4);

            var bfs = new BreadthFirstSearch();
            bfs.Run(graph, v1);

            Assert.IsTrue(v1.Value.Processed);
            Assert.IsTrue(v2.Value.Processed);
            Assert.IsFalse(v3.Value.Processed);
            Assert.IsFalse(v4.Value.Processed);
        }
    }
}
