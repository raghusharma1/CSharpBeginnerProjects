// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleCSharpEnv using AI Type  and AI Model 

ROOST_METHOD_HASH=Run_bbc3b7dcfd
ROOST_METHOD_SIG_HASH=Run_23f9485d25

   ########## Test-Scenarios ##########  

Based on the provided method and related code, here are several test scenarios for the `Run` method of the `BreadthFirstSearch` class:

Scenario 1: Null Graph Handling

Details:
  TestName: ThrowsArgumentNullExceptionWhenGraphIsNull
  Description: Verify that the method throws an ArgumentNullException when a null graph is provided.
Execution:
  Arrange: Create a BreadthFirstSearch instance and set up a null graph and a valid start vertex.
  Act: Call the Run method with the null graph and valid start vertex.
  Assert: Expect an ArgumentNullException to be thrown.
Validation:
  This test ensures that the method properly handles null input for the graph parameter, maintaining robustness and preventing null reference exceptions later in the execution.

Scenario 2: Single Vertex Graph

Details:
  TestName: ProcessesSingleVertexGraphCorrectly
  Description: Ensure the method correctly processes a graph with only one vertex (the start vertex).
Execution:
  Arrange: Create a graph with a single vertex and set it as the start vertex.
  Act: Run the BFS algorithm on this graph.
  Assert: Verify that the vertex is marked as processed, has a distance of 0, and has no predecessor.
Validation:
  This test confirms that the BFS algorithm works correctly for the simplest possible graph, setting a baseline for more complex scenarios.

Scenario 3: Linear Graph Traversal

Details:
  TestName: TraversesLinearGraphCorrectly
  Description: Test the BFS algorithm on a linear graph (each vertex connected to at most two others).
Execution:
  Arrange: Create a linear graph with multiple vertices.
  Act: Run the BFS algorithm starting from one end of the graph.
  Assert: Check that each vertex is processed in order, with increasing distances and correct predecessors.
Validation:
  This scenario verifies that the BFS algorithm correctly traverses a simple linear structure, assigning proper distances and predecessors.

Scenario 4: Branching Graph Traversal

Details:
  TestName: TraversesBranchingGraphCorrectly
  Description: Verify the BFS algorithm's behavior on a graph with multiple branches.
Execution:
  Arrange: Create a graph with a root vertex that branches out to multiple paths.
  Act: Run the BFS algorithm starting from the root vertex.
  Assert: Ensure all vertices are processed, with correct distances and predecessors based on their level in the graph.
Validation:
  This test confirms that the BFS algorithm correctly handles graphs with multiple paths, processing vertices in the correct order of their distance from the start.

Scenario 5: Cyclic Graph Handling

Details:
  TestName: HandlesCyclicGraphWithoutInfiniteLoop
  Description: Ensure the BFS algorithm correctly processes a graph containing cycles without getting stuck in an infinite loop.
Execution:
  Arrange: Create a graph with at least one cycle.
  Act: Run the BFS algorithm on this cyclic graph.
  Assert: Verify that all vertices are processed exactly once, with correct distances and predecessors.
Validation:
  This scenario is crucial for ensuring that the algorithm can handle graphs with cycles, which is a common occurrence in real-world graph structures.

Scenario 6: Disconnected Graph Components

Details:
  TestName: ProcessesOnlyReachableVerticesInDisconnectedGraph
  Description: Verify that the BFS algorithm only processes vertices reachable from the start vertex in a disconnected graph.
Execution:
  Arrange: Create a graph with multiple disconnected components.
  Act: Run the BFS algorithm starting from a vertex in one of the components.
  Assert: Check that only vertices in the same component as the start vertex are processed, while others remain unprocessed.
Validation:
  This test ensures that the BFS algorithm correctly handles disconnected graphs, processing only the reachable portion of the graph.

Scenario 7: Large Graph Performance

Details:
  TestName: CompletesLargeGraphTraversalInReasonableTime
  Description: Test the performance of the BFS algorithm on a large graph to ensure it completes in a reasonable time.
Execution:
  Arrange: Create a large graph with many vertices and edges.
  Act: Run the BFS algorithm on this large graph, measuring the execution time.
  Assert: Verify that the algorithm completes within an acceptable time frame and processes all vertices correctly.
Validation:
  This scenario helps ensure that the BFS implementation is efficient and can handle large-scale graphs without excessive time complexity.

These test scenarios cover various aspects of the BreadthFirstSearch implementation, including edge cases, error handling, and different graph structures. They aim to validate the correctness and efficiency of the algorithm across different scenarios.


*/

// ********RoostGPT********
using NUnit.Framework;
using LunarDoggo.Datastructures.Graphs;
using LunarDoggo.Algorithms.Graphs.Pathfinding;
using System;
using System.Linq;

namespace LunarDoggo.Algorithms.Graphs.Pathfinding.Test
{
    [TestFixture]
    public class RunTest
    {
        [Test, Category("invalid")]
        public void ThrowsArgumentNullExceptionWhenGraphIsNull()
        {
            var bfs = new BreadthFirstSearch();
            var startVertex = new Vertex<BFSVertex>(0, new BFSVertex());

            Assert.Throws<ArgumentNullException>(() => bfs.Run(null, startVertex));
        }

        [Test, Category("valid")]
        public void ProcessesSingleVertexGraphCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertex = graph.AddVertex(new BFSVertex());
            var bfs = new BreadthFirstSearch();

            bfs.Run(graph, vertex);

            Assert.IsTrue(vertex.Value.Processed);
            Assert.AreEqual(0, vertex.Value.Distance);
            Assert.IsNull(vertex.Value.Predecessor);
        }

        [Test, Category("valid")]
        public void TraversesLinearGraphCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);

            var bfs = new BreadthFirstSearch();
            bfs.Run(graph, v1);

            Assert.IsTrue(v1.Value.Processed);
            Assert.IsTrue(v2.Value.Processed);
            Assert.IsTrue(v3.Value.Processed);
            Assert.AreEqual(0, v1.Value.Distance);
            Assert.AreEqual(1, v2.Value.Distance);
            Assert.AreEqual(2, v3.Value.Distance);
            Assert.IsNull(v1.Value.Predecessor);
            Assert.AreEqual(v1, v2.Value.Predecessor);
            Assert.AreEqual(v2, v3.Value.Predecessor);
        }

        [Test, Category("valid")]
        public void TraversesBranchingGraphCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var root = graph.AddVertex(new BFSVertex());
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(root, v1);
            graph.AddEdge(root, v2);
            graph.AddEdge(v1, v3);

            var bfs = new BreadthFirstSearch();
            bfs.Run(graph, root);

            Assert.IsTrue(root.Value.Processed);
            Assert.IsTrue(v1.Value.Processed);
            Assert.IsTrue(v2.Value.Processed);
            Assert.IsTrue(v3.Value.Processed);
            Assert.AreEqual(0, root.Value.Distance);
            Assert.AreEqual(1, v1.Value.Distance);
            Assert.AreEqual(1, v2.Value.Distance);
            Assert.AreEqual(2, v3.Value.Distance);
            Assert.IsNull(root.Value.Predecessor);
            Assert.AreEqual(root, v1.Value.Predecessor);
            Assert.AreEqual(root, v2.Value.Predecessor);
            Assert.AreEqual(v1, v3.Value.Predecessor);
        }

        [Test, Category("valid")]
        public void HandlesCyclicGraphWithoutInfiniteLoop()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);
            graph.AddEdge(v3, v1);

            var bfs = new BreadthFirstSearch();
            bfs.Run(graph, v1);

            Assert.IsTrue(v1.Value.Processed);
            Assert.IsTrue(v2.Value.Processed);
            Assert.IsTrue(v3.Value.Processed);
            Assert.AreEqual(0, v1.Value.Distance);
            Assert.AreEqual(1, v2.Value.Distance);
            Assert.AreEqual(1, v3.Value.Distance);
            Assert.IsNull(v1.Value.Predecessor);
            Assert.AreEqual(v1, v2.Value.Predecessor);
            Assert.AreEqual(v1, v3.Value.Predecessor);
        }

        [Test, Category("valid")]
        public void ProcessesOnlyReachableVerticesInDisconnectedGraph()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            var v4 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v3, v4);

            var bfs = new BreadthFirstSearch();
            bfs.Run(graph, v1);

            Assert.IsTrue(v1.Value.Processed);
            Assert.IsTrue(v2.Value.Processed);
            Assert.IsFalse(v3.Value.Processed);
            Assert.IsFalse(v4.Value.Processed);
            Assert.AreEqual(0, v1.Value.Distance);
            Assert.AreEqual(1, v2.Value.Distance);
            Assert.AreEqual(int.MaxValue, v3.Value.Distance);
            Assert.AreEqual(int.MaxValue, v4.Value.Distance);
        }

        [Test, Category("valid")]
        public void CompletesLargeGraphTraversalInReasonableTime()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertices = Enumerable.Range(0, 10000).Select(_ => graph.AddVertex(new BFSVertex())).ToList();
            
            for (int i = 0; i < vertices.Count - 1; i++)
            {
                graph.AddEdge(vertices[i], vertices[i + 1]);
            }

            var bfs = new BreadthFirstSearch();
            var startTime = DateTime.Now;
            bfs.Run(graph, vertices[0]);
            var endTime = DateTime.Now;

            Assert.Less((endTime - startTime).TotalSeconds, 5); // Assuming 5 seconds is reasonable
            Assert.IsTrue(vertices.All(v => v.Value.Processed));
            for (int i = 0; i < vertices.Count; i++)
            {
                Assert.AreEqual(i, vertices[i].Value.Distance);
            }
        }
    }
}
