// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleCSharpEnv using AI Type  and AI Model 

ROOST_METHOD_HASH=Run_bbc3b7dcfd
ROOST_METHOD_SIG_HASH=Run_23f9485d25

   ########## Test-Scenarios ##########  

Based on the provided method and context, here are several test scenarios for the `Run` method of the `BreadthFirstSearch` class:

Scenario 1: Null Graph Input

Details:
  TestName: ThrowsArgumentNullExceptionWhenGraphIsNull
  Description: Verify that the method throws an ArgumentNullException when a null graph is provided.
Execution:
  Arrange: Create a BreadthFirstSearch instance and prepare a null graph and a valid start vertex.
  Act: Call the Run method with the null graph and valid start vertex.
  Assert: Expect an ArgumentNullException to be thrown.
Validation:
  This test ensures that the method properly handles null input for the graph parameter, maintaining robustness and preventing null reference exceptions later in the execution.

Scenario 2: Valid Graph with Single Vertex

Details:
  TestName: ProcessesSingleVertexGraphCorrectly
  Description: Ensure the method correctly processes a graph with only one vertex (the start vertex).
Execution:
  Arrange: Create a BreadthFirstSearch instance, a graph with a single vertex, and set this vertex as the start.
  Act: Call the Run method with the graph and start vertex.
  Assert: Verify that the start vertex has a distance of 0 and is marked as processed.
Validation:
  This test confirms that the method correctly initializes and processes the simplest possible graph, setting the foundation for more complex scenarios.

Scenario 3: Graph with Multiple Vertices

Details:
  TestName: CorrectlyProcessesMultiVertexGraph
  Description: Verify that the method correctly processes a graph with multiple vertices, setting distances and predecessors.
Execution:
  Arrange: Create a BreadthFirstSearch instance, a graph with multiple vertices and edges, and choose a start vertex.
  Act: Call the Run method with the graph and start vertex.
  Assert: Check that all vertices are processed, have correct distances from the start, and have appropriate predecessors set.
Validation:
  This test ensures that the core functionality of the BFS algorithm is working correctly for a typical use case.

Scenario 4: Disconnected Graph

Details:
  TestName: HandlesDisconnectedGraphCorrectly
  Description: Ensure the method correctly processes a graph with disconnected components.
Execution:
  Arrange: Create a BreadthFirstSearch instance, a graph with multiple disconnected components, and choose a start vertex in one component.
  Act: Call the Run method with the graph and start vertex.
  Assert: Verify that vertices in the same component as the start are processed and have distances set, while vertices in other components remain unprocessed with maximum distance.
Validation:
  This test confirms that the method behaves correctly when faced with a graph that isn't fully connected, a common edge case in graph algorithms.

Scenario 5: Cyclic Graph

Details:
  TestName: ProcessesCyclicGraphWithoutInfiniteLoop
  Description: Verify that the method correctly handles a graph containing cycles without entering an infinite loop.
Execution:
  Arrange: Create a BreadthFirstSearch instance, a graph with cycles, and choose a start vertex.
  Act: Call the Run method with the graph and start vertex.
  Assert: Check that all vertices are processed exactly once and have correct distances set.
Validation:
  This test ensures that the method can handle graphs with cycles, a crucial aspect of graph traversal algorithms.

Scenario 6: Large Graph Performance

Details:
  TestName: CompletesInReasonableTimeForLargeGraph
  Description: Ensure the method completes in a reasonable time for a large graph, testing its efficiency.
Execution:
  Arrange: Create a BreadthFirstSearch instance, a large graph with many vertices and edges, and choose a start vertex.
  Act: Call the Run method with the graph and start vertex, measuring the execution time.
  Assert: Verify that the method completes within an acceptable time limit and that all vertices are processed.
Validation:
  This test checks the performance characteristics of the implementation, ensuring it scales well to larger inputs.

Scenario 7: Graph with Self-Loops

Details:
  TestName: HandlesSelfLoopsCorrectly
  Description: Verify that the method correctly processes a graph containing vertices with edges to themselves (self-loops).
Execution:
  Arrange: Create a BreadthFirstSearch instance, a graph with self-loops, and choose a start vertex.
  Act: Call the Run method with the graph and start vertex.
  Assert: Check that all vertices are processed correctly and self-loops don't affect the distances or processing order.
Validation:
  This test ensures that the method can handle graphs with self-loops, which can be a special case in some graph algorithms.

These test scenarios cover various aspects of the BreadthFirstSearch.Run method, including normal operation, edge cases, and error handling. They should provide a comprehensive test suite for this method.


*/

// ********RoostGPT********
using NUnit.Framework;
using LunarDoggo.Datastructures.Graphs;
using LunarDoggo.Algorithms.Graphs.Pathfinding;
using System;
using System.Linq;

namespace LunarDoggo.Algorithms.Graphs.Pathfinding.Test
{
    [TestFixture]
    public class RunTest
    {
        private BreadthFirstSearch bfs;
        private UndirectedUnweightedGraph<BFSVertex> graph;

        [SetUp]
        public void Setup()
        {
            bfs = new BreadthFirstSearch();
            graph = new UndirectedUnweightedGraph<BFSVertex>();
        }

        [Test, Category("invalid")]
        public void ThrowsArgumentNullExceptionWhenGraphIsNull()
        {
            var start = new Vertex<BFSVertex>(0, new BFSVertex());
            Assert.Throws<ArgumentNullException>(() => bfs.Run(null, start));
        }

        [Test, Category("valid")]
        public void ProcessesSingleVertexGraphCorrectly()
        {
            var vertex = graph.AddVertex(new BFSVertex());
            bfs.Run(graph, vertex);

            Assert.AreEqual(0, vertex.Value.Distance);
            Assert.IsTrue(vertex.Value.Processed);
            Assert.IsNull(vertex.Value.Predecessor);
        }

        [Test, Category("valid")]
        public void CorrectlyProcessesMultiVertexGraph()
        {
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);

            bfs.Run(graph, v1);

            Assert.AreEqual(0, v1.Value.Distance);
            Assert.AreEqual(1, v2.Value.Distance);
            Assert.AreEqual(2, v3.Value.Distance);
            Assert.IsTrue(v1.Value.Processed);
            Assert.IsTrue(v2.Value.Processed);
            Assert.IsTrue(v3.Value.Processed);
            Assert.IsNull(v1.Value.Predecessor);
            Assert.AreEqual(v1, v2.Value.Predecessor);
            Assert.AreEqual(v2, v3.Value.Predecessor);
        }

        [Test, Category("valid")]
        public void HandlesDisconnectedGraphCorrectly()
        {
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);

            bfs.Run(graph, v1);

            Assert.AreEqual(0, v1.Value.Distance);
            Assert.AreEqual(1, v2.Value.Distance);
            Assert.AreEqual(int.MaxValue, v3.Value.Distance);
            Assert.IsTrue(v1.Value.Processed);
            Assert.IsTrue(v2.Value.Processed);
            Assert.IsFalse(v3.Value.Processed);
        }

        [Test, Category("valid")]
        public void ProcessesCyclicGraphWithoutInfiniteLoop()
        {
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);
            graph.AddEdge(v3, v1);

            bfs.Run(graph, v1);

            Assert.AreEqual(0, v1.Value.Distance);
            Assert.AreEqual(1, v2.Value.Distance);
            Assert.AreEqual(1, v3.Value.Distance);
            Assert.IsTrue(v1.Value.Processed);
            Assert.IsTrue(v2.Value.Processed);
            Assert.IsTrue(v3.Value.Processed);
        }

        [Test, Category("valid")]
        public void CompletesInReasonableTimeForLargeGraph()
        {
            const int vertexCount = 10000;
            var vertices = Enumerable.Range(0, vertexCount)
                .Select(_ => graph.AddVertex(new BFSVertex()))
                .ToList();

            for (int i = 0; i < vertexCount - 1; i++)
            {
                graph.AddEdge(vertices[i], vertices[i + 1]);
            }

            var startTime = DateTime.Now;
            bfs.Run(graph, vertices[0]);
            var endTime = DateTime.Now;

            Assert.Less((endTime - startTime).TotalSeconds, 5);
            Assert.IsTrue(vertices.All(v => v.Value.Processed));
        }

        [Test, Category("valid")]
        public void HandlesSelfLoopsCorrectly()
        {
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v1);
            graph.AddEdge(v1, v2);

            bfs.Run(graph, v1);

            Assert.AreEqual(0, v1.Value.Distance);
            Assert.AreEqual(1, v2.Value.Distance);
            Assert.IsTrue(v1.Value.Processed);
            Assert.IsTrue(v2.Value.Processed);
            Assert.IsNull(v1.Value.Predecessor);
            Assert.AreEqual(v1, v2.Value.Predecessor);
        }
    }
}
