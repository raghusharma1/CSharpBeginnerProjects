// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleCSharpEnv using AI Type  and AI Model 

ROOST_METHOD_HASH=Run_bbc3b7dcfd
ROOST_METHOD_SIG_HASH=Run_23f9485d25

   ########## Test-Scenarios ##########  

Based on the provided method and context, here are several test scenarios for the BreadthFirstSearch.Run method:

Scenario 1: Null Graph Handling

Details:
  TestName: ThrowsArgumentNullExceptionWhenGraphIsNull
  Description: Verify that the method throws an ArgumentNullException when a null graph is passed.

Execution:
  Arrange: Create a BreadthFirstSearch instance and a null IGraph<BFSVertex>.
  Act: Call the Run method with the null graph and a valid start vertex.
  Assert: Expect an ArgumentNullException to be thrown.

Validation:
  This test ensures that the method properly handles null input for the graph parameter, maintaining robustness and preventing null reference exceptions later in the execution.

Scenario 2: Single Vertex Graph

Details:
  TestName: ProcessesSingleVertexGraphCorrectly
  Description: Ensure the method correctly processes a graph with only one vertex.

Execution:
  Arrange: Create a BreadthFirstSearch instance and an IGraph<BFSVertex> with a single vertex.
  Act: Call the Run method with the graph and the single vertex as the start.
  Assert: Verify that the vertex's Distance is 0 and Processed is true.

Validation:
  This test confirms that the algorithm works correctly for the simplest possible graph, setting the correct distance and processed state for the start vertex.

Scenario 3: Linear Graph Traversal

Details:
  TestName: CorrectlyTraversesLinearGraph
  Description: Verify that the method correctly traverses a linear graph (a chain of vertices).

Execution:
  Arrange: Create a BreadthFirstSearch instance and an IGraph<BFSVertex> with a linear structure (e.g., A -> B -> C -> D).
  Act: Call the Run method with the graph and the first vertex as the start.
  Assert: Check that each vertex has the correct Distance (0, 1, 2, 3) and Predecessor.

Validation:
  This test ensures that the BFS algorithm correctly calculates distances and predecessors in a simple linear graph structure.

Scenario 4: Branching Graph Traversal

Details:
  TestName: CorrectlyTraversesBranchingGraph
  Description: Verify that the method correctly traverses a graph with multiple branches.

Execution:
  Arrange: Create a BreadthFirstSearch instance and an IGraph<BFSVertex> with a branching structure (e.g., A -> B -> C, A -> D -> E).
  Act: Call the Run method with the graph and vertex A as the start.
  Assert: Verify that all vertices have correct Distance values and Predecessors.

Validation:
  This test confirms that the BFS algorithm correctly handles branching paths, assigning proper distances and predecessors in a more complex graph structure.

Scenario 5: Cyclic Graph Handling

Details:
  TestName: CorrectlyHandlesCyclicGraph
  Description: Ensure the method correctly processes a graph containing cycles without getting stuck in an infinite loop.

Execution:
  Arrange: Create a BreadthFirstSearch instance and an IGraph<BFSVertex> with a cycle (e.g., A -> B -> C -> A).
  Act: Call the Run method with the graph and any vertex as the start.
  Assert: Verify that all vertices are processed, have correct Distance values, and the algorithm terminates.

Validation:
  This test checks that the BFS algorithm can handle cycles in the graph without issues, ensuring it doesn't revisit already processed vertices.

Scenario 6: Disconnected Graph Components

Details:
  TestName: ProcessesOnlyReachableVerticesInDisconnectedGraph
  Description: Verify that the method only processes vertices reachable from the start vertex in a disconnected graph.

Execution:
  Arrange: Create a BreadthFirstSearch instance and an IGraph<BFSVertex> with disconnected components (e.g., (A -> B, C -> D)).
  Act: Call the Run method with the graph and vertex A as the start.
  Assert: Check that vertices A and B are processed with correct distances, while C and D remain unprocessed.

Validation:
  This test ensures that the BFS algorithm correctly handles disconnected graphs, only processing the component reachable from the start vertex.

Scenario 7: Large Graph Performance

Details:
  TestName: CompletesLargeGraphTraversalInReasonableTime
  Description: Verify that the method can process a large graph within an acceptable time frame.

Execution:
  Arrange: Create a BreadthFirstSearch instance and a large IGraph<BFSVertex> (e.g., 10000 vertices).
  Act: Measure the time taken to call and complete the Run method.
  Assert: Verify that the execution time is within an acceptable limit.

Validation:
  This test checks the performance characteristics of the BFS implementation, ensuring it can handle large graphs efficiently.

These test scenarios cover various aspects of the BreadthFirstSearch.Run method, including error handling, correct traversal in different graph structures, and performance considerations.


*/

// ********RoostGPT********
using NUnit.Framework;
using LunarDoggo.Datastructures.Graphs;
using LunarDoggo.Algorithms.Graphs.Pathfinding;
using System;
using System.Linq;

namespace LunarDoggo.Algorithms.Graphs.Pathfinding.Test
{
    [TestFixture]
    public class RunTest
    {
        [Test, Category("invalid")]
        public void ThrowsArgumentNullExceptionWhenGraphIsNull()
        {
            var bfs = new BreadthFirstSearch();
            var startVertex = new Vertex<BFSVertex>(0, new BFSVertex());

            Assert.Throws<ArgumentNullException>(() => bfs.Run(null, startVertex));
        }

        [Test, Category("valid")]
        public void ProcessesSingleVertexGraphCorrectly()
        {
            var bfs = new BreadthFirstSearch();
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertex = graph.AddVertex(new BFSVertex());

            bfs.Run(graph, vertex);

            Assert.That(vertex.Value.Distance, Is.EqualTo(0));
            Assert.That(vertex.Value.Processed, Is.True);
        }

        [Test, Category("valid")]
        public void CorrectlyTraversesLinearGraph()
        {
            var bfs = new BreadthFirstSearch();
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertexA = graph.AddVertex(new BFSVertex());
            var vertexB = graph.AddVertex(new BFSVertex());
            var vertexC = graph.AddVertex(new BFSVertex());
            var vertexD = graph.AddVertex(new BFSVertex());

            graph.AddEdge(vertexA, vertexB);
            graph.AddEdge(vertexB, vertexC);
            graph.AddEdge(vertexC, vertexD);

            bfs.Run(graph, vertexA);

            Assert.That(vertexA.Value.Distance, Is.EqualTo(0));
            Assert.That(vertexB.Value.Distance, Is.EqualTo(1));
            Assert.That(vertexC.Value.Distance, Is.EqualTo(2));
            Assert.That(vertexD.Value.Distance, Is.EqualTo(3));

            Assert.That(vertexB.Value.Predecessor, Is.EqualTo(vertexA));
            Assert.That(vertexC.Value.Predecessor, Is.EqualTo(vertexB));
            Assert.That(vertexD.Value.Predecessor, Is.EqualTo(vertexC));
        }

        [Test, Category("valid")]
        public void CorrectlyTraversesBranchingGraph()
        {
            var bfs = new BreadthFirstSearch();
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertexA = graph.AddVertex(new BFSVertex());
            var vertexB = graph.AddVertex(new BFSVertex());
            var vertexC = graph.AddVertex(new BFSVertex());
            var vertexD = graph.AddVertex(new BFSVertex());
            var vertexE = graph.AddVertex(new BFSVertex());

            graph.AddEdge(vertexA, vertexB);
            graph.AddEdge(vertexA, vertexD);
            graph.AddEdge(vertexB, vertexC);
            graph.AddEdge(vertexD, vertexE);

            bfs.Run(graph, vertexA);

            Assert.That(vertexA.Value.Distance, Is.EqualTo(0));
            Assert.That(vertexB.Value.Distance, Is.EqualTo(1));
            Assert.That(vertexC.Value.Distance, Is.EqualTo(2));
            Assert.That(vertexD.Value.Distance, Is.EqualTo(1));
            Assert.That(vertexE.Value.Distance, Is.EqualTo(2));

            Assert.That(vertexB.Value.Predecessor, Is.EqualTo(vertexA));
            Assert.That(vertexC.Value.Predecessor, Is.EqualTo(vertexB));
            Assert.That(vertexD.Value.Predecessor, Is.EqualTo(vertexA));
            Assert.That(vertexE.Value.Predecessor, Is.EqualTo(vertexD));
        }

        [Test, Category("valid")]
        public void CorrectlyHandlesCyclicGraph()
        {
            var bfs = new BreadthFirstSearch();
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertexA = graph.AddVertex(new BFSVertex());
            var vertexB = graph.AddVertex(new BFSVertex());
            var vertexC = graph.AddVertex(new BFSVertex());

            graph.AddEdge(vertexA, vertexB);
            graph.AddEdge(vertexB, vertexC);
            graph.AddEdge(vertexC, vertexA);

            bfs.Run(graph, vertexA);

            Assert.That(vertexA.Value.Distance, Is.EqualTo(0));
            Assert.That(vertexB.Value.Distance, Is.EqualTo(1));
            Assert.That(vertexC.Value.Distance, Is.EqualTo(1));

            Assert.That(vertexA.Value.Processed, Is.True);
            Assert.That(vertexB.Value.Processed, Is.True);
            Assert.That(vertexC.Value.Processed, Is.True);
        }

        [Test, Category("valid")]
        public void ProcessesOnlyReachableVerticesInDisconnectedGraph()
        {
            var bfs = new BreadthFirstSearch();
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertexA = graph.AddVertex(new BFSVertex());
            var vertexB = graph.AddVertex(new BFSVertex());
            var vertexC = graph.AddVertex(new BFSVertex());
            var vertexD = graph.AddVertex(new BFSVertex());

            graph.AddEdge(vertexA, vertexB);
            graph.AddEdge(vertexC, vertexD);

            bfs.Run(graph, vertexA);

            Assert.That(vertexA.Value.Distance, Is.EqualTo(0));
            Assert.That(vertexB.Value.Distance, Is.EqualTo(1));
            Assert.That(vertexC.Value.Distance, Is.EqualTo(int.MaxValue));
            Assert.That(vertexD.Value.Distance, Is.EqualTo(int.MaxValue));

            Assert.That(vertexA.Value.Processed, Is.True);
            Assert.That(vertexB.Value.Processed, Is.True);
            Assert.That(vertexC.Value.Processed, Is.False);
            Assert.That(vertexD.Value.Processed, Is.False);
        }

        [Test, Category("valid")]
        public void CompletesLargeGraphTraversalInReasonableTime()
        {
            var bfs = new BreadthFirstSearch();
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertices = Enumerable.Range(0, 10000).Select(_ => graph.AddVertex(new BFSVertex())).ToList();

            for (int i = 0; i < vertices.Count - 1; i++)
            {
                graph.AddEdge(vertices[i], vertices[i + 1]);
            }

            var startTime = DateTime.Now;
            bfs.Run(graph, vertices[0]);
            var endTime = DateTime.Now;

            var executionTime = (endTime - startTime).TotalSeconds;
            Assert.That(executionTime, Is.LessThan(5), "BFS took too long to complete");

            for (int i = 0; i < vertices.Count; i++)
            {
                Assert.That(vertices[i].Value.Distance, Is.EqualTo(i));
                Assert.That(vertices[i].Value.Processed, Is.True);
            }
        }
    }
}
