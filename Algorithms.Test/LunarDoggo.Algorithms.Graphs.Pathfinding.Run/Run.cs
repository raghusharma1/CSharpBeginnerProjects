// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleCSharpEnv using AI Type  and AI Model 

ROOST_METHOD_HASH=Run_bbc3b7dcfd
ROOST_METHOD_SIG_HASH=Run_23f9485d25

   ########## Test-Scenarios ##########  

Based on the provided method and context, here are several NUnit test scenarios for the `Run` method of the `BreadthFirstSearch` class:

Scenario 1: Null Graph Throws ArgumentNullException

Details:
  TestName: NullGraphThrowsArgumentNullException
  Description: Verify that passing a null graph to the Run method throws an ArgumentNullException.
Execution:
  Arrange: Create a BreadthFirstSearch instance and a null graph.
  Act: Call the Run method with the null graph and a valid start vertex.
  Assert: Verify that an ArgumentNullException is thrown.
Validation:
  This test ensures that the method properly handles null input for the graph parameter, maintaining robustness and preventing null reference exceptions later in the execution.

Scenario 2: Single Vertex Graph

Details:
  TestName: SingleVertexGraphProcessesCorrectly
  Description: Ensure that a graph with a single vertex is processed correctly.
Execution:
  Arrange: Create a graph with a single vertex and instantiate BreadthFirstSearch.
  Act: Run the BFS algorithm on this graph.
  Assert: Check that the vertex is marked as processed and has a distance of 0.
Validation:
  This test verifies that the algorithm works correctly for the simplest possible graph, serving as a baseline for more complex scenarios.

Scenario 3: Linear Graph Processing

Details:
  TestName: LinearGraphProcessesInOrder
  Description: Test that a linear graph (vertices in a line) is processed in the correct order.
Execution:
  Arrange: Create a linear graph with multiple vertices and instantiate BreadthFirstSearch.
  Act: Run the BFS algorithm starting from one end of the linear graph.
  Assert: Verify that each vertex's distance increases by 1 as we move along the graph, and predecessors are set correctly.
Validation:
  This scenario ensures that the BFS algorithm correctly traverses a simple linear structure, assigning distances and predecessors as expected.

Scenario 4: Cyclic Graph Handling

Details:
  TestName: CyclicGraphProcessedWithoutInfiniteLoop
  Description: Ensure that a graph with cycles is processed correctly without getting stuck in an infinite loop.
Execution:
  Arrange: Create a graph with a cycle and instantiate BreadthFirstSearch.
  Act: Run the BFS algorithm on this cyclic graph.
  Assert: Check that all vertices are processed, have correct distances, and the algorithm terminates.
Validation:
  This test verifies that the algorithm can handle cycles in the graph without issues, which is crucial for its robustness and applicability to various graph structures.

Scenario 5: Disconnected Graph Components

Details:
  TestName: DisconnectedGraphComponentsHandledCorrectly
  Description: Test that the algorithm correctly processes a graph with disconnected components.
Execution:
  Arrange: Create a graph with multiple disconnected components and instantiate BreadthFirstSearch.
  Act: Run the BFS algorithm starting from a vertex in one component.
  Assert: Verify that vertices in the start component are processed and have distances set, while vertices in other components remain unprocessed with maximum distance.
Validation:
  This scenario ensures that the BFS algorithm behaves correctly when faced with a graph that isn't fully connected, which is important for real-world applications where graphs may not always be fully connected.

Scenario 6: Large Graph Performance

Details:
  TestName: LargeGraphProcessedEfficiently
  Description: Ensure that the algorithm can handle a large graph within a reasonable time frame.
Execution:
  Arrange: Create a large graph with many vertices and edges, and instantiate BreadthFirstSearch.
  Act: Run the BFS algorithm on this large graph, measuring the execution time.
  Assert: Verify that all vertices are processed correctly and the execution time is within an acceptable range.
Validation:
  This test checks the algorithm's performance and scalability, which is crucial for its practical application to large datasets.

Scenario 7: Graph With Self-Loops

Details:
  TestName: GraphWithSelfLoopsHandledCorrectly
  Description: Test that the algorithm correctly handles graphs containing self-loops (edges from a vertex to itself).
Execution:
  Arrange: Create a graph with self-loops and instantiate BreadthFirstSearch.
  Act: Run the BFS algorithm on this graph.
  Assert: Verify that all vertices are processed correctly, ignoring the self-loops in distance calculations.
Validation:
  This scenario ensures that the presence of self-loops doesn't interfere with the correct operation of the BFS algorithm, which is important for graphs that may contain such structures.

These test scenarios cover various aspects of the BreadthFirstSearch algorithm, including edge cases, error handling, and performance considerations. They should provide a comprehensive suite for validating the correctness and robustness of the implementation.


*/

// ********RoostGPT********
using NUnit.Framework;
using LunarDoggo.Datastructures.Graphs;
using LunarDoggo.Algorithms.Graphs.Pathfinding;
using System;
using System.Linq;

namespace LunarDoggo.Algorithms.Graphs.Pathfinding.Test
{
    [TestFixture]
    public class RunTest
    {
        [Test, Category("invalid")]
        public void NullGraphThrowsArgumentNullException()
        {
            var bfs = new BreadthFirstSearch();
            var startVertex = new Vertex<BFSVertex>(0, new BFSVertex());

            Assert.Throws<ArgumentNullException>(() => bfs.Run(null, startVertex));
        }

        [Test, Category("valid")]
        public void SingleVertexGraphProcessesCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertex = graph.AddVertex(new BFSVertex());
            var bfs = new BreadthFirstSearch();

            bfs.Run(graph, vertex);

            Assert.IsTrue(vertex.Value.Processed);
            Assert.AreEqual(0, vertex.Value.Distance);
        }

        [Test, Category("valid")]
        public void LinearGraphProcessesInOrder()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);

            var bfs = new BreadthFirstSearch();
            bfs.Run(graph, v1);

            Assert.AreEqual(0, v1.Value.Distance);
            Assert.AreEqual(1, v2.Value.Distance);
            Assert.AreEqual(2, v3.Value.Distance);
            Assert.AreEqual(v1, v2.Value.Predecessor);
            Assert.AreEqual(v2, v3.Value.Predecessor);
        }

        [Test, Category("valid")]
        public void CyclicGraphProcessedWithoutInfiniteLoop()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);
            graph.AddEdge(v3, v1);

            var bfs = new BreadthFirstSearch();
            bfs.Run(graph, v1);

            Assert.IsTrue(v1.Value.Processed);
            Assert.IsTrue(v2.Value.Processed);
            Assert.IsTrue(v3.Value.Processed);
            Assert.AreEqual(0, v1.Value.Distance);
            Assert.AreEqual(1, v2.Value.Distance);
            Assert.AreEqual(1, v3.Value.Distance);
        }

        [Test, Category("valid")]
        public void DisconnectedGraphComponentsHandledCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            var v4 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v3, v4);

            var bfs = new BreadthFirstSearch();
            bfs.Run(graph, v1);

            Assert.IsTrue(v1.Value.Processed);
            Assert.IsTrue(v2.Value.Processed);
            Assert.IsFalse(v3.Value.Processed);
            Assert.IsFalse(v4.Value.Processed);
            Assert.AreEqual(0, v1.Value.Distance);
            Assert.AreEqual(1, v2.Value.Distance);
            Assert.AreEqual(int.MaxValue, v3.Value.Distance);
            Assert.AreEqual(int.MaxValue, v4.Value.Distance);
        }

        [Test, Category("valid")]
        public void LargeGraphProcessedEfficiently()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertices = Enumerable.Range(0, 10000).Select(_ => graph.AddVertex(new BFSVertex())).ToList();
            
            for (int i = 0; i < vertices.Count - 1; i++)
            {
                graph.AddEdge(vertices[i], vertices[i + 1]);
            }

            var bfs = new BreadthFirstSearch();
            var startTime = DateTime.Now;
            bfs.Run(graph, vertices[0]);
            var endTime = DateTime.Now;

            Assert.IsTrue((endTime - startTime).TotalSeconds < 5); // Adjust the time limit as needed
            Assert.IsTrue(vertices.All(v => v.Value.Processed));
            Assert.AreEqual(vertices.Count - 1, vertices.Last().Value.Distance);
        }

        [Test, Category("valid")]
        public void GraphWithSelfLoopsHandledCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v1); // Self-loop
            graph.AddEdge(v1, v2);

            var bfs = new BreadthFirstSearch();
            bfs.Run(graph, v1);

            Assert.IsTrue(v1.Value.Processed);
            Assert.IsTrue(v2.Value.Processed);
            Assert.AreEqual(0, v1.Value.Distance);
            Assert.AreEqual(1, v2.Value.Distance);
            Assert.AreEqual(v1, v2.Value.Predecessor);
        }
    }
}
