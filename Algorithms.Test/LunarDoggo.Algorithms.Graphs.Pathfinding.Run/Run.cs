// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleCSharpEnv using AI Type  and AI Model 

ROOST_METHOD_HASH=Run_bbc3b7dcfd
ROOST_METHOD_SIG_HASH=Run_23f9485d25

   ########## Test-Scenarios ##########  

Based on the provided method and context, here are several test scenarios for the `Run` method of the `BreadthFirstSearch` class:

Scenario 1: Null Graph Input

Details:
  TestName: ThrowsArgumentNullExceptionWhenGraphIsNull
  Description: Verify that the method throws an ArgumentNullException when a null graph is provided.
Execution:
  Arrange: Create a BreadthFirstSearch instance and set up a null graph and a valid start vertex.
  Act: Call the Run method with the null graph and valid start vertex.
  Assert: Verify that an ArgumentNullException is thrown with the correct message.
Validation:
  This test ensures that the method properly handles null input for the graph parameter, which is a crucial input validation step.

Scenario 2: Valid Graph with Single Vertex

Details:
  TestName: ProcessesSingleVertexGraphCorrectly
  Description: Ensure the method correctly processes a graph with only one vertex (the start vertex).
Execution:
  Arrange: Create a BreadthFirstSearch instance, a graph with a single vertex, and set this vertex as the start vertex.
  Act: Call the Run method with the graph and start vertex.
  Assert: Verify that the start vertex has been processed (Processed = true, Distance = 0, Predecessor = null).
Validation:
  This test checks if the method correctly initializes and processes the simplest possible graph, which is an important edge case.

Scenario 3: Graph with Multiple Vertices

Details:
  TestName: ProcessesMultiVertexGraphCorrectly
  Description: Verify that the method correctly processes a graph with multiple vertices and edges.
Execution:
  Arrange: Create a BreadthFirstSearch instance, a graph with multiple vertices and edges, and choose a start vertex.
  Act: Call the Run method with the graph and start vertex.
  Assert: Check that all vertices have been processed, have correct distances, and have appropriate predecessors.
Validation:
  This test ensures that the BFS algorithm correctly traverses a more complex graph structure, which is its primary function.

Scenario 4: Disconnected Graph

Details:
  TestName: HandlesDisconnectedGraphCorrectly
  Description: Ensure the method correctly processes a graph with disconnected components.
Execution:
  Arrange: Create a BreadthFirstSearch instance, a graph with multiple disconnected components, and choose a start vertex in one component.
  Act: Call the Run method with the graph and start vertex.
  Assert: Verify that vertices in the same component as the start vertex are processed, while vertices in other components remain unprocessed.
Validation:
  This test checks if the method correctly handles graphs that are not fully connected, which is an important edge case in graph algorithms.

Scenario 5: Cyclic Graph

Details:
  TestName: ProcessesCyclicGraphWithoutInfiniteLoop
  Description: Verify that the method correctly processes a graph containing cycles without entering an infinite loop.
Execution:
  Arrange: Create a BreadthFirstSearch instance, a graph with cycles, and choose a start vertex.
  Act: Call the Run method with the graph and start vertex.
  Assert: Check that all vertices have been processed exactly once and have correct distances and predecessors.
Validation:
  This test ensures that the BFS algorithm can handle graphs with cycles, which is crucial for its correctness and termination.

Scenario 6: Large Graph Performance

Details:
  TestName: CompletesLargeGraphTraversalInReasonableTime
  Description: Ensure the method can process a large graph within an acceptable time frame.
Execution:
  Arrange: Create a BreadthFirstSearch instance, generate a large graph with many vertices and edges, and choose a start vertex.
  Act: Measure the time taken to call and complete the Run method with the large graph and start vertex.
  Assert: Verify that the method completes within a predefined time limit and that all vertices are processed correctly.
Validation:
  This test checks the performance characteristics of the BFS implementation, which is important for its practical usability on larger datasets.

These test scenarios cover various aspects of the BreadthFirstSearch.Run method, including input validation, correct processing of different graph structures, handling of edge cases, and performance considerations.


*/

// ********RoostGPT********
using NUnit.Framework;
using LunarDoggo.Datastructures.Graphs;
using LunarDoggo.Algorithms.Graphs.Pathfinding;
using System;
using System.Collections.Generic;
using System.Linq;

namespace LunarDoggo.Algorithms.Graphs.Pathfinding.Test
{
    [TestFixture]
    public class RunTest
    {
        private BreadthFirstSearch bfs;

        [SetUp]
        public void Setup()
        {
            bfs = new BreadthFirstSearch();
        }

        [Test, Category("invalid")]
        public void ThrowsArgumentNullExceptionWhenGraphIsNull()
        {
            // Arrange
            IGraph<BFSVertex> graph = null;
            Vertex<BFSVertex> start = new Vertex<BFSVertex>(0, new BFSVertex());

            // Act & Assert
            Assert.Throws<ArgumentNullException>(() => bfs.Run(graph, start));
        }

        [Test, Category("valid")]
        public void ProcessesSingleVertexGraphCorrectly()
        {
            // Arrange
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertex = graph.AddVertex(new BFSVertex());

            // Act
            bfs.Run(graph, vertex);

            // Assert
            Assert.IsTrue(vertex.Value.Processed);
            Assert.AreEqual(0, vertex.Value.Distance);
            Assert.IsNull(vertex.Value.Predecessor);
        }

        [Test, Category("valid")]
        public void ProcessesMultiVertexGraphCorrectly()
        {
            // Arrange
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);

            // Act
            bfs.Run(graph, v1);

            // Assert
            Assert.IsTrue(v1.Value.Processed);
            Assert.IsTrue(v2.Value.Processed);
            Assert.IsTrue(v3.Value.Processed);
            Assert.AreEqual(0, v1.Value.Distance);
            Assert.AreEqual(1, v2.Value.Distance);
            Assert.AreEqual(2, v3.Value.Distance);
            Assert.IsNull(v1.Value.Predecessor);
            Assert.AreEqual(v1, v2.Value.Predecessor);
            Assert.AreEqual(v2, v3.Value.Predecessor);
        }

        [Test, Category("valid")]
        public void HandlesDisconnectedGraphCorrectly()
        {
            // Arrange
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);

            // Act
            bfs.Run(graph, v1);

            // Assert
            Assert.IsTrue(v1.Value.Processed);
            Assert.IsTrue(v2.Value.Processed);
            Assert.IsFalse(v3.Value.Processed);
            Assert.AreEqual(0, v1.Value.Distance);
            Assert.AreEqual(1, v2.Value.Distance);
            Assert.AreEqual(int.MaxValue, v3.Value.Distance);
        }

        [Test, Category("valid")]
        public void ProcessesCyclicGraphWithoutInfiniteLoop()
        {
            // Arrange
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);
            graph.AddEdge(v3, v1);

            // Act
            bfs.Run(graph, v1);

            // Assert
            Assert.IsTrue(v1.Value.Processed);
            Assert.IsTrue(v2.Value.Processed);
            Assert.IsTrue(v3.Value.Processed);
            Assert.AreEqual(0, v1.Value.Distance);
            Assert.AreEqual(1, v2.Value.Distance);
            Assert.AreEqual(1, v3.Value.Distance);
        }

        [Test, Category("valid")]
        public void CompletesLargeGraphTraversalInReasonableTime()
        {
            // Arrange
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertices = new List<Vertex<BFSVertex>>();
            for (int i = 0; i < 10000; i++)
            {
                vertices.Add(graph.AddVertex(new BFSVertex()));
            }
            for (int i = 0; i < 9999; i++)
            {
                graph.AddEdge(vertices[i], vertices[i + 1]);
            }

            // Act
            var startTime = DateTime.Now;
            bfs.Run(graph, vertices[0]);
            var endTime = DateTime.Now;

            // Assert
            Assert.Less((endTime - startTime).TotalSeconds, 5); // Assuming 5 seconds is reasonable
            Assert.IsTrue(vertices.All(v => v.Value.Processed));
        }
    }
}
