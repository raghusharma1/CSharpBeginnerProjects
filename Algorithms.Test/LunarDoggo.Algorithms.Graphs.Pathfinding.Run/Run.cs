// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleCSharpEnv using AI Type  and AI Model 

ROOST_METHOD_HASH=Run_bbc3b7dcfd
ROOST_METHOD_SIG_HASH=Run_23f9485d25

   ########## Test-Scenarios ##########  

Based on the provided method and related code, here are several test scenarios for the `Run` method of the `BreadthFirstSearch` class:

Scenario 1: Null Graph Handling

Details:
  TestName: ThrowsArgumentNullExceptionForNullGraph
  Description: Verify that the method throws an ArgumentNullException when a null graph is passed.

Execution:
  Arrange: Create a BreadthFirstSearch instance and a null graph.
  Act: Call the Run method with the null graph and a valid start vertex.
  Assert: Verify that an ArgumentNullException is thrown.

Validation:
  This test ensures that the method properly handles null input for the graph parameter, maintaining robustness and preventing null reference exceptions later in the execution.

Scenario 2: Single Vertex Graph

Details:
  TestName: ProcessesSingleVertexGraphCorrectly
  Description: Ensure the method correctly processes a graph with only one vertex.

Execution:
  Arrange: Create a graph with a single vertex and instantiate BreadthFirstSearch.
  Act: Run the BFS algorithm on this graph.
  Assert: Check that the vertex is processed, its distance is 0, and it has no predecessor.

Validation:
  This test verifies the base case of the BFS algorithm, ensuring it works correctly for the simplest possible graph structure.

Scenario 3: Linear Graph Traversal

Details:
  TestName: TraversesLinearGraphCorrectly
  Description: Verify correct traversal and distance calculation in a linear graph (A -> B -> C -> D).

Execution:
  Arrange: Create a linear graph with 4 vertices and set up BreadthFirstSearch.
  Act: Run BFS starting from vertex A.
  Assert: Check that all vertices are processed, distances are correct (0, 1, 2, 3), and predecessors are set properly.

Validation:
  This scenario tests the algorithm's ability to traverse a simple path, ensuring correct distance calculation and predecessor assignment.

Scenario 4: Cyclic Graph Handling

Details:
  TestName: HandlesCyclicGraphCorrectly
  Description: Ensure the algorithm correctly processes a graph with cycles without getting stuck in an infinite loop.

Execution:
  Arrange: Create a cyclic graph (e.g., A -> B -> C -> A) and set up BreadthFirstSearch.
  Act: Run BFS starting from any vertex.
  Assert: Verify all vertices are processed once, distances are correct, and the cycle doesn't cause issues.

Validation:
  This test checks the algorithm's ability to handle cycles in the graph, which is crucial for its correctness and termination.

Scenario 5: Disconnected Graph Components

Details:
  TestName: ProcessesDisconnectedGraphComponents
  Description: Verify that the algorithm correctly processes a graph with disconnected components.

Execution:
  Arrange: Create a graph with two disconnected components and set up BreadthFirstSearch.
  Act: Run BFS starting from a vertex in one component.
  Assert: Check that vertices in the starting component are processed and have correct distances, while vertices in the other component remain unprocessed.

Validation:
  This scenario ensures that the BFS algorithm correctly handles graphs that are not fully connected, which is important for its applicability to various graph structures.

Scenario 6: Large Graph Performance

Details:
  TestName: PerformsEfficientlyOnLargeGraph
  Description: Test the performance of the algorithm on a large graph to ensure it completes within a reasonable time.

Execution:
  Arrange: Create a large graph (e.g., 10000 vertices) with a mix of connections.
  Act: Run BFS and measure the execution time.
  Assert: Verify that the algorithm completes within an acceptable time frame and processes all vertices.

Validation:
  This test ensures that the implementation is efficient and can handle large-scale graphs without performance issues.

Scenario 7: Correct Initialization of Vertices

Details:
  TestName: InitializesVerticesCorrectly
  Description: Verify that all vertices are correctly initialized before the BFS traversal begins.

Execution:
  Arrange: Create a graph with multiple vertices and set up BreadthFirstSearch.
  Act: Run the BFS algorithm.
  Assert: Check that before processing, all vertices (except the start vertex) have Distance set to Int32.MaxValue, Predecessor set to null, and Processed set to false.

Validation:
  This test ensures that the initialization step of the algorithm is working correctly, which is crucial for the proper execution of the BFS.

These scenarios cover various aspects of the BreadthFirstSearch algorithm, including edge cases, error handling, and different graph structures. They aim to thoroughly test the functionality and robustness of the implementation.


*/

// ********RoostGPT********
using NUnit.Framework;
using LunarDoggo.Datastructures.Graphs;
using LunarDoggo.Algorithms.Graphs.Pathfinding;
using System;
using System.Linq;

namespace LunarDoggo.Algorithms.Graphs.Pathfinding.Test
{
    [TestFixture]
    public class RunTest
    {
        [Test, Category("invalid")]
        public void ThrowsArgumentNullExceptionForNullGraph()
        {
            var bfs = new BreadthFirstSearch();
            var startVertex = new Vertex<BFSVertex>(0, new BFSVertex());

            Assert.Throws<ArgumentNullException>(() => bfs.Run(null, startVertex));
        }

        [Test, Category("valid")]
        public void ProcessesSingleVertexGraphCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertex = graph.AddVertex(new BFSVertex());
            var bfs = new BreadthFirstSearch();

            bfs.Run(graph, vertex);

            Assert.That(vertex.Value.Processed, Is.True);
            Assert.That(vertex.Value.Distance, Is.EqualTo(0));
            Assert.That(vertex.Value.Predecessor, Is.Null);
        }

        [Test, Category("valid")]
        public void TraversesLinearGraphCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertexA = graph.AddVertex(new BFSVertex());
            var vertexB = graph.AddVertex(new BFSVertex());
            var vertexC = graph.AddVertex(new BFSVertex());
            var vertexD = graph.AddVertex(new BFSVertex());

            graph.AddEdge(vertexA, vertexB);
            graph.AddEdge(vertexB, vertexC);
            graph.AddEdge(vertexC, vertexD);

            var bfs = new BreadthFirstSearch();
            bfs.Run(graph, vertexA);

            Assert.That(vertexA.Value.Distance, Is.EqualTo(0));
            Assert.That(vertexB.Value.Distance, Is.EqualTo(1));
            Assert.That(vertexC.Value.Distance, Is.EqualTo(2));
            Assert.That(vertexD.Value.Distance, Is.EqualTo(3));

            Assert.That(vertexA.Value.Predecessor, Is.Null);
            Assert.That(vertexB.Value.Predecessor, Is.EqualTo(vertexA));
            Assert.That(vertexC.Value.Predecessor, Is.EqualTo(vertexB));
            Assert.That(vertexD.Value.Predecessor, Is.EqualTo(vertexC));
        }

        [Test, Category("valid")]
        public void HandlesCyclicGraphCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertexA = graph.AddVertex(new BFSVertex());
            var vertexB = graph.AddVertex(new BFSVertex());
            var vertexC = graph.AddVertex(new BFSVertex());

            graph.AddEdge(vertexA, vertexB);
            graph.AddEdge(vertexB, vertexC);
            graph.AddEdge(vertexC, vertexA);

            var bfs = new BreadthFirstSearch();
            bfs.Run(graph, vertexA);

            Assert.That(vertexA.Value.Distance, Is.EqualTo(0));
            Assert.That(vertexB.Value.Distance, Is.EqualTo(1));
            Assert.That(vertexC.Value.Distance, Is.EqualTo(1));

            Assert.That(vertexA.Value.Predecessor, Is.Null);
            Assert.That(vertexB.Value.Predecessor, Is.EqualTo(vertexA));
            Assert.That(vertexC.Value.Predecessor, Is.EqualTo(vertexA));
        }

        [Test, Category("valid")]
        public void ProcessesDisconnectedGraphComponents()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertexA = graph.AddVertex(new BFSVertex());
            var vertexB = graph.AddVertex(new BFSVertex());
            var vertexC = graph.AddVertex(new BFSVertex());
            var vertexD = graph.AddVertex(new BFSVertex());

            graph.AddEdge(vertexA, vertexB);
            graph.AddEdge(vertexC, vertexD);

            var bfs = new BreadthFirstSearch();
            bfs.Run(graph, vertexA);

            Assert.That(vertexA.Value.Processed, Is.True);
            Assert.That(vertexB.Value.Processed, Is.True);
            Assert.That(vertexC.Value.Processed, Is.False);
            Assert.That(vertexD.Value.Processed, Is.False);

            Assert.That(vertexA.Value.Distance, Is.EqualTo(0));
            Assert.That(vertexB.Value.Distance, Is.EqualTo(1));
            Assert.That(vertexC.Value.Distance, Is.EqualTo(int.MaxValue));
            Assert.That(vertexD.Value.Distance, Is.EqualTo(int.MaxValue));
        }

        [Test, Category("valid")]
        public void PerformsEfficientlyOnLargeGraph()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertices = Enumerable.Range(0, 10000).Select(_ => graph.AddVertex(new BFSVertex())).ToList();

            // Connect vertices in a way that creates a large, connected graph
            for (int i = 0; i < vertices.Count - 1; i++)
            {
                graph.AddEdge(vertices[i], vertices[i + 1]);
                if (i % 100 == 0 && i + 100 < vertices.Count)
                {
                    graph.AddEdge(vertices[i], vertices[i + 100]);
                }
            }

            var bfs = new BreadthFirstSearch();
            var startTime = DateTime.Now;
            bfs.Run(graph, vertices[0]);
            var endTime = DateTime.Now;

            var executionTime = (endTime - startTime).TotalSeconds;
            Assert.That(executionTime, Is.LessThan(5), "BFS took too long to complete");

            Assert.That(vertices.All(v => v.Value.Processed), Is.True, "Not all vertices were processed");
        }

        [Test, Category("valid")]
        public void InitializesVerticesCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertexA = graph.AddVertex(new BFSVertex());
            var vertexB = graph.AddVertex(new BFSVertex());
            var vertexC = graph.AddVertex(new BFSVertex());

            graph.AddEdge(vertexA, vertexB);
            graph.AddEdge(vertexB, vertexC);

            var bfs = new BreadthFirstSearch();
            bfs.Run(graph, vertexA);

            Assert.That(vertexA.Value.Distance, Is.EqualTo(0));
            Assert.That(vertexA.Value.Predecessor, Is.Null);
            Assert.That(vertexA.Value.Processed, Is.True);

            Assert.That(vertexB.Value.Distance, Is.EqualTo(1));
            Assert.That(vertexB.Value.Predecessor, Is.EqualTo(vertexA));
            Assert.That(vertexB.Value.Processed, Is.True);

            Assert.That(vertexC.Value.Distance, Is.EqualTo(2));
            Assert.That(vertexC.Value.Predecessor, Is.EqualTo(vertexB));
            Assert.That(vertexC.Value.Processed, Is.True);
        }
    }
}
