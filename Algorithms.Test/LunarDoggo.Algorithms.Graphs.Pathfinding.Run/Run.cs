// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleCSharpEnv using AI Type  and AI Model 

ROOST_METHOD_HASH=Run_bbc3b7dcfd
ROOST_METHOD_SIG_HASH=Run_23f9485d25

   ########## Test-Scenarios ##########  

Based on the provided method and related code, here are several test scenarios for the `Run` method of the `BreadthFirstSearch` class:

Scenario 1: Valid Graph and Start Vertex

Details:
  TestName: RunWithValidGraphAndStartVertex
  Description: Test the BFS algorithm with a valid graph and start vertex to ensure correct traversal and distance calculation.

Execution:
  Arrange: Create a valid graph with multiple vertices and edges, and select a start vertex.
  Act: Call the Run method with the created graph and start vertex.
  Assert: Check if all vertices are processed, distances are correctly calculated, and predecessors are properly set.

Validation:
  This test verifies that the BFS algorithm correctly traverses the graph, assigns proper distances from the start vertex, and sets the correct predecessors for each vertex. It ensures the core functionality of the BFS algorithm is working as expected.

Scenario 2: Null Graph Input

Details:
  TestName: RunWithNullGraphThrowsArgumentNullException
  Description: Test that the method throws an ArgumentNullException when a null graph is provided.

Execution:
  Arrange: Create a null graph and a valid start vertex.
  Act: Call the Run method with the null graph and valid start vertex.
  Assert: Verify that an ArgumentNullException is thrown with the correct error message.

Validation:
  This test ensures that the method properly handles invalid input by throwing the correct exception when a null graph is provided, maintaining the robustness of the algorithm.

Scenario 3: Empty Graph

Details:
  TestName: RunWithEmptyGraph
  Description: Test the behavior of the BFS algorithm when given an empty graph.

Execution:
  Arrange: Create an empty graph (no vertices or edges) and a start vertex.
  Act: Call the Run method with the empty graph and start vertex.
  Assert: Verify that no exceptions are thrown and the method completes without error.

Validation:
  This test checks that the algorithm gracefully handles edge cases such as an empty graph without crashing or throwing unexpected exceptions.

Scenario 4: Graph with Single Vertex

Details:
  TestName: RunWithSingleVertexGraph
  Description: Test the BFS algorithm on a graph containing only one vertex (the start vertex).

Execution:
  Arrange: Create a graph with a single vertex and set it as the start vertex.
  Act: Call the Run method with this graph and the single vertex.
  Assert: Verify that the vertex is processed, its distance is 0, and it has no predecessor.

Validation:
  This test ensures that the algorithm correctly handles the simplest possible graph scenario, properly initializing and processing a single-vertex graph.

Scenario 5: Disconnected Graph

Details:
  TestName: RunWithDisconnectedGraph
  Description: Test the BFS algorithm on a graph with multiple disconnected components.

Execution:
  Arrange: Create a graph with multiple disconnected subgraphs and choose a start vertex from one of the subgraphs.
  Act: Call the Run method with this disconnected graph and the chosen start vertex.
  Assert: Verify that only vertices in the same component as the start vertex are processed and have finite distances, while others remain unprocessed with infinite distances.

Validation:
  This test verifies that the BFS algorithm correctly handles disconnected graphs, processing only the reachable vertices and leaving unreachable vertices untouched.

Scenario 6: Cyclic Graph

Details:
  TestName: RunWithCyclicGraph
  Description: Test the BFS algorithm on a graph containing cycles to ensure it doesn't enter an infinite loop.

Execution:
  Arrange: Create a graph with at least one cycle and choose a start vertex.
  Act: Call the Run method with this cyclic graph and the start vertex.
  Assert: Verify that all vertices are processed exactly once, distances are correct, and the algorithm terminates.

Validation:
  This test ensures that the BFS algorithm correctly handles cycles in the graph without getting stuck in an infinite loop, and still calculates correct distances and predecessors.

Scenario 7: Large Graph Performance

Details:
  TestName: RunWithLargeGraphPerformance
  Description: Test the performance of the BFS algorithm on a large graph to ensure it completes within a reasonable time.

Execution:
  Arrange: Create a large graph with many vertices and edges, and choose a start vertex.
  Act: Measure the time taken to run the BFS algorithm on this large graph.
  Assert: Verify that the algorithm completes within an acceptable time limit and processes all vertices correctly.

Validation:
  This test checks the efficiency and scalability of the BFS implementation, ensuring it can handle large graphs without excessive time complexity.

These test scenarios cover various aspects of the BreadthFirstSearch.Run method, including normal operation, edge cases, error handling, and performance considerations.


*/

// ********RoostGPT********
using NUnit.Framework;
using LunarDoggo.Datastructures.Graphs;
using LunarDoggo.Algorithms.Graphs.Pathfinding;
using System;
using System.Linq;

namespace LunarDoggo.Algorithms.Graphs.Pathfinding.Test
{
    [TestFixture]
    public class RunTest
    {
        private BreadthFirstSearch bfs;

        [SetUp]
        public void Setup()
        {
            bfs = new BreadthFirstSearch();
        }

        [Test, Category("valid")]
        public void RunWithValidGraphAndStartVertex()
        {
            // Arrange
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);

            // Act
            bfs.Run(graph, v1);

            // Assert
            Assert.That(v1.Value.Distance, Is.EqualTo(0));
            Assert.That(v2.Value.Distance, Is.EqualTo(1));
            Assert.That(v3.Value.Distance, Is.EqualTo(2));
            Assert.That(v1.Value.Predecessor, Is.Null);
            Assert.That(v2.Value.Predecessor, Is.EqualTo(v1));
            Assert.That(v3.Value.Predecessor, Is.EqualTo(v2));
        }

        [Test, Category("invalid")]
        public void RunWithNullGraphThrowsArgumentNullException()
        {
            // Arrange
            IGraph<BFSVertex> graph = null;
            var startVertex = new Vertex<BFSVertex>(0, new BFSVertex());

            // Act & Assert
            Assert.Throws<ArgumentNullException>(() => bfs.Run(graph, startVertex));
        }

        [Test, Category("boundary")]
        public void RunWithEmptyGraph()
        {
            // Arrange
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var startVertex = new Vertex<BFSVertex>(0, new BFSVertex());

            // Act & Assert
            Assert.DoesNotThrow(() => bfs.Run(graph, startVertex));
        }

        [Test, Category("boundary")]
        public void RunWithSingleVertexGraph()
        {
            // Arrange
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertex = graph.AddVertex(new BFSVertex());

            // Act
            bfs.Run(graph, vertex);

            // Assert
            Assert.That(vertex.Value.Distance, Is.EqualTo(0));
            Assert.That(vertex.Value.Predecessor, Is.Null);
            Assert.That(vertex.Value.Processed, Is.True);
        }

        [Test, Category("valid")]
        public void RunWithDisconnectedGraph()
        {
            // Arrange
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            var v4 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v3, v4);

            // Act
            bfs.Run(graph, v1);

            // Assert
            Assert.That(v1.Value.Distance, Is.EqualTo(0));
            Assert.That(v2.Value.Distance, Is.EqualTo(1));
            Assert.That(v3.Value.Distance, Is.EqualTo(int.MaxValue));
            Assert.That(v4.Value.Distance, Is.EqualTo(int.MaxValue));
            Assert.That(v1.Value.Processed, Is.True);
            Assert.That(v2.Value.Processed, Is.True);
            Assert.That(v3.Value.Processed, Is.False);
            Assert.That(v4.Value.Processed, Is.False);
        }

        [Test, Category("valid")]
        public void RunWithCyclicGraph()
        {
            // Arrange
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);
            graph.AddEdge(v3, v1);

            // Act
            bfs.Run(graph, v1);

            // Assert
            Assert.That(v1.Value.Distance, Is.EqualTo(0));
            Assert.That(v2.Value.Distance, Is.EqualTo(1));
            Assert.That(v3.Value.Distance, Is.EqualTo(1));
            Assert.That(v1.Value.Processed && v2.Value.Processed && v3.Value.Processed, Is.True);
        }

        [Test, Category("valid")]
        public void RunWithLargeGraphPerformance()
        {
            // Arrange
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertices = Enumerable.Range(0, 10000).Select(_ => graph.AddVertex(new BFSVertex())).ToList();
            for (int i = 0; i < vertices.Count - 1; i++)
            {
                graph.AddEdge(vertices[i], vertices[i + 1]);
            }

            // Act
            var startTime = DateTime.Now;
            bfs.Run(graph, vertices[0]);
            var endTime = DateTime.Now;

            // Assert
            var duration = (endTime - startTime).TotalSeconds;
            Assert.That(duration, Is.LessThan(5), "BFS took too long to complete");
            Assert.That(vertices.All(v => v.Value.Processed), Is.True, "Not all vertices were processed");
        }
    }
}
