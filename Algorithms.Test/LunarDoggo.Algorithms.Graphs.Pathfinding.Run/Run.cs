// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleCSharpEnv using AI Type  and AI Model 

ROOST_METHOD_HASH=Run_bbc3b7dcfd
ROOST_METHOD_SIG_HASH=Run_23f9485d25

   ########## Test-Scenarios ##########  

Based on the provided method and related code, here are several test scenarios for the `Run` method of the `BreadthFirstSearch` class:

Scenario 1: Null Graph Handling

Details:
  TestName: ThrowsArgumentNullExceptionWhenGraphIsNull
  Description: Verify that the method throws an ArgumentNullException when a null graph is provided.
Execution:
  Arrange: Create a BreadthFirstSearch instance and prepare a null graph and a valid start vertex.
  Act: Call the Run method with the null graph and valid start vertex.
  Assert: Expect an ArgumentNullException to be thrown.
Validation:
  This test ensures that the method properly handles null input for the graph parameter, maintaining robustness and preventing null reference exceptions later in the execution.

Scenario 2: Single Vertex Graph

Details:
  TestName: ProcessesSingleVertexGraphCorrectly
  Description: Ensure the method correctly processes a graph with only one vertex (the start vertex).
Execution:
  Arrange: Create a graph with a single vertex, set it as the start vertex, and initialize a BreadthFirstSearch instance.
  Act: Call the Run method with the graph and start vertex.
  Assert: Verify that the start vertex's distance is 0 and it has no predecessor.
Validation:
  This test confirms that the method correctly initializes and processes the simplest possible graph, setting the base case for more complex scenarios.

Scenario 3: Linear Graph Traversal

Details:
  TestName: TraversesLinearGraphCorrectly
  Description: Verify correct traversal and distance calculation in a linear graph (A -> B -> C -> D).
Execution:
  Arrange: Create a linear graph with 4 vertices, set the first vertex as the start, and initialize a BreadthFirstSearch instance.
  Act: Call the Run method with the graph and start vertex.
  Assert: Check that each vertex has the correct distance (0, 1, 2, 3) and predecessor.
Validation:
  This test ensures that the BFS algorithm correctly traverses a simple linear path, assigning proper distances and predecessors.

Scenario 4: Branching Graph Traversal

Details:
  TestName: TraversesBranchingGraphCorrectly
  Description: Verify correct traversal and distance calculation in a branching graph (A -> B -> C, A -> D -> E).
Execution:
  Arrange: Create a branching graph, set the root as the start vertex, and initialize a BreadthFirstSearch instance.
  Act: Call the Run method with the graph and start vertex.
  Assert: Verify correct distances (A:0, B:1, D:1, C:2, E:2) and predecessors for all vertices.
Validation:
  This test confirms that the BFS algorithm correctly handles branching paths, assigning proper distances and predecessors in a more complex graph structure.

Scenario 5: Cyclic Graph Handling

Details:
  TestName: HandlesCyclicGraphWithoutInfiniteLoop
  Description: Ensure the method correctly processes a graph with cycles without getting stuck in an infinite loop.
Execution:
  Arrange: Create a cyclic graph (e.g., A -> B -> C -> A), set a start vertex, and initialize a BreadthFirstSearch instance.
  Act: Call the Run method with the graph and start vertex.
  Assert: Verify that all vertices are processed, have correct distances, and the method terminates.
Validation:
  This test checks that the BFS algorithm can handle cycles in the graph without revisiting already processed nodes, preventing infinite loops.

Scenario 6: Disconnected Graph Components

Details:
  TestName: ProcessesOnlyReachableVerticesInDisconnectedGraph
  Description: Verify that only vertices reachable from the start vertex are processed in a disconnected graph.
Execution:
  Arrange: Create a graph with two disconnected components, set a start vertex in one component, and initialize a BreadthFirstSearch instance.
  Act: Call the Run method with the graph and start vertex.
  Assert: Check that vertices in the same component as the start are processed (have distances set) while others remain unprocessed.
Validation:
  This test ensures that the BFS algorithm correctly handles disconnected graphs, processing only the reachable vertices from the given start point.

Scenario 7: Large Graph Performance

Details:
  TestName: CompletesLargeGraphTraversalInReasonableTime
  Description: Verify that the method can process a large graph within an acceptable time frame.
Execution:
  Arrange: Generate a large graph (e.g., 10000 vertices), set a start vertex, and initialize a BreadthFirstSearch instance.
  Act: Measure the time taken to call and complete the Run method.
  Assert: Verify that the execution time is within an acceptable range and all vertices are processed.
Validation:
  This test checks the performance and scalability of the BFS implementation, ensuring it can handle large graphs efficiently.

These test scenarios cover various aspects of the BreadthFirstSearch.Run method, including error handling, correct traversal in different graph structures, cycle handling, and performance with large datasets.


*/

// ********RoostGPT********
using NUnit.Framework;
using LunarDoggo.Datastructures.Graphs;
using LunarDoggo.Algorithms.Graphs.Pathfinding;
using System;
using System.Linq;

namespace LunarDoggo.Algorithms.Graphs.Pathfinding.Test
{
    [TestFixture]
    public class RunTest
    {
        [Test, Category("invalid")]
        public void ThrowsArgumentNullExceptionWhenGraphIsNull()
        {
            var bfs = new BreadthFirstSearch();
            var start = new Vertex<BFSVertex>(0, new BFSVertex());

            Assert.Throws<ArgumentNullException>(() => bfs.Run(null, start));
        }

        [Test, Category("valid")]
        public void ProcessesSingleVertexGraphCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var start = graph.AddVertex(new BFSVertex());
            var bfs = new BreadthFirstSearch();

            bfs.Run(graph, start);

            Assert.That(start.Value.Distance, Is.EqualTo(0));
            Assert.That(start.Value.Predecessor, Is.Null);
        }

        [Test, Category("valid")]
        public void TraversesLinearGraphCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var a = graph.AddVertex(new BFSVertex());
            var b = graph.AddVertex(new BFSVertex());
            var c = graph.AddVertex(new BFSVertex());
            var d = graph.AddVertex(new BFSVertex());

            graph.AddEdge(a, b);
            graph.AddEdge(b, c);
            graph.AddEdge(c, d);

            var bfs = new BreadthFirstSearch();
            bfs.Run(graph, a);

            Assert.That(a.Value.Distance, Is.EqualTo(0));
            Assert.That(b.Value.Distance, Is.EqualTo(1));
            Assert.That(c.Value.Distance, Is.EqualTo(2));
            Assert.That(d.Value.Distance, Is.EqualTo(3));

            Assert.That(a.Value.Predecessor, Is.Null);
            Assert.That(b.Value.Predecessor, Is.EqualTo(a));
            Assert.That(c.Value.Predecessor, Is.EqualTo(b));
            Assert.That(d.Value.Predecessor, Is.EqualTo(c));
        }

        [Test, Category("valid")]
        public void TraversesBranchingGraphCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var a = graph.AddVertex(new BFSVertex());
            var b = graph.AddVertex(new BFSVertex());
            var c = graph.AddVertex(new BFSVertex());
            var d = graph.AddVertex(new BFSVertex());
            var e = graph.AddVertex(new BFSVertex());

            graph.AddEdge(a, b);
            graph.AddEdge(b, c);
            graph.AddEdge(a, d);
            graph.AddEdge(d, e);

            var bfs = new BreadthFirstSearch();
            bfs.Run(graph, a);

            Assert.That(a.Value.Distance, Is.EqualTo(0));
            Assert.That(b.Value.Distance, Is.EqualTo(1));
            Assert.That(c.Value.Distance, Is.EqualTo(2));
            Assert.That(d.Value.Distance, Is.EqualTo(1));
            Assert.That(e.Value.Distance, Is.EqualTo(2));

            Assert.That(a.Value.Predecessor, Is.Null);
            Assert.That(b.Value.Predecessor, Is.EqualTo(a));
            Assert.That(c.Value.Predecessor, Is.EqualTo(b));
            Assert.That(d.Value.Predecessor, Is.EqualTo(a));
            Assert.That(e.Value.Predecessor, Is.EqualTo(d));
        }

        [Test, Category("valid")]
        public void HandlesCyclicGraphWithoutInfiniteLoop()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var a = graph.AddVertex(new BFSVertex());
            var b = graph.AddVertex(new BFSVertex());
            var c = graph.AddVertex(new BFSVertex());

            graph.AddEdge(a, b);
            graph.AddEdge(b, c);
            graph.AddEdge(c, a);

            var bfs = new BreadthFirstSearch();
            bfs.Run(graph, a);

            Assert.That(a.Value.Distance, Is.EqualTo(0));
            Assert.That(b.Value.Distance, Is.EqualTo(1));
            Assert.That(c.Value.Distance, Is.EqualTo(1));

            Assert.That(a.Value.Predecessor, Is.Null);
            Assert.That(b.Value.Predecessor, Is.EqualTo(a));
            Assert.That(c.Value.Predecessor, Is.EqualTo(a));
        }

        [Test, Category("valid")]
        public void ProcessesOnlyReachableVerticesInDisconnectedGraph()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var a = graph.AddVertex(new BFSVertex());
            var b = graph.AddVertex(new BFSVertex());
            var c = graph.AddVertex(new BFSVertex());
            var d = graph.AddVertex(new BFSVertex());
            var e = graph.AddVertex(new BFSVertex());

            graph.AddEdge(a, b);
            graph.AddEdge(b, c);
            graph.AddEdge(d, e);

            var bfs = new BreadthFirstSearch();
            bfs.Run(graph, a);

            Assert.That(a.Value.Distance, Is.EqualTo(0));
            Assert.That(b.Value.Distance, Is.EqualTo(1));
            Assert.That(c.Value.Distance, Is.EqualTo(2));
            Assert.That(d.Value.Distance, Is.EqualTo(int.MaxValue));
            Assert.That(e.Value.Distance, Is.EqualTo(int.MaxValue));

            Assert.That(a.Value.Predecessor, Is.Null);
            Assert.That(b.Value.Predecessor, Is.EqualTo(a));
            Assert.That(c.Value.Predecessor, Is.EqualTo(b));
            Assert.That(d.Value.Predecessor, Is.Null);
            Assert.That(e.Value.Predecessor, Is.Null);
        }

        [Test, Category("valid")]
        public void CompletesLargeGraphTraversalInReasonableTime()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertices = Enumerable.Range(0, 10000).Select(_ => graph.AddVertex(new BFSVertex())).ToList();

            for (int i = 0; i < vertices.Count - 1; i++)
            {
                graph.AddEdge(vertices[i], vertices[i + 1]);
            }

            var bfs = new BreadthFirstSearch();
            var start = vertices[0];

            var startTime = DateTime.Now;
            bfs.Run(graph, start);
            var endTime = DateTime.Now;

            var executionTime = (endTime - startTime).TotalSeconds;
            Assert.That(executionTime, Is.LessThan(5)); // Adjust the time limit as needed

            for (int i = 0; i < vertices.Count; i++)
            {
                Assert.That(vertices[i].Value.Distance, Is.EqualTo(i));
                if (i > 0)
                {
                    Assert.That(vertices[i].Value.Predecessor, Is.EqualTo(vertices[i - 1]));
                }
            }
        }
    }
}
