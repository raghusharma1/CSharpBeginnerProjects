// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleCSharpEnv using AI Type  and AI Model 

ROOST_METHOD_HASH=Run_bbc3b7dcfd
ROOST_METHOD_SIG_HASH=Run_23f9485d25

   ########## Test-Scenarios ##########  

Based on the provided method and related code, here are several test scenarios for the `Run` method of the `BreadthFirstSearch` class:

Scenario 1: Null Graph Handling

Details:
  TestName: ThrowsArgumentNullExceptionWhenGraphIsNull
  Description: Verify that the method throws an ArgumentNullException when a null graph is passed.

Execution:
  Arrange: Create a BreadthFirstSearch instance and a null graph.
  Act: Call the Run method with the null graph and a valid start vertex.
  Assert: Verify that an ArgumentNullException is thrown.

Validation:
  This test ensures that the method properly handles null input for the graph parameter, maintaining robustness and preventing null reference exceptions later in the execution.

Scenario 2: Single Vertex Graph

Details:
  TestName: ProcessesSingleVertexGraphCorrectly
  Description: Ensure the method correctly processes a graph with only one vertex.

Execution:
  Arrange: Create a graph with a single vertex and initialize a BreadthFirstSearch instance.
  Act: Run the BFS algorithm on this graph.
  Assert: Verify that the single vertex is processed (Processed = true) and its Distance is 0.

Validation:
  This test confirms that the BFS algorithm works correctly for the simplest possible graph, setting the base case for more complex scenarios.

Scenario 3: Linear Graph Traversal

Details:
  TestName: TraversesLinearGraphCorrectly
  Description: Check if the BFS algorithm correctly traverses a linear graph (each vertex connected to at most two others).

Execution:
  Arrange: Create a linear graph with multiple vertices (e.g., A -> B -> C -> D).
  Act: Run the BFS algorithm starting from vertex A.
  Assert: Verify that all vertices are processed and their distances are set correctly (0 for A, 1 for B, 2 for C, 3 for D).

Validation:
  This scenario tests the core functionality of BFS in a simple, predictable graph structure, ensuring correct distance calculation and processing order.

Scenario 4: Cyclic Graph Handling

Details:
  TestName: HandlesCyclicGraphWithoutInfiniteLoop
  Description: Ensure the BFS algorithm correctly handles a graph with cycles without getting stuck in an infinite loop.

Execution:
  Arrange: Create a cyclic graph (e.g., A -> B -> C -> A).
  Act: Run the BFS algorithm starting from any vertex.
  Assert: Verify that all vertices are processed exactly once and have correct distances set.

Validation:
  This test is crucial to ensure that the algorithm doesn't revisit already processed nodes in a cyclic graph, which could lead to infinite loops or incorrect results.

Scenario 5: Disconnected Graph Components

Details:
  TestName: ProcessesOnlyReachableVerticesInDisconnectedGraph
  Description: Verify that BFS only processes vertices reachable from the start vertex in a disconnected graph.

Execution:
  Arrange: Create a graph with two disconnected components (e.g., A -> B, C -> D).
  Act: Run the BFS algorithm starting from vertex A.
  Assert: Check that only A and B are processed, while C and D remain unprocessed.

Validation:
  This scenario tests the algorithm's behavior with disconnected graphs, ensuring it doesn't process unreachable vertices and correctly identifies the connected component.

Scenario 6: Large Graph Performance

Details:
  TestName: CompletesLargeGraphTraversalInReasonableTime
  Description: Test the performance of the BFS algorithm on a large graph to ensure it completes in a reasonable time.

Execution:
  Arrange: Create a large graph with many vertices and edges (e.g., 10,000 vertices).
  Act: Run the BFS algorithm and measure the execution time.
  Assert: Verify that the algorithm completes within an acceptable time limit and processes all vertices.

Validation:
  This test ensures the algorithm's efficiency and scalability for large datasets, which is crucial for real-world applications.

Scenario 7: Correct Predecessor Assignment

Details:
  TestName: AssignsCorrectPredecessorsInComplexGraph
  Description: Verify that the BFS algorithm correctly assigns predecessors in a complex graph structure.

Execution:
  Arrange: Create a complex graph with multiple paths between vertices.
  Act: Run the BFS algorithm from a chosen start vertex.
  Assert: Check that each processed vertex (except the start) has a predecessor assigned, and that the predecessor is on a shortest path from the start vertex.

Validation:
  This test ensures that the predecessor assignment, which is crucial for path reconstruction, works correctly in complex graph structures.

These scenarios cover various aspects of the BreadthFirstSearch algorithm, including edge cases, error handling, and core functionality across different graph structures.


*/

// ********RoostGPT********
using NUnit.Framework;
using LunarDoggo.Datastructures.Graphs;
using LunarDoggo.Algorithms.Graphs.Pathfinding;
using System;
using System.Linq;

namespace LunarDoggo.Algorithms.Graphs.Pathfinding.Test
{
    [TestFixture]
    public class RunTest
    {
        [Test, Category("invalid")]
        public void ThrowsArgumentNullExceptionWhenGraphIsNull()
        {
            var bfs = new BreadthFirstSearch();
            var startVertex = new Vertex<BFSVertex>(0, new BFSVertex());

            Assert.Throws<ArgumentNullException>(() => bfs.Run(null, startVertex));
        }

        [Test, Category("valid")]
        public void ProcessesSingleVertexGraphCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertex = graph.AddVertex(new BFSVertex());
            var bfs = new BreadthFirstSearch();

            bfs.Run(graph, vertex);

            Assert.IsTrue(vertex.Value.Processed);
            Assert.AreEqual(0, vertex.Value.Distance);
        }

        [Test, Category("valid")]
        public void TraversesLinearGraphCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertexA = graph.AddVertex(new BFSVertex());
            var vertexB = graph.AddVertex(new BFSVertex());
            var vertexC = graph.AddVertex(new BFSVertex());
            var vertexD = graph.AddVertex(new BFSVertex());

            graph.AddEdge(vertexA, vertexB);
            graph.AddEdge(vertexB, vertexC);
            graph.AddEdge(vertexC, vertexD);

            var bfs = new BreadthFirstSearch();
            bfs.Run(graph, vertexA);

            Assert.AreEqual(0, vertexA.Value.Distance);
            Assert.AreEqual(1, vertexB.Value.Distance);
            Assert.AreEqual(2, vertexC.Value.Distance);
            Assert.AreEqual(3, vertexD.Value.Distance);
        }

        [Test, Category("valid")]
        public void HandlesCyclicGraphWithoutInfiniteLoop()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertexA = graph.AddVertex(new BFSVertex());
            var vertexB = graph.AddVertex(new BFSVertex());
            var vertexC = graph.AddVertex(new BFSVertex());

            graph.AddEdge(vertexA, vertexB);
            graph.AddEdge(vertexB, vertexC);
            graph.AddEdge(vertexC, vertexA);

            var bfs = new BreadthFirstSearch();
            bfs.Run(graph, vertexA);

            Assert.IsTrue(vertexA.Value.Processed);
            Assert.IsTrue(vertexB.Value.Processed);
            Assert.IsTrue(vertexC.Value.Processed);
            Assert.AreEqual(0, vertexA.Value.Distance);
            Assert.AreEqual(1, vertexB.Value.Distance);
            Assert.AreEqual(1, vertexC.Value.Distance);
        }

        [Test, Category("valid")]
        public void ProcessesOnlyReachableVerticesInDisconnectedGraph()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertexA = graph.AddVertex(new BFSVertex());
            var vertexB = graph.AddVertex(new BFSVertex());
            var vertexC = graph.AddVertex(new BFSVertex());
            var vertexD = graph.AddVertex(new BFSVertex());

            graph.AddEdge(vertexA, vertexB);
            graph.AddEdge(vertexC, vertexD);

            var bfs = new BreadthFirstSearch();
            bfs.Run(graph, vertexA);

            Assert.IsTrue(vertexA.Value.Processed);
            Assert.IsTrue(vertexB.Value.Processed);
            Assert.IsFalse(vertexC.Value.Processed);
            Assert.IsFalse(vertexD.Value.Processed);
        }

        [Test, Category("valid")]
        public void CompletesLargeGraphTraversalInReasonableTime()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertices = Enumerable.Range(0, 10000).Select(_ => graph.AddVertex(new BFSVertex())).ToList();

            for (int i = 0; i < vertices.Count - 1; i++)
            {
                graph.AddEdge(vertices[i], vertices[i + 1]);
            }

            var bfs = new BreadthFirstSearch();
            var startTime = DateTime.Now;
            bfs.Run(graph, vertices[0]);
            var endTime = DateTime.Now;

            Assert.Less((endTime - startTime).TotalSeconds, 5); // Assuming 5 seconds is reasonable
            Assert.IsTrue(vertices.All(v => v.Value.Processed));
        }

        [Test, Category("valid")]
        public void AssignsCorrectPredecessorsInComplexGraph()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertexA = graph.AddVertex(new BFSVertex());
            var vertexB = graph.AddVertex(new BFSVertex());
            var vertexC = graph.AddVertex(new BFSVertex());
            var vertexD = graph.AddVertex(new BFSVertex());
            var vertexE = graph.AddVertex(new BFSVertex());

            graph.AddEdge(vertexA, vertexB);
            graph.AddEdge(vertexA, vertexC);
            graph.AddEdge(vertexB, vertexD);
            graph.AddEdge(vertexC, vertexD);
            graph.AddEdge(vertexD, vertexE);

            var bfs = new BreadthFirstSearch();
            bfs.Run(graph, vertexA);

            Assert.AreEqual(null, vertexA.Value.Predecessor);
            Assert.AreEqual(vertexA, vertexB.Value.Predecessor);
            Assert.AreEqual(vertexA, vertexC.Value.Predecessor);
            Assert.IsTrue(vertexD.Value.Predecessor == vertexB || vertexD.Value.Predecessor == vertexC);
            Assert.AreEqual(vertexD, vertexE.Value.Predecessor);
        }
    }
}
