// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleCSharpEnv using AI Type  and AI Model 

ROOST_METHOD_HASH=Run_bbc3b7dcfd
ROOST_METHOD_SIG_HASH=Run_23f9485d25

   ########## Test-Scenarios ##########  

Based on the provided method and context, here are several test scenarios for the `Run` method of the `BreadthFirstSearch` class:

Scenario 1: Null Graph Handling

Details:
  TestName: ThrowsArgumentNullExceptionWhenGraphIsNull
  Description: Verify that the method throws an ArgumentNullException when a null graph is passed.
Execution:
  Arrange: Create a BreadthFirstSearch instance and set up a null graph and a valid start vertex.
  Act: Call the Run method with the null graph and valid start vertex.
  Assert: Expect an ArgumentNullException to be thrown.
Validation:
  This test ensures that the method properly handles null input for the graph parameter, maintaining robustness and preventing null reference exceptions later in the execution.

Scenario 2: Basic BFS Traversal

Details:
  TestName: CorrectlyTraversesSimpleGraph
  Description: Ensure that the BFS algorithm correctly traverses a simple graph and sets the correct distances and predecessors.
Execution:
  Arrange: Create a simple graph with known structure (e.g., a small tree or a simple connected graph).
  Act: Run the BFS algorithm on this graph starting from a specific vertex.
  Assert: Check that all vertices have been processed, and their distances and predecessors are set correctly.
Validation:
  This test verifies the core functionality of the BFS algorithm, ensuring it correctly explores the graph level by level and sets the appropriate metadata for each vertex.

Scenario 3: Disconnected Graph Handling

Details:
  TestName: HandlesDisconnectedGraphCorrectly
  Description: Verify that the BFS algorithm correctly handles a disconnected graph, only processing the connected component of the start vertex.
Execution:
  Arrange: Create a graph with multiple disconnected components.
  Act: Run the BFS algorithm starting from a vertex in one of the components.
  Assert: Check that only vertices in the same component as the start vertex are processed, while others remain unprocessed.
Validation:
  This test ensures that the BFS algorithm respects graph connectivity and doesn't incorrectly process unreachable vertices.

Scenario 4: Single Vertex Graph

Details:
  TestName: CorrectlyHandlesSingleVertexGraph
  Description: Ensure the BFS algorithm works correctly on a graph containing only one vertex.
Execution:
  Arrange: Create a graph with a single vertex.
  Act: Run the BFS algorithm on this single-vertex graph.
  Assert: Verify that the vertex is processed, has a distance of 0, and no predecessor.
Validation:
  This edge case test confirms that the algorithm behaves correctly in the simplest possible scenario, which is important for robustness.

Scenario 5: Cyclic Graph Traversal

Details:
  TestName: CorrectlyTraversesCyclicGraph
  Description: Verify that the BFS algorithm correctly handles graphs containing cycles without getting stuck in infinite loops.
Execution:
  Arrange: Create a graph with one or more cycles.
  Act: Run the BFS algorithm on this cyclic graph.
  Assert: Check that all vertices are processed exactly once, with correct distances and predecessors.
Validation:
  This test ensures that the algorithm can handle more complex graph structures without issues, which is crucial for its general applicability.

Scenario 6: Large Graph Performance

Details:
  TestName: CompletesLargeGraphTraversalInReasonableTime
  Description: Ensure that the BFS algorithm can handle large graphs efficiently.
Execution:
  Arrange: Create a large graph with many vertices and edges.
  Act: Run the BFS algorithm on this large graph, measuring the execution time.
  Assert: Verify that the algorithm completes within a reasonable time frame and processes all vertices correctly.
Validation:
  This performance test is important to ensure the algorithm's efficiency and scalability for larger datasets.

Scenario 7: Preservation of Original Graph Structure

Details:
  TestName: PreservesOriginalGraphStructure
  Description: Verify that the BFS algorithm doesn't modify the original structure of the graph.
Execution:
  Arrange: Create a graph and make a deep copy of its structure.
  Act: Run the BFS algorithm on the original graph.
  Assert: Compare the original graph's structure (vertices and edges) with the copy to ensure no modifications were made.
Validation:
  This test is crucial to ensure that the algorithm is non-destructive and only modifies the BFSVertex values as intended.

These scenarios cover various aspects of the BFS algorithm, including normal operation, edge cases, error handling, and performance considerations. They should provide a comprehensive test suite for the given method.


*/

// ********RoostGPT********
using NUnit.Framework;
using LunarDoggo.Datastructures.Graphs;
using LunarDoggo.Algorithms.Graphs.Pathfinding;
using System;
using System.Collections.Generic;
using System.Linq;

namespace LunarDoggo.Algorithms.Graphs.Pathfinding.Test
{
    [TestFixture]
    public class RunTest
    {
        [Test, Category("invalid")]
        public void ThrowsArgumentNullExceptionWhenGraphIsNull()
        {
            // Arrange
            var bfs = new BreadthFirstSearch();
            IGraph<BFSVertex> graph = null;
            var startVertex = new Vertex<BFSVertex>(0, new BFSVertex());

            // Act & Assert
            Assert.Throws<ArgumentNullException>(() => bfs.Run(graph, startVertex));
        }

        [Test, Category("valid")]
        public void CorrectlyTraversesSimpleGraph()
        {
            // Arrange
            var bfs = new BreadthFirstSearch();
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v0 = graph.AddVertex(new BFSVertex());
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v0, v1);
            graph.AddEdge(v1, v2);

            // Act
            bfs.Run(graph, v0);

            // Assert
            Assert.That(v0.Value.Distance, Is.EqualTo(0));
            Assert.That(v1.Value.Distance, Is.EqualTo(1));
            Assert.That(v2.Value.Distance, Is.EqualTo(2));
            Assert.That(v0.Value.Predecessor, Is.Null);
            Assert.That(v1.Value.Predecessor, Is.EqualTo(v0));
            Assert.That(v2.Value.Predecessor, Is.EqualTo(v1));
        }

        [Test, Category("valid")]
        public void HandlesDisconnectedGraphCorrectly()
        {
            // Arrange
            var bfs = new BreadthFirstSearch();
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v0 = graph.AddVertex(new BFSVertex());
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v0, v1);
            graph.AddEdge(v2, v3);

            // Act
            bfs.Run(graph, v0);

            // Assert
            Assert.That(v0.Value.Distance, Is.EqualTo(0));
            Assert.That(v1.Value.Distance, Is.EqualTo(1));
            Assert.That(v2.Value.Distance, Is.EqualTo(int.MaxValue));
            Assert.That(v3.Value.Distance, Is.EqualTo(int.MaxValue));
            Assert.That(v0.Value.Predecessor, Is.Null);
            Assert.That(v1.Value.Predecessor, Is.EqualTo(v0));
            Assert.That(v2.Value.Predecessor, Is.Null);
            Assert.That(v3.Value.Predecessor, Is.Null);
        }

        [Test, Category("boundary")]
        public void CorrectlyHandlesSingleVertexGraph()
        {
            // Arrange
            var bfs = new BreadthFirstSearch();
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v0 = graph.AddVertex(new BFSVertex());

            // Act
            bfs.Run(graph, v0);

            // Assert
            Assert.That(v0.Value.Distance, Is.EqualTo(0));
            Assert.That(v0.Value.Predecessor, Is.Null);
        }

        [Test, Category("valid")]
        public void CorrectlyTraversesCyclicGraph()
        {
            // Arrange
            var bfs = new BreadthFirstSearch();
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v0 = graph.AddVertex(new BFSVertex());
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v0, v1);
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v0);

            // Act
            bfs.Run(graph, v0);

            // Assert
            Assert.That(v0.Value.Distance, Is.EqualTo(0));
            Assert.That(v1.Value.Distance, Is.EqualTo(1));
            Assert.That(v2.Value.Distance, Is.EqualTo(1));
            Assert.That(v0.Value.Predecessor, Is.Null);
            Assert.That(v1.Value.Predecessor, Is.EqualTo(v0));
            Assert.That(v2.Value.Predecessor, Is.EqualTo(v0));
        }

        [Test, Category("integration")]
        public void CompletesLargeGraphTraversalInReasonableTime()
        {
            // Arrange
            var bfs = new BreadthFirstSearch();
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertices = new List<Vertex<BFSVertex>>();
            for (int i = 0; i < 10000; i++)
            {
                vertices.Add(graph.AddVertex(new BFSVertex()));
            }
            for (int i = 0; i < 9999; i++)
            {
                graph.AddEdge(vertices[i], vertices[i + 1]);
            }

            // Act
            var startTime = DateTime.Now;
            bfs.Run(graph, vertices[0]);
            var endTime = DateTime.Now;

            // Assert
            Assert.That((endTime - startTime).TotalSeconds, Is.LessThan(5));
            Assert.That(vertices.Last().Value.Distance, Is.EqualTo(9999));
        }

        [Test, Category("valid")]
        public void PreservesOriginalGraphStructure()
        {
            // Arrange
            var bfs = new BreadthFirstSearch();
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v0 = graph.AddVertex(new BFSVertex());
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v0, v1);
            graph.AddEdge(v1, v2);

            var originalVertices = graph.Vertices.ToList();
            var originalEdges = graph.Edges.ToList();

            // Act
            bfs.Run(graph, v0);

            // Assert
            Assert.That(graph.Vertices, Is.EquivalentTo(originalVertices));
            Assert.That(graph.Edges, Is.EquivalentTo(originalEdges));
        }
    }
}
