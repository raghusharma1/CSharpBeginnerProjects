// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleCSharpEnv using AI Type  and AI Model 

ROOST_METHOD_HASH=Run_bbc3b7dcfd
ROOST_METHOD_SIG_HASH=Run_23f9485d25

   ########## Test-Scenarios ##########  

Based on the provided method and context, here are several test scenarios for the BreadthFirstSearch.Run method:

Scenario 1: Null Graph Handling

Details:
  TestName: ThrowArgumentNullExceptionWhenGraphIsNull
  Description: Verify that the method throws an ArgumentNullException when a null graph is passed.

Execution:
  Arrange: Create a BreadthFirstSearch instance and a null IGraph<BFSVertex>.
  Act: Call the Run method with the null graph and a valid start vertex.
  Assert: Expect an ArgumentNullException to be thrown.

Validation:
  This test ensures that the method properly handles null input for the graph parameter, maintaining robustness and preventing null reference exceptions later in the execution.

Scenario 2: Single Vertex Graph

Details:
  TestName: ProcessSingleVertexGraphCorrectly
  Description: Ensure the method correctly processes a graph with only one vertex.

Execution:
  Arrange: Create a BreadthFirstSearch instance and an IGraph<BFSVertex> with a single vertex.
  Act: Call the Run method with the graph and the single vertex as the start.
  Assert: Verify that the vertex's Distance is 0 and Processed is true.

Validation:
  This test confirms that the method correctly initializes and processes a trivial graph case, setting the correct distance and processed state for the single vertex.

Scenario 3: Linear Graph Traversal

Details:
  TestName: TraverseLinearGraphCorrectly
  Description: Verify correct traversal and distance calculation in a linear graph (A -> B -> C).

Execution:
  Arrange: Create a BreadthFirstSearch instance and an IGraph<BFSVertex> with three vertices connected linearly.
  Act: Call the Run method with the graph and the first vertex as the start.
  Assert: Check that all vertices are processed and have correct distances (0, 1, 2 respectively).

Validation:
  This test ensures that the BFS algorithm correctly traverses a simple linear graph, assigning proper distances and processing all vertices.

Scenario 4: Cyclic Graph Handling

Details:
  TestName: HandleCyclicGraphWithoutInfiniteLoop
  Description: Ensure the method correctly processes a graph with cycles without getting stuck in an infinite loop.

Execution:
  Arrange: Create a BreadthFirstSearch instance and an IGraph<BFSVertex> with a cycle (e.g., A -> B -> C -> A).
  Act: Call the Run method with the graph and any vertex as the start.
  Assert: Verify that all vertices are processed, have correct distances, and the method terminates.

Validation:
  This test confirms that the BFS algorithm can handle cyclic graphs without falling into infinite loops, which is crucial for graph traversal robustness.

Scenario 5: Disconnected Graph Components

Details:
  TestName: ProcessOnlyReachableVerticesInDisconnectedGraph
  Description: Verify that only vertices reachable from the start vertex are processed in a disconnected graph.

Execution:
  Arrange: Create a BreadthFirstSearch instance and an IGraph<BFSVertex> with two disconnected components.
  Act: Call the Run method with the graph and a vertex from one component as the start.
  Assert: Check that all vertices in the start component are processed and have distances set, while vertices in the other component remain unprocessed with maximum distance.

Validation:
  This test ensures that the BFS algorithm correctly handles disconnected graphs, processing only the reachable vertices and leaving unreachable vertices in their initial state.

Scenario 6: Large Graph Performance

Details:
  TestName: ProcessLargeGraphWithinReasonableTime
  Description: Ensure the method can handle a large graph (e.g., 10000 vertices) within a reasonable time frame.

Execution:
  Arrange: Create a BreadthFirstSearch instance and a large IGraph<BFSVertex> with many vertices and edges.
  Act: Measure the time taken to call and complete the Run method.
  Assert: Verify that the method completes within a specified time limit and all vertices are processed.

Validation:
  This test checks the performance and scalability of the BFS implementation, ensuring it can handle large graphs efficiently.

Scenario 7: Correct Predecessor Assignment

Details:
  TestName: AssignCorrectPredecessorsInComplexGraph
  Description: Verify that the method correctly assigns predecessors in a more complex graph structure.

Execution:
  Arrange: Create a BreadthFirstSearch instance and an IGraph<BFSVertex> with a complex structure (e.g., multiple paths between vertices).
  Act: Call the Run method with the graph and a chosen start vertex.
  Assert: Check that each processed vertex (except the start) has a predecessor that is one step closer to the start vertex.

Validation:
  This test ensures that the BFS algorithm correctly builds the breadth-first tree by assigning appropriate predecessors, which is crucial for path reconstruction and other graph analyses.

These test scenarios cover various aspects of the BreadthFirstSearch.Run method, including edge cases, error handling, and different graph structures. They aim to ensure the correctness, robustness, and efficiency of the BFS implementation.


*/

// ********RoostGPT********
using NUnit.Framework;
using LunarDoggo.Datastructures.Graphs;
using LunarDoggo.Algorithms.Graphs.Pathfinding;
using System;
using System.Collections.Generic;
using System.Linq;

namespace LunarDoggo.Algorithms.Graphs.Pathfinding.Test
{
    [TestFixture]
    public class RunTest
    {
        private BreadthFirstSearch bfs;

        [SetUp]
        public void Setup()
        {
            bfs = new BreadthFirstSearch();
        }

        [Test, Category("invalid")]
        public void ThrowArgumentNullExceptionWhenGraphIsNull()
        {
            IGraph<BFSVertex> graph = null;
            Vertex<BFSVertex> start = new Vertex<BFSVertex>(0, new BFSVertex());

            Assert.Throws<ArgumentNullException>(() => bfs.Run(graph, start));
        }

        [Test, Category("valid")]
        public void ProcessSingleVertexGraphCorrectly()
        {
            UndirectedUnweightedGraph<BFSVertex> graph = new UndirectedUnweightedGraph<BFSVertex>();
            Vertex<BFSVertex> vertex = graph.AddVertex(new BFSVertex());

            bfs.Run(graph, vertex);

            Assert.That(vertex.Value.Distance, Is.EqualTo(0));
            Assert.That(vertex.Value.Processed, Is.True);
        }

        [Test, Category("valid")]
        public void TraverseLinearGraphCorrectly()
        {
            UndirectedUnweightedGraph<BFSVertex> graph = new UndirectedUnweightedGraph<BFSVertex>();
            Vertex<BFSVertex> vertexA = graph.AddVertex(new BFSVertex());
            Vertex<BFSVertex> vertexB = graph.AddVertex(new BFSVertex());
            Vertex<BFSVertex> vertexC = graph.AddVertex(new BFSVertex());
            graph.AddEdge(vertexA, vertexB);
            graph.AddEdge(vertexB, vertexC);

            bfs.Run(graph, vertexA);

            Assert.That(vertexA.Value.Distance, Is.EqualTo(0));
            Assert.That(vertexB.Value.Distance, Is.EqualTo(1));
            Assert.That(vertexC.Value.Distance, Is.EqualTo(2));
            Assert.That(vertexA.Value.Processed && vertexB.Value.Processed && vertexC.Value.Processed, Is.True);
        }

        [Test, Category("valid")]
        public void HandleCyclicGraphWithoutInfiniteLoop()
        {
            UndirectedUnweightedGraph<BFSVertex> graph = new UndirectedUnweightedGraph<BFSVertex>();
            Vertex<BFSVertex> vertexA = graph.AddVertex(new BFSVertex());
            Vertex<BFSVertex> vertexB = graph.AddVertex(new BFSVertex());
            Vertex<BFSVertex> vertexC = graph.AddVertex(new BFSVertex());
            graph.AddEdge(vertexA, vertexB);
            graph.AddEdge(vertexB, vertexC);
            graph.AddEdge(vertexC, vertexA);

            bfs.Run(graph, vertexA);

            Assert.That(vertexA.Value.Distance, Is.EqualTo(0));
            Assert.That(vertexB.Value.Distance, Is.EqualTo(1));
            Assert.That(vertexC.Value.Distance, Is.EqualTo(1));
            Assert.That(vertexA.Value.Processed && vertexB.Value.Processed && vertexC.Value.Processed, Is.True);
        }

        [Test, Category("valid")]
        public void ProcessOnlyReachableVerticesInDisconnectedGraph()
        {
            UndirectedUnweightedGraph<BFSVertex> graph = new UndirectedUnweightedGraph<BFSVertex>();
            Vertex<BFSVertex> vertexA = graph.AddVertex(new BFSVertex());
            Vertex<BFSVertex> vertexB = graph.AddVertex(new BFSVertex());
            Vertex<BFSVertex> vertexC = graph.AddVertex(new BFSVertex());
            Vertex<BFSVertex> vertexD = graph.AddVertex(new BFSVertex());
            graph.AddEdge(vertexA, vertexB);
            graph.AddEdge(vertexC, vertexD);

            bfs.Run(graph, vertexA);

            Assert.That(vertexA.Value.Distance, Is.EqualTo(0));
            Assert.That(vertexB.Value.Distance, Is.EqualTo(1));
            Assert.That(vertexC.Value.Distance, Is.EqualTo(int.MaxValue));
            Assert.That(vertexD.Value.Distance, Is.EqualTo(int.MaxValue));
            Assert.That(vertexA.Value.Processed && vertexB.Value.Processed, Is.True);
            Assert.That(vertexC.Value.Processed || vertexD.Value.Processed, Is.False);
        }

        [Test, Category("valid")]
        public void ProcessLargeGraphWithinReasonableTime()
        {
            UndirectedUnweightedGraph<BFSVertex> graph = new UndirectedUnweightedGraph<BFSVertex>();
            List<Vertex<BFSVertex>> vertices = new List<Vertex<BFSVertex>>();
            for (int i = 0; i < 10000; i++)
            {
                vertices.Add(graph.AddVertex(new BFSVertex()));
            }
            for (int i = 0; i < 9999; i++)
            {
                graph.AddEdge(vertices[i], vertices[i + 1]);
            }

            DateTime start = DateTime.Now;
            bfs.Run(graph, vertices[0]);
            TimeSpan duration = DateTime.Now - start;

            Assert.That(duration.TotalSeconds, Is.LessThan(5));
            Assert.That(vertices.All(v => v.Value.Processed), Is.True);
        }

        [Test, Category("valid")]
        public void AssignCorrectPredecessorsInComplexGraph()
        {
            UndirectedUnweightedGraph<BFSVertex> graph = new UndirectedUnweightedGraph<BFSVertex>();
            Vertex<BFSVertex> vertexA = graph.AddVertex(new BFSVertex());
            Vertex<BFSVertex> vertexB = graph.AddVertex(new BFSVertex());
            Vertex<BFSVertex> vertexC = graph.AddVertex(new BFSVertex());
            Vertex<BFSVertex> vertexD = graph.AddVertex(new BFSVertex());
            Vertex<BFSVertex> vertexE = graph.AddVertex(new BFSVertex());
            graph.AddEdge(vertexA, vertexB);
            graph.AddEdge(vertexA, vertexC);
            graph.AddEdge(vertexB, vertexD);
            graph.AddEdge(vertexC, vertexD);
            graph.AddEdge(vertexD, vertexE);

            bfs.Run(graph, vertexA);

            Assert.That(vertexB.Value.Predecessor, Is.EqualTo(vertexA));
            Assert.That(vertexC.Value.Predecessor, Is.EqualTo(vertexA));
            Assert.That(vertexD.Value.Predecessor, Is.AnyOf(vertexB, vertexC));
            Assert.That(vertexE.Value.Predecessor, Is.EqualTo(vertexD));
        }
    }
}
