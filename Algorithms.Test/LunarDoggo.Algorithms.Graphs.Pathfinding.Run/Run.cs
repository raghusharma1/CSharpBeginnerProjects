// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleCSharpEnv using AI Type  and AI Model 

ROOST_METHOD_HASH=Run_bbc3b7dcfd
ROOST_METHOD_SIG_HASH=Run_23f9485d25

   ########## Test-Scenarios ##########  

Based on the provided method and context, here are several test scenarios for the `Run` method of the `BreadthFirstSearch` class:

Scenario 1: Null Graph Handling

Details:
  TestName: ThrowsArgumentNullExceptionWhenGraphIsNull
  Description: Verify that the method throws an ArgumentNullException when a null graph is passed.
Execution:
  Arrange: Create a BreadthFirstSearch instance and set up a null graph and a valid start vertex.
  Act: Call the Run method with the null graph and valid start vertex.
  Assert: Expect an ArgumentNullException to be thrown.
Validation:
  This test ensures that the method properly handles null input for the graph parameter, maintaining robustness and preventing null reference exceptions later in the execution.

Scenario 2: Single Vertex Graph

Details:
  TestName: ProcessesSingleVertexGraphCorrectly
  Description: Ensure the method correctly processes a graph with only one vertex (the start vertex).
Execution:
  Arrange: Create a graph with a single vertex, set up a BreadthFirstSearch instance.
  Act: Run the BFS algorithm on this graph.
  Assert: Verify that the single vertex is processed (Processed = true, Distance = 0, Predecessor = null).
Validation:
  This test confirms that the BFS algorithm works correctly for the simplest possible graph, setting a baseline for more complex scenarios.

Scenario 3: Linear Graph Traversal

Details:
  TestName: TraversesLinearGraphCorrectly
  Description: Check if the BFS algorithm correctly traverses a linear graph (a chain of vertices).
Execution:
  Arrange: Create a linear graph with multiple vertices connected in a line, set up a BreadthFirstSearch instance.
  Act: Run the BFS algorithm starting from one end of the linear graph.
  Assert: Verify that all vertices are processed in order, with increasing distances and correct predecessors.
Validation:
  This test ensures that the BFS algorithm correctly handles a simple but multi-vertex graph structure, properly updating distances and predecessors.

Scenario 4: Cyclic Graph Handling

Details:
  TestName: HandlesCyclicGraphWithoutInfiniteLoop
  Description: Verify that the BFS algorithm correctly processes a graph with cycles without getting stuck in an infinite loop.
Execution:
  Arrange: Create a graph with a cycle (e.g., A -> B -> C -> A), set up a BreadthFirstSearch instance.
  Act: Run the BFS algorithm starting from any vertex in the cycle.
  Assert: Check that all vertices are processed exactly once, with correct distances and predecessors.
Validation:
  This test confirms that the algorithm can handle cycles in the graph without revisiting vertices or entering an infinite loop.

Scenario 5: Disconnected Graph Components

Details:
  TestName: ProcessesOnlyReachableVerticesInDisconnectedGraph
  Description: Ensure that the BFS algorithm only processes vertices reachable from the start vertex in a disconnected graph.
Execution:
  Arrange: Create a graph with two disconnected components, set up a BreadthFirstSearch instance.
  Act: Run the BFS algorithm starting from a vertex in one component.
  Assert: Verify that only vertices in the same component as the start vertex are processed, while vertices in the other component remain unprocessed.
Validation:
  This test checks that the BFS algorithm respects the graph's structure and doesn't process unreachable vertices.

Scenario 6: Large Graph Performance

Details:
  TestName: CompletesLargeGraphTraversalInReasonableTime
  Description: Verify that the BFS algorithm can process a large graph within a reasonable time frame.
Execution:
  Arrange: Create a large graph with many vertices and edges, set up a BreadthFirstSearch instance.
  Act: Run the BFS algorithm and measure the execution time.
  Assert: Check that the algorithm completes within an acceptable time limit and processes all vertices correctly.
Validation:
  This test ensures that the BFS implementation is efficient enough to handle large graphs, which is crucial for real-world applications.

These test scenarios cover various aspects of the BreadthFirstSearch algorithm, including edge cases, error handling, and performance considerations. They should provide a comprehensive suite for validating the correctness and robustness of the implementation.


*/

// ********RoostGPT********
using NUnit.Framework;
using LunarDoggo.Datastructures.Graphs;
using LunarDoggo.Algorithms.Graphs.Pathfinding;
using System;
using System.Linq;

namespace LunarDoggo.Algorithms.Graphs.Pathfinding.Test
{
    [TestFixture]
    public class RunTest
    {
        private BreadthFirstSearch bfs;
        private UndirectedUnweightedGraph<BFSVertex> graph;

        [SetUp]
        public void Setup()
        {
            bfs = new BreadthFirstSearch();
            graph = new UndirectedUnweightedGraph<BFSVertex>();
        }

        [Test, Category("invalid")]
        public void ThrowsArgumentNullExceptionWhenGraphIsNull()
        {
            var startVertex = new Vertex<BFSVertex>(0, new BFSVertex());
            Assert.Throws<ArgumentNullException>(() => bfs.Run(null, startVertex));
        }

        [Test, Category("valid")]
        public void ProcessesSingleVertexGraphCorrectly()
        {
            var vertex = graph.AddVertex(new BFSVertex());
            bfs.Run(graph, vertex);

            Assert.IsTrue(vertex.Value.Processed);
            Assert.AreEqual(0, vertex.Value.Distance);
            Assert.IsNull(vertex.Value.Predecessor);
        }

        [Test, Category("valid")]
        public void TraversesLinearGraphCorrectly()
        {
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());

            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);

            bfs.Run(graph, v1);

            Assert.IsTrue(v1.Value.Processed);
            Assert.IsTrue(v2.Value.Processed);
            Assert.IsTrue(v3.Value.Processed);

            Assert.AreEqual(0, v1.Value.Distance);
            Assert.AreEqual(1, v2.Value.Distance);
            Assert.AreEqual(2, v3.Value.Distance);

            Assert.IsNull(v1.Value.Predecessor);
            Assert.AreEqual(v1, v2.Value.Predecessor);
            Assert.AreEqual(v2, v3.Value.Predecessor);
        }

        [Test, Category("valid")]
        public void HandlesCyclicGraphWithoutInfiniteLoop()
        {
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());

            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);
            graph.AddEdge(v3, v1);

            bfs.Run(graph, v1);

            Assert.IsTrue(v1.Value.Processed);
            Assert.IsTrue(v2.Value.Processed);
            Assert.IsTrue(v3.Value.Processed);

            Assert.AreEqual(0, v1.Value.Distance);
            Assert.AreEqual(1, v2.Value.Distance);
            Assert.AreEqual(1, v3.Value.Distance);

            Assert.IsNull(v1.Value.Predecessor);
            Assert.AreEqual(v1, v2.Value.Predecessor);
            Assert.AreEqual(v1, v3.Value.Predecessor);
        }

        [Test, Category("valid")]
        public void ProcessesOnlyReachableVerticesInDisconnectedGraph()
        {
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            var v4 = graph.AddVertex(new BFSVertex());

            graph.AddEdge(v1, v2);
            graph.AddEdge(v3, v4);

            bfs.Run(graph, v1);

            Assert.IsTrue(v1.Value.Processed);
            Assert.IsTrue(v2.Value.Processed);
            Assert.IsFalse(v3.Value.Processed);
            Assert.IsFalse(v4.Value.Processed);

            Assert.AreEqual(0, v1.Value.Distance);
            Assert.AreEqual(1, v2.Value.Distance);
            Assert.AreEqual(int.MaxValue, v3.Value.Distance);
            Assert.AreEqual(int.MaxValue, v4.Value.Distance);

            Assert.IsNull(v1.Value.Predecessor);
            Assert.AreEqual(v1, v2.Value.Predecessor);
            Assert.IsNull(v3.Value.Predecessor);
            Assert.IsNull(v4.Value.Predecessor);
        }

        [Test, Category("valid")]
        public void CompletesLargeGraphTraversalInReasonableTime()
        {
            const int vertexCount = 10000;
            var vertices = Enumerable.Range(0, vertexCount)
                .Select(_ => graph.AddVertex(new BFSVertex()))
                .ToList();

            for (int i = 0; i < vertexCount - 1; i++)
            {
                graph.AddEdge(vertices[i], vertices[i + 1]);
            }

            var startTime = DateTime.Now;
            bfs.Run(graph, vertices[0]);
            var endTime = DateTime.Now;

            var duration = (endTime - startTime).TotalSeconds;
            Assert.Less(duration, 5, "BFS took too long to complete");

            for (int i = 0; i < vertexCount; i++)
            {
                Assert.IsTrue(vertices[i].Value.Processed);
                Assert.AreEqual(i, vertices[i].Value.Distance);
                if (i > 0)
                {
                    Assert.AreEqual(vertices[i - 1], vertices[i].Value.Predecessor);
                }
                else
                {
                    Assert.IsNull(vertices[i].Value.Predecessor);
                }
            }
        }
    }
}
