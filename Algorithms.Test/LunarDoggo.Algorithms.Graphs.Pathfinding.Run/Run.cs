// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleCSharpEnv using AI Type Claude AI and AI Model claude-3-5-sonnet-20240620

ROOST_METHOD_HASH=Run_bbc3b7dcfd
ROOST_METHOD_SIG_HASH=Run_23f9485d25

   ########## Test-Scenarios ##########  

Based on the provided method and related code, here are several test scenarios for the `Run` method of the `BreadthFirstSearch` class:

Scenario 1: Null Graph Handling

Details:
  TestName: ThrowsArgumentNullExceptionWhenGraphIsNull
  Description: Verify that the method throws an ArgumentNullException when a null graph is provided.
Execution:
  Arrange: Create a BreadthFirstSearch instance and prepare a null graph and a valid start vertex.
  Act: Call the Run method with the null graph and valid start vertex.
  Assert: Expect an ArgumentNullException to be thrown.
Validation:
  This test ensures that the method properly handles null input for the graph parameter, maintaining robustness and preventing null reference exceptions later in the execution.

Scenario 2: Single Vertex Graph

Details:
  TestName: ProcessesSingleVertexGraphCorrectly
  Description: Ensure the method correctly processes a graph with only one vertex (the start vertex).
Execution:
  Arrange: Create a graph with a single vertex, set it as the start vertex, and initialize a BreadthFirstSearch instance.
  Act: Call the Run method with the graph and start vertex.
  Assert: Verify that the start vertex's distance is 0 and it has no predecessor.
Validation:
  This test confirms that the BFS algorithm works correctly for the simplest possible graph, setting the correct distance and leaving the predecessor as null.

Scenario 3: Linear Graph Traversal

Details:
  TestName: TraversesLinearGraphCorrectly
  Description: Verify that the method correctly traverses a linear graph (a chain of vertices).
Execution:
  Arrange: Create a linear graph with multiple vertices connected in a chain, set the first vertex as the start, and initialize a BreadthFirstSearch instance.
  Act: Call the Run method with the graph and start vertex.
  Assert: Check that each vertex has the correct distance (increasing by 1 for each step away from the start) and the correct predecessor.
Validation:
  This test ensures that the BFS algorithm correctly processes a simple linear structure, assigning proper distances and predecessors.

Scenario 4: Branching Graph Traversal

Details:
  TestName: TraversesBranchingGraphCorrectly
  Description: Confirm that the method correctly traverses a graph with multiple branches.
Execution:
  Arrange: Create a graph with a root vertex that branches out to multiple paths of varying lengths, set the root as the start vertex, and initialize a BreadthFirstSearch instance.
  Act: Call the Run method with the graph and start vertex.
  Assert: Verify that all vertices are processed, have correct distances (shortest path from start), and appropriate predecessors.
Validation:
  This test checks if the BFS algorithm correctly handles more complex graph structures, ensuring it finds the shortest paths in a branching scenario.

Scenario 5: Cyclic Graph Handling

Details:
  TestName: HandlesCyclicGraphWithoutInfiniteLoop
  Description: Ensure the method correctly processes a graph containing cycles without getting stuck in an infinite loop.
Execution:
  Arrange: Create a graph with at least one cycle, set a vertex as the start, and initialize a BreadthFirstSearch instance.
  Act: Call the Run method with the graph and start vertex.
  Assert: Check that all vertices are processed exactly once, have correct distances, and appropriate predecessors.
Validation:
  This test verifies that the BFS algorithm can handle graphs with cycles, avoiding repeated processing of vertices and terminating correctly.

Scenario 6: Disconnected Graph Components

Details:
  TestName: ProcessesOnlyReachableVerticesInDisconnectedGraph
  Description: Verify that the method only processes vertices reachable from the start vertex in a disconnected graph.
Execution:
  Arrange: Create a graph with multiple disconnected components, set a start vertex in one component, and initialize a BreadthFirstSearch instance.
  Act: Call the Run method with the graph and start vertex.
  Assert: Confirm that only vertices in the same component as the start vertex are processed (have finite distances and predecessors), while others remain unprocessed.
Validation:
  This test ensures that the BFS algorithm correctly handles disconnected graphs, processing only the reachable portion from the given start vertex.

Scenario 7: Large Graph Performance

Details:
  TestName: CompletesLargeGraphTraversalInReasonableTime
  Description: Check that the method can process a large graph within an acceptable time frame.
Execution:
  Arrange: Generate a large graph with many vertices and edges, set a start vertex, and initialize a BreadthFirstSearch instance.
  Act: Measure the time taken to call and complete the Run method with the large graph and start vertex.
  Assert: Verify that the execution time is within an acceptable range and that all vertices are correctly processed.
Validation:
  This test assesses the performance characteristics of the BFS implementation, ensuring it scales reasonably with larger inputs.

These scenarios cover various aspects of the BreadthFirstSearch.Run method, including error handling, correctness for different graph structures, and performance considerations.


*/

// ********RoostGPT********
using NUnit.Framework;
using LunarDoggo.Datastructures.Graphs;
using LunarDoggo.Algorithms.Graphs.Pathfinding;
using System;
using System.Linq;

namespace LunarDoggo.Algorithms.Graphs.Pathfinding.Test
{
    [TestFixture]
    public class RunTest
    {
        [Test, Category("invalid")]
        public void ThrowsArgumentNullExceptionWhenGraphIsNull()
        {
            var bfs = new BreadthFirstSearch();
            var startVertex = new Vertex<BFSVertex>(0, new BFSVertex());

            Assert.Throws<ArgumentNullException>(() => bfs.Run(null, startVertex));
        }

        [Test, Category("valid")]
        public void ProcessesSingleVertexGraphCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var startVertex = graph.AddVertex(new BFSVertex());
            var bfs = new BreadthFirstSearch();

            bfs.Run(graph, startVertex);

            Assert.That(startVertex.Value.Distance, Is.EqualTo(0));
            Assert.That(startVertex.Value.Predecessor, Is.Null);
        }

        [Test, Category("valid")]
        public void TraversesLinearGraphCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);

            var bfs = new BreadthFirstSearch();
            bfs.Run(graph, v1);

            Assert.That(v1.Value.Distance, Is.EqualTo(0));
            Assert.That(v2.Value.Distance, Is.EqualTo(1));
            Assert.That(v3.Value.Distance, Is.EqualTo(2));
            Assert.That(v2.Value.Predecessor, Is.EqualTo(v1));
            Assert.That(v3.Value.Predecessor, Is.EqualTo(v2));
        }

        [Test, Category("valid")]
        public void TraversesBranchingGraphCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var root = graph.AddVertex(new BFSVertex());
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            var v4 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(root, v1);
            graph.AddEdge(root, v2);
            graph.AddEdge(v1, v3);
            graph.AddEdge(v2, v4);

            var bfs = new BreadthFirstSearch();
            bfs.Run(graph, root);

            Assert.That(root.Value.Distance, Is.EqualTo(0));
            Assert.That(v1.Value.Distance, Is.EqualTo(1));
            Assert.That(v2.Value.Distance, Is.EqualTo(1));
            Assert.That(v3.Value.Distance, Is.EqualTo(2));
            Assert.That(v4.Value.Distance, Is.EqualTo(2));
            Assert.That(v1.Value.Predecessor, Is.EqualTo(root));
            Assert.That(v2.Value.Predecessor, Is.EqualTo(root));
            Assert.That(v3.Value.Predecessor, Is.EqualTo(v1));
            Assert.That(v4.Value.Predecessor, Is.EqualTo(v2));
        }

        [Test, Category("valid")]
        public void HandlesCyclicGraphWithoutInfiniteLoop()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);
            graph.AddEdge(v3, v1);

            var bfs = new BreadthFirstSearch();
            bfs.Run(graph, v1);

            Assert.That(v1.Value.Distance, Is.EqualTo(0));
            Assert.That(v2.Value.Distance, Is.EqualTo(1));
            Assert.That(v3.Value.Distance, Is.EqualTo(1));
            Assert.That(v2.Value.Predecessor, Is.EqualTo(v1));
            Assert.That(v3.Value.Predecessor, Is.EqualTo(v1));
        }

        [Test, Category("valid")]
        public void ProcessesOnlyReachableVerticesInDisconnectedGraph()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            var v4 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v3, v4);

            var bfs = new BreadthFirstSearch();
            bfs.Run(graph, v1);

            Assert.That(v1.Value.Distance, Is.EqualTo(0));
            Assert.That(v2.Value.Distance, Is.EqualTo(1));
            Assert.That(v3.Value.Distance, Is.EqualTo(int.MaxValue));
            Assert.That(v4.Value.Distance, Is.EqualTo(int.MaxValue));
            Assert.That(v2.Value.Predecessor, Is.EqualTo(v1));
            Assert.That(v3.Value.Predecessor, Is.Null);
            Assert.That(v4.Value.Predecessor, Is.Null);
        }

        [Test, Category("valid")]
        public void CompletesLargeGraphTraversalInReasonableTime()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertices = Enumerable.Range(0, 10000).Select(_ => graph.AddVertex(new BFSVertex())).ToList();
            for (int i = 0; i < vertices.Count - 1; i++)
            {
                graph.AddEdge(vertices[i], vertices[i + 1]);
            }

            var bfs = new BreadthFirstSearch();
            var startTime = DateTime.Now;
            bfs.Run(graph, vertices[0]);
            var endTime = DateTime.Now;

            Assert.That((endTime - startTime).TotalSeconds, Is.LessThan(5));
            Assert.That(vertices.All(v => v.Value.Processed), Is.True);
        }
    }
}
