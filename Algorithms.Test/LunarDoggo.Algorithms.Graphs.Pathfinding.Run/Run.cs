// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleCSharpEnv using AI Type  and AI Model 

ROOST_METHOD_HASH=Run_bbc3b7dcfd
ROOST_METHOD_SIG_HASH=Run_23f9485d25

   ########## Test-Scenarios ##########  

Based on the provided method and related code, here are several test scenarios for the `Run` method of the `BreadthFirstSearch` class:

Scenario 1: Valid Graph and Start Vertex

Details:
  TestName: RunBFSWithValidGraphAndStartVertex
  Description: Test the BFS algorithm with a valid graph and start vertex to ensure correct traversal and distance calculation.

Execution:
  Arrange: Create a valid graph with multiple vertices and edges, and select a start vertex.
  Act: Call the Run method with the created graph and start vertex.
  Assert: Check if all vertices are processed, distances are correctly calculated, and predecessors are properly set.

Validation:
  This test verifies that the BFS algorithm correctly traverses the graph, assigns proper distances from the start vertex, and sets the correct predecessors for each vertex. It ensures the core functionality of the BFS algorithm is working as expected.

Scenario 2: Null Graph Input

Details:
  TestName: RunBFSWithNullGraphThrowsArgumentNullException
  Description: Test that the Run method throws an ArgumentNullException when given a null graph.

Execution:
  Arrange: Prepare a null graph and a valid start vertex.
  Act: Call the Run method with the null graph and valid start vertex.
  Assert: Verify that an ArgumentNullException is thrown with the correct error message.

Validation:
  This test ensures that the method properly handles invalid input by throwing the correct exception when a null graph is provided. It validates the error handling mechanism of the method.

Scenario 3: Empty Graph

Details:
  TestName: RunBFSWithEmptyGraph
  Description: Test the BFS algorithm with an empty graph to ensure it handles this edge case correctly.

Execution:
  Arrange: Create an empty graph (no vertices or edges) and a start vertex.
  Act: Call the Run method with the empty graph and start vertex.
  Assert: Verify that no exceptions are thrown and the method completes without error.

Validation:
  This test checks if the BFS algorithm can handle an edge case of an empty graph without crashing or throwing unexpected exceptions. It ensures robustness of the algorithm.

Scenario 4: Graph with Isolated Vertices

Details:
  TestName: RunBFSWithGraphContainingIsolatedVertices
  Description: Test the BFS algorithm on a graph with some isolated vertices (vertices with no edges).

Execution:
  Arrange: Create a graph with both connected and isolated vertices, and select a start vertex from the connected portion.
  Act: Call the Run method with this graph and the selected start vertex.
  Assert: Verify that connected vertices are processed correctly and isolated vertices remain unprocessed.

Validation:
  This test ensures that the BFS algorithm correctly handles graphs with disconnected components, processing only the vertices reachable from the start vertex and leaving others untouched.

Scenario 5: Cyclic Graph

Details:
  TestName: RunBFSOnCyclicGraph
  Description: Test the BFS algorithm on a graph containing cycles to ensure it doesn't enter an infinite loop.

Execution:
  Arrange: Create a graph with at least one cycle and select a start vertex.
  Act: Call the Run method with this cyclic graph and start vertex.
  Assert: Verify that all vertices are processed exactly once and distances are correctly calculated.

Validation:
  This test checks if the BFS algorithm can handle cycles in the graph without getting stuck in an infinite loop. It ensures that each vertex is processed only once, maintaining the correct distance calculations.

Scenario 6: Large Graph Performance

Details:
  TestName: RunBFSOnLargeGraphPerformanceTest
  Description: Test the performance of the BFS algorithm on a large graph to ensure it completes within a reasonable time.

Execution:
  Arrange: Create a large graph with many vertices and edges, and select a start vertex.
  Act: Measure the time taken to execute the Run method on this large graph.
  Assert: Verify that the execution completes within an acceptable time limit.

Validation:
  This test assesses the performance characteristics of the BFS implementation, ensuring it can handle large graphs efficiently. It helps identify any potential performance bottlenecks in the algorithm.

These test scenarios cover various aspects of the BFS algorithm implementation, including normal operation, error handling, edge cases, and performance considerations.


*/

// ********RoostGPT********
using NUnit.Framework;
using LunarDoggo.Datastructures.Graphs;
using LunarDoggo.Algorithms.Graphs.Pathfinding;
using System;
using System.Linq;

namespace LunarDoggo.Algorithms.Graphs.Pathfinding.Test
{
    [TestFixture]
    public class RunTest
    {
        [Test, Category("valid")]
        public void RunBFSWithValidGraphAndStartVertex()
        {
            // Arrange
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);

            var bfs = new BreadthFirstSearch();

            // Act
            bfs.Run(graph, v1);

            // Assert
            Assert.That(v1.Value.Distance, Is.EqualTo(0));
            Assert.That(v2.Value.Distance, Is.EqualTo(1));
            Assert.That(v3.Value.Distance, Is.EqualTo(2));
            Assert.That(v1.Value.Predecessor, Is.Null);
            Assert.That(v2.Value.Predecessor, Is.EqualTo(v1));
            Assert.That(v3.Value.Predecessor, Is.EqualTo(v2));
        }

        [Test, Category("invalid")]
        public void RunBFSWithNullGraphThrowsArgumentNullException()
        {
            // Arrange
            var bfs = new BreadthFirstSearch();
            var startVertex = new Vertex<BFSVertex>(0, new BFSVertex());

            // Act & Assert
            Assert.Throws<ArgumentNullException>(() => bfs.Run(null, startVertex));
        }

        [Test, Category("boundary")]
        public void RunBFSWithEmptyGraph()
        {
            // Arrange
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var startVertex = new Vertex<BFSVertex>(0, new BFSVertex());
            var bfs = new BreadthFirstSearch();

            // Act & Assert
            Assert.DoesNotThrow(() => bfs.Run(graph, startVertex));
        }

        [Test, Category("valid")]
        public void RunBFSWithGraphContainingIsolatedVertices()
        {
            // Arrange
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            var v4 = graph.AddVertex(new BFSVertex()); // Isolated vertex
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);

            var bfs = new BreadthFirstSearch();

            // Act
            bfs.Run(graph, v1);

            // Assert
            Assert.That(v1.Value.Distance, Is.EqualTo(0));
            Assert.That(v2.Value.Distance, Is.EqualTo(1));
            Assert.That(v3.Value.Distance, Is.EqualTo(2));
            Assert.That(v4.Value.Distance, Is.EqualTo(int.MaxValue));
            Assert.That(v4.Value.Processed, Is.False);
        }

        [Test, Category("valid")]
        public void RunBFSOnCyclicGraph()
        {
            // Arrange
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);
            graph.AddEdge(v3, v1);

            var bfs = new BreadthFirstSearch();

            // Act
            bfs.Run(graph, v1);

            // Assert
            Assert.That(v1.Value.Distance, Is.EqualTo(0));
            Assert.That(v2.Value.Distance, Is.EqualTo(1));
            Assert.That(v3.Value.Distance, Is.EqualTo(1));
            Assert.That(v1.Value.Predecessor, Is.Null);
            Assert.That(v2.Value.Predecessor, Is.EqualTo(v1));
            Assert.That(v3.Value.Predecessor, Is.EqualTo(v1));
        }

        [Test, Category("valid")]
        public void RunBFSOnLargeGraphPerformanceTest()
        {
            // Arrange
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertices = Enumerable.Range(0, 10000).Select(_ => graph.AddVertex(new BFSVertex())).ToList();
            for (int i = 0; i < vertices.Count - 1; i++)
            {
                graph.AddEdge(vertices[i], vertices[i + 1]);
            }

            var bfs = new BreadthFirstSearch();

            // Act
            var startTime = DateTime.Now;
            bfs.Run(graph, vertices[0]);
            var endTime = DateTime.Now;

            // Assert
            var duration = (endTime - startTime).TotalSeconds;
            Assert.That(duration, Is.LessThan(5), "BFS took too long to complete");
            Assert.That(vertices.Last().Value.Distance, Is.EqualTo(9999));
        }
    }
}
