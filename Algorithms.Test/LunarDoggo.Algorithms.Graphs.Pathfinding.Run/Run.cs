// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleCSharpEnv using AI Type  and AI Model 

ROOST_METHOD_HASH=Run_bbc3b7dcfd
ROOST_METHOD_SIG_HASH=Run_23f9485d25

   ########## Test-Scenarios ##########  

Based on the provided method and context, here are several test scenarios for the BreadthFirstSearch.Run method:

Scenario 1: Null Graph Handling

Details:
  TestName: ThrowsArgumentNullExceptionWhenGraphIsNull
  Description: Verify that the method throws an ArgumentNullException when a null graph is provided.
Execution:
  Arrange: Create a BreadthFirstSearch instance and a null IGraph<BFSVertex>.
  Act: Call the Run method with the null graph and a valid start vertex.
  Assert: Expect an ArgumentNullException to be thrown.
Validation:
  This test ensures that the method properly handles null input for the graph parameter, maintaining robustness and preventing null reference exceptions later in the execution.

Scenario 2: Single Vertex Graph

Details:
  TestName: ProcessesSingleVertexGraphCorrectly
  Description: Ensure the method correctly processes a graph with only one vertex.
Execution:
  Arrange: Create a BreadthFirstSearch instance and a graph with a single vertex.
  Act: Run the BFS algorithm on this graph.
  Assert: Verify that the single vertex is processed (Processed = true) and its Distance is 0.
Validation:
  This test confirms that the algorithm works correctly for the simplest possible graph, serving as a baseline for more complex scenarios.

Scenario 3: Linear Graph Traversal

Details:
  TestName: CorrectlyTraversesLinearGraph
  Description: Verify that the BFS algorithm correctly traverses a linear graph (vertices in a line).
Execution:
  Arrange: Create a linear graph with multiple vertices connected in sequence.
  Act: Run the BFS algorithm starting from one end of the linear graph.
  Assert: Check that all vertices are processed in order, with distances increasing by 1 for each step away from the start.
Validation:
  This test ensures that the BFS algorithm correctly handles simple linear structures, assigning proper distances and processing vertices in the expected order.

Scenario 4: Branching Graph Traversal

Details:
  TestName: CorrectlyTraversesBranchingGraph
  Description: Ensure the BFS algorithm correctly traverses a graph with multiple branches.
Execution:
  Arrange: Create a graph with a root vertex that branches out to multiple paths of varying lengths.
  Act: Run the BFS algorithm starting from the root vertex.
  Assert: Verify that all vertices are processed, with correct distances assigned based on their shortest path from the root.
Validation:
  This test confirms that the BFS algorithm correctly handles more complex graph structures, ensuring it explores all branches equally before moving to the next level.

Scenario 5: Cyclic Graph Handling

Details:
  TestName: CorrectlyHandlesCyclicGraph
  Description: Verify that the BFS algorithm correctly processes a graph containing cycles without getting stuck in an infinite loop.
Execution:
  Arrange: Create a graph with at least one cycle.
  Act: Run the BFS algorithm starting from a vertex in or near the cycle.
  Assert: Check that all vertices are processed exactly once and have correct distance values.
Validation:
  This test ensures that the algorithm can handle graphs with cycles, which is crucial for its robustness and applicability to real-world graph problems.

Scenario 6: Disconnected Graph Components

Details:
  TestName: ProcessesOnlyReachableVerticesInDisconnectedGraph
  Description: Ensure that the BFS algorithm only processes vertices reachable from the start vertex in a disconnected graph.
Execution:
  Arrange: Create a graph with multiple disconnected components.
  Act: Run the BFS algorithm starting from a vertex in one of the components.
  Assert: Verify that only vertices in the same component as the start vertex are processed, while others remain unprocessed.
Validation:
  This test confirms that the algorithm respects the connectivity of the graph and doesn't artificially process unreachable vertices.

Scenario 7: Large Graph Performance

Details:
  TestName: PerformsEfficientlyOnLargeGraph
  Description: Verify that the BFS algorithm can handle a large graph within a reasonable time frame.
Execution:
  Arrange: Create a large graph with thousands of vertices and edges.
  Act: Run the BFS algorithm and measure the execution time.
  Assert: Check that the algorithm completes within an acceptable time limit and processes all vertices correctly.
Validation:
  This test ensures that the implementation is efficient and can scale to larger graph sizes without performance degradation.

These scenarios cover various aspects of the BreadthFirstSearch.Run method, including error handling, correct traversal in different graph structures, and performance considerations.


*/

// ********RoostGPT********
using NUnit.Framework;
using LunarDoggo.Datastructures.Graphs;
using LunarDoggo.Algorithms.Graphs.Pathfinding;
using System;
using System.Collections.Generic;
using System.Linq;

namespace LunarDoggo.Algorithms.Graphs.Pathfinding.Test
{
    [TestFixture]
    public class RunTest
    {
        private BreadthFirstSearch bfs;

        [SetUp]
        public void Setup()
        {
            bfs = new BreadthFirstSearch();
        }

        [Test, Category("invalid")]
        public void ThrowsArgumentNullExceptionWhenGraphIsNull()
        {
            IGraph<BFSVertex> nullGraph = null;
            Vertex<BFSVertex> startVertex = new Vertex<BFSVertex>(0, new BFSVertex());

            Assert.Throws<ArgumentNullException>(() => bfs.Run(nullGraph, startVertex));
        }

        [Test, Category("valid")]
        public void ProcessesSingleVertexGraphCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertex = graph.AddVertex(new BFSVertex());

            bfs.Run(graph, vertex);

            Assert.IsTrue(vertex.Value.Processed);
            Assert.AreEqual(0, vertex.Value.Distance);
        }

        [Test, Category("valid")]
        public void CorrectlyTraversesLinearGraph()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertices = new List<Vertex<BFSVertex>>();

            for (int i = 0; i < 5; i++)
            {
                vertices.Add(graph.AddVertex(new BFSVertex()));
                if (i > 0)
                {
                    graph.AddEdge(vertices[i - 1], vertices[i]);
                }
            }

            bfs.Run(graph, vertices[0]);

            for (int i = 0; i < 5; i++)
            {
                Assert.IsTrue(vertices[i].Value.Processed);
                Assert.AreEqual(i, vertices[i].Value.Distance);
                if (i > 0)
                {
                    Assert.AreEqual(vertices[i - 1], vertices[i].Value.Predecessor);
                }
            }
        }

        [Test, Category("valid")]
        public void CorrectlyTraversesBranchingGraph()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var root = graph.AddVertex(new BFSVertex());
            var level1 = new List<Vertex<BFSVertex>> { graph.AddVertex(new BFSVertex()), graph.AddVertex(new BFSVertex()) };
            var level2 = new List<Vertex<BFSVertex>> { graph.AddVertex(new BFSVertex()), graph.AddVertex(new BFSVertex()), graph.AddVertex(new BFSVertex()) };

            graph.AddEdge(root, level1[0]);
            graph.AddEdge(root, level1[1]);
            graph.AddEdge(level1[0], level2[0]);
            graph.AddEdge(level1[0], level2[1]);
            graph.AddEdge(level1[1], level2[2]);

            bfs.Run(graph, root);

            Assert.IsTrue(root.Value.Processed);
            Assert.AreEqual(0, root.Value.Distance);

            foreach (var vertex in level1)
            {
                Assert.IsTrue(vertex.Value.Processed);
                Assert.AreEqual(1, vertex.Value.Distance);
                Assert.AreEqual(root, vertex.Value.Predecessor);
            }

            foreach (var vertex in level2)
            {
                Assert.IsTrue(vertex.Value.Processed);
                Assert.AreEqual(2, vertex.Value.Distance);
                Assert.IsTrue(level1.Contains(vertex.Value.Predecessor));
            }
        }

        [Test, Category("valid")]
        public void CorrectlyHandlesCyclicGraph()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertices = new List<Vertex<BFSVertex>>();

            for (int i = 0; i < 4; i++)
            {
                vertices.Add(graph.AddVertex(new BFSVertex()));
            }

            graph.AddEdge(vertices[0], vertices[1]);
            graph.AddEdge(vertices[1], vertices[2]);
            graph.AddEdge(vertices[2], vertices[3]);
            graph.AddEdge(vertices[3], vertices[0]); // Creating a cycle

            bfs.Run(graph, vertices[0]);

            for (int i = 0; i < 4; i++)
            {
                Assert.IsTrue(vertices[i].Value.Processed);
                Assert.AreEqual(i > 2 ? 1 : i, vertices[i].Value.Distance);
            }
        }

        [Test, Category("valid")]
        public void ProcessesOnlyReachableVerticesInDisconnectedGraph()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var component1 = new List<Vertex<BFSVertex>> { graph.AddVertex(new BFSVertex()), graph.AddVertex(new BFSVertex()) };
            var component2 = new List<Vertex<BFSVertex>> { graph.AddVertex(new BFSVertex()), graph.AddVertex(new BFSVertex()) };

            graph.AddEdge(component1[0], component1[1]);
            graph.AddEdge(component2[0], component2[1]);

            bfs.Run(graph, component1[0]);

            foreach (var vertex in component1)
            {
                Assert.IsTrue(vertex.Value.Processed);
            }

            foreach (var vertex in component2)
            {
                Assert.IsFalse(vertex.Value.Processed);
                Assert.AreEqual(int.MaxValue, vertex.Value.Distance);
            }
        }

        [Test, Category("valid")]
        public void PerformsEfficientlyOnLargeGraph()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertices = new List<Vertex<BFSVertex>>();

            // Create a large graph
            for (int i = 0; i < 10000; i++)
            {
                vertices.Add(graph.AddVertex(new BFSVertex()));
                if (i > 0)
                {
                    graph.AddEdge(vertices[i - 1], vertices[i]);
                }
            }

            var startTime = DateTime.Now;
            bfs.Run(graph, vertices[0]);
            var endTime = DateTime.Now;

            var duration = (endTime - startTime).TotalSeconds;
            Assert.Less(duration, 5, "BFS took too long to complete");

            Assert.IsTrue(vertices.All(v => v.Value.Processed));
        }
    }
}
