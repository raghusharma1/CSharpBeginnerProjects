// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleCSharpEnv using AI Type Claude AI and AI Model claude-3-5-sonnet-20240620

ROOST_METHOD_HASH=Run_bbc3b7dcfd
ROOST_METHOD_SIG_HASH=Run_23f9485d25

   ########## Test-Scenarios ##########  

Based on the provided method and related code, I'll generate test scenarios for the `Run` method of the `BreadthFirstSearch` class. Here are the test scenarios:

Scenario 1: Null Graph Handling

Details:
  TestName: ThrowArgumentNullExceptionWhenGraphIsNull
  Description: Verify that the method throws an ArgumentNullException when a null graph is passed.
Execution:
  Arrange: Create a BreadthFirstSearch instance and set up a null graph and a valid start vertex.
  Act: Call the Run method with the null graph and valid start vertex.
  Assert: Verify that an ArgumentNullException is thrown with the correct message.
Validation:
  This test ensures that the method properly handles null input for the graph parameter, maintaining robustness and preventing null reference exceptions later in the execution.

Scenario 2: Basic BFS Traversal

Details:
  TestName: CorrectlyTraversesSimpleGraph
  Description: Ensure that the BFS algorithm correctly traverses a simple graph and sets the correct distances and predecessors.
Execution:
  Arrange: Create a simple graph with known structure, initialize a BreadthFirstSearch instance, and choose a start vertex.
  Act: Call the Run method with the created graph and start vertex.
  Assert: Verify that each vertex has the correct distance and predecessor set.
Validation:
  This test confirms that the basic BFS algorithm is working correctly, visiting vertices in the correct order and setting appropriate distances and predecessors.

Scenario 3: Isolated Vertices Handling

Details:
  TestName: CorrectlyHandlesGraphWithIsolatedVertices
  Description: Verify that the BFS algorithm correctly handles a graph with isolated vertices.
Execution:
  Arrange: Create a graph with some connected vertices and some isolated vertices, initialize a BreadthFirstSearch instance, and choose a start vertex.
  Act: Call the Run method with the created graph and start vertex.
  Assert: Check that connected vertices have correct distances and predecessors, while isolated vertices remain unprocessed.
Validation:
  This test ensures that the algorithm correctly processes connected components while leaving isolated vertices untouched, which is important for graphs that aren't fully connected.

Scenario 4: Cyclic Graph Traversal

Details:
  TestName: CorrectlyTraversesCyclicGraph
  Description: Ensure that the BFS algorithm correctly handles a graph containing cycles.
Execution:
  Arrange: Create a graph with known cycles, initialize a BreadthFirstSearch instance, and choose a start vertex.
  Act: Call the Run method with the created graph and start vertex.
  Assert: Verify that each vertex has the correct distance and predecessor set, ensuring no infinite loops occurred.
Validation:
  This test confirms that the algorithm can handle cyclic graphs without getting stuck in infinite loops, which is crucial for real-world graph structures.

Scenario 5: Large Graph Performance

Details:
  TestName: PerformsEfficientlyOnLargeGraph
  Description: Verify that the BFS algorithm performs efficiently on a large graph.
Execution:
  Arrange: Create a large graph with many vertices and edges, initialize a BreadthFirstSearch instance, and choose a start vertex.
  Act: Measure the time taken to call and complete the Run method with the large graph and start vertex.
  Assert: Verify that the execution time is within acceptable limits and that all vertices are correctly processed.
Validation:
  This test ensures that the algorithm's performance scales well with larger graphs, which is important for real-world applications dealing with substantial datasets.

Scenario 6: Start Vertex Initialization

Details:
  TestName: CorrectlyInitializesStartVertex
  Description: Ensure that the start vertex is correctly initialized with distance 0 and no predecessor.
Execution:
  Arrange: Create a graph, initialize a BreadthFirstSearch instance, and choose a start vertex.
  Act: Call the Run method with the created graph and start vertex.
  Assert: Verify that the start vertex has a distance of 0 and null predecessor.
Validation:
  This test confirms that the algorithm correctly sets up the starting point for the BFS traversal, which is crucial for the accuracy of the entire process.

These test scenarios cover various aspects of the BreadthFirstSearch.Run method, including error handling, correct traversal, handling of different graph structures, and performance considerations.


*/

// ********RoostGPT********
using NUnit.Framework;
using System;
using System.Collections.Generic;
using LunarDoggo.Datastructures.Graphs;
using LunarDoggo.Algorithms.Graphs.Pathfinding;

namespace LunarDoggo.Algorithms.Graphs.Pathfinding.Test
{
    [TestFixture]
    public class RunTest
    {
        private BreadthFirstSearch bfs;

        [SetUp]
        public void Setup()
        {
            bfs = new BreadthFirstSearch();
        }

        [Test, Category("invalid")]
        public void ThrowArgumentNullExceptionWhenGraphIsNull()
        {
            // Arrange
            IGraph<BFSVertex> graph = null;
            Vertex<BFSVertex> start = new Vertex<BFSVertex>(0, new BFSVertex());

            // Act & Assert
            Assert.Throws<ArgumentNullException>(() => bfs.Run(graph, start));
        }

        [Test, Category("valid")]
        public void CorrectlyTraversesSimpleGraph()
        {
            // Arrange
            UndirectedUnweightedGraph<BFSVertex> graph = new UndirectedUnweightedGraph<BFSVertex>();
            Vertex<BFSVertex> v1 = graph.AddVertex(new BFSVertex());
            Vertex<BFSVertex> v2 = graph.AddVertex(new BFSVertex());
            Vertex<BFSVertex> v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);

            // Act
            bfs.Run(graph, v1);

            // Assert
            Assert.AreEqual(0, v1.Value.Distance);
            Assert.AreEqual(1, v2.Value.Distance);
            Assert.AreEqual(2, v3.Value.Distance);
            Assert.IsNull(v1.Value.Predecessor);
            Assert.AreEqual(v1, v2.Value.Predecessor);
            Assert.AreEqual(v2, v3.Value.Predecessor);
        }

        [Test, Category("valid")]
        public void CorrectlyHandlesGraphWithIsolatedVertices()
        {
            // Arrange
            UndirectedUnweightedGraph<BFSVertex> graph = new UndirectedUnweightedGraph<BFSVertex>();
            Vertex<BFSVertex> v1 = graph.AddVertex(new BFSVertex());
            Vertex<BFSVertex> v2 = graph.AddVertex(new BFSVertex());
            Vertex<BFSVertex> v3 = graph.AddVertex(new BFSVertex());
            Vertex<BFSVertex> v4 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);

            // Act
            bfs.Run(graph, v1);

            // Assert
            Assert.AreEqual(0, v1.Value.Distance);
            Assert.AreEqual(1, v2.Value.Distance);
            Assert.AreEqual(int.MaxValue, v3.Value.Distance);
            Assert.AreEqual(int.MaxValue, v4.Value.Distance);
            Assert.IsNull(v1.Value.Predecessor);
            Assert.AreEqual(v1, v2.Value.Predecessor);
            Assert.IsNull(v3.Value.Predecessor);
            Assert.IsNull(v4.Value.Predecessor);
        }

        [Test, Category("valid")]
        public void CorrectlyTraversesCyclicGraph()
        {
            // Arrange
            UndirectedUnweightedGraph<BFSVertex> graph = new UndirectedUnweightedGraph<BFSVertex>();
            Vertex<BFSVertex> v1 = graph.AddVertex(new BFSVertex());
            Vertex<BFSVertex> v2 = graph.AddVertex(new BFSVertex());
            Vertex<BFSVertex> v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);
            graph.AddEdge(v3, v1);

            // Act
            bfs.Run(graph, v1);

            // Assert
            Assert.AreEqual(0, v1.Value.Distance);
            Assert.AreEqual(1, v2.Value.Distance);
            Assert.AreEqual(1, v3.Value.Distance);
            Assert.IsNull(v1.Value.Predecessor);
            Assert.AreEqual(v1, v2.Value.Predecessor);
            Assert.AreEqual(v1, v3.Value.Predecessor);
        }

        [Test, Category("valid")]
        public void PerformsEfficientlyOnLargeGraph()
        {
            // Arrange
            UndirectedUnweightedGraph<BFSVertex> graph = new UndirectedUnweightedGraph<BFSVertex>();
            int vertexCount = 10000;
            List<Vertex<BFSVertex>> vertices = new List<Vertex<BFSVertex>>();

            for (int i = 0; i < vertexCount; i++)
            {
                vertices.Add(graph.AddVertex(new BFSVertex()));
            }

            for (int i = 0; i < vertexCount - 1; i++)
            {
                graph.AddEdge(vertices[i], vertices[i + 1]);
            }

            // Act
            var startTime = DateTime.Now;
            bfs.Run(graph, vertices[0]);
            var endTime = DateTime.Now;

            // Assert
            var duration = (endTime - startTime).TotalSeconds;
            Assert.Less(duration, 5, "BFS took too long to complete");

            for (int i = 0; i < vertexCount; i++)
            {
                Assert.AreEqual(i, vertices[i].Value.Distance);
                if (i > 0)
                {
                    Assert.AreEqual(vertices[i - 1], vertices[i].Value.Predecessor);
                }
            }
        }

        [Test, Category("valid")]
        public void CorrectlyInitializesStartVertex()
        {
            // Arrange
            UndirectedUnweightedGraph<BFSVertex> graph = new UndirectedUnweightedGraph<BFSVertex>();
            Vertex<BFSVertex> start = graph.AddVertex(new BFSVertex());
            Vertex<BFSVertex> v2 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(start, v2);

            // Act
            bfs.Run(graph, start);

            // Assert
            Assert.AreEqual(0, start.Value.Distance);
            Assert.IsNull(start.Value.Predecessor);
            Assert.IsTrue(start.Value.Processed);
        }
    }
}
