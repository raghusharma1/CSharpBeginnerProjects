// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleCSharpEnv using AI Type  and AI Model 

ROOST_METHOD_HASH=Run_bbc3b7dcfd
ROOST_METHOD_SIG_HASH=Run_23f9485d25

   ########## Test-Scenarios ##########  

Based on the provided method and related code, I'll generate test scenarios for the `Run` method of the `BreadthFirstSearch` class. Here are the test scenarios:

Scenario 1: Null Graph Handling

Details:
  TestName: ThrowArgumentNullExceptionWhenGraphIsNull
  Description: Verify that the method throws an ArgumentNullException when a null graph is passed.
Execution:
  Arrange: Create a BreadthFirstSearch instance and set up a null graph and a valid start vertex.
  Act: Call the Run method with the null graph and valid start vertex.
  Assert: Expect an ArgumentNullException to be thrown.
Validation:
  This test ensures that the method properly handles null input for the graph parameter, maintaining robustness and preventing null reference exceptions later in the execution.

Scenario 2: Basic BFS Traversal

Details:
  TestName: CorrectlyTraversesSimpleGraph
  Description: Ensure that the BFS algorithm correctly traverses a simple graph and sets the correct distances and predecessors.
Execution:
  Arrange: Create a simple graph with known structure, initialize a BreadthFirstSearch instance, and choose a start vertex.
  Act: Call the Run method with the created graph and start vertex.
  Assert: Check that each vertex has the correct distance and predecessor set.
Validation:
  This test verifies that the core BFS algorithm is working correctly, visiting vertices in the correct order and setting appropriate distances and predecessors.

Scenario 3: Isolated Vertex Handling

Details:
  TestName: CorrectlyHandlesIsolatedVertices
  Description: Verify that the BFS algorithm correctly handles isolated vertices in the graph.
Execution:
  Arrange: Create a graph with some connected vertices and one or more isolated vertices. Initialize a BreadthFirstSearch instance.
  Act: Call the Run method with the graph and a start vertex from the connected portion.
  Assert: Check that isolated vertices remain unprocessed (distance should be Int32.MaxValue and predecessor should be null).
Validation:
  This test ensures that the BFS algorithm doesn't incorrectly process vertices that are not reachable from the start vertex.

Scenario 4: Cyclic Graph Traversal

Details:
  TestName: CorrectlyTraversesCyclicGraph
  Description: Ensure that the BFS algorithm correctly handles cycles in the graph without getting stuck in infinite loops.
Execution:
  Arrange: Create a graph with one or more cycles, initialize a BreadthFirstSearch instance, and choose a start vertex.
  Act: Call the Run method with the cyclic graph and start vertex.
  Assert: Verify that all vertices are processed exactly once and have correct distances and predecessors.
Validation:
  This test checks that the BFS algorithm can handle cyclic structures in the graph without issues, ensuring it doesn't revisit already processed vertices.

Scenario 5: Large Graph Performance

Details:
  TestName: PerformsEfficientlyOnLargeGraph
  Description: Verify that the BFS algorithm performs efficiently on a large graph within a reasonable time frame.
Execution:
  Arrange: Create a large graph with many vertices and edges, initialize a BreadthFirstSearch instance, and choose a start vertex.
  Act: Measure the time taken to call and complete the Run method with the large graph and start vertex.
  Assert: Check that the execution time is within an acceptable range and that all vertices are correctly processed.
Validation:
  This test ensures that the BFS implementation is efficient and scales well with larger graphs, which is crucial for real-world applications.

Scenario 6: Disconnected Graph Traversal

Details:
  TestName: CorrectlyHandlesDisconnectedGraph
  Description: Ensure that the BFS algorithm correctly processes a disconnected graph, only traversing the component containing the start vertex.
Execution:
  Arrange: Create a graph with multiple disconnected components, initialize a BreadthFirstSearch instance, and choose a start vertex in one component.
  Act: Call the Run method with the disconnected graph and start vertex.
  Assert: Verify that only vertices in the same component as the start vertex are processed, while others remain unprocessed.
Validation:
  This test checks that the BFS algorithm respects the graph's structure and doesn't incorrectly process unreachable vertices in disconnected components.

These test scenarios cover various aspects of the BreadthFirstSearch implementation, including edge cases and potential issues. They should provide good coverage for verifying the correctness and robustness of the BFS algorithm implementation.


*/

// ********RoostGPT********
using NUnit.Framework;
using LunarDoggo.Datastructures.Graphs;
using LunarDoggo.Algorithms.Graphs.Pathfinding;
using System;
using System.Collections.Generic;

namespace LunarDoggo.Algorithms.Graphs.Pathfinding.Test
{
    [TestFixture]
    public class RunTest
    {
        [Test, Category("invalid")]
        public void ThrowArgumentNullExceptionWhenGraphIsNull()
        {
            // Arrange
            var bfs = new BreadthFirstSearch();
            IGraph<BFSVertex> graph = null;
            var startVertex = new Vertex<BFSVertex>(0, new BFSVertex());

            // Act & Assert
            Assert.Throws<ArgumentNullException>(() => bfs.Run(graph, startVertex));
        }

        [Test, Category("valid")]
        public void CorrectlyTraversesSimpleGraph()
        {
            // Arrange
            var bfs = new BreadthFirstSearch();
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v0 = graph.AddVertex(new BFSVertex());
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v0, v1);
            graph.AddEdge(v1, v2);

            // Act
            bfs.Run(graph, v0);

            // Assert
            Assert.AreEqual(0, v0.Value.Distance);
            Assert.AreEqual(1, v1.Value.Distance);
            Assert.AreEqual(2, v2.Value.Distance);
            Assert.IsNull(v0.Value.Predecessor);
            Assert.AreEqual(v0, v1.Value.Predecessor);
            Assert.AreEqual(v1, v2.Value.Predecessor);
        }

        [Test, Category("valid")]
        public void CorrectlyHandlesIsolatedVertices()
        {
            // Arrange
            var bfs = new BreadthFirstSearch();
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v0 = graph.AddVertex(new BFSVertex());
            var v1 = graph.AddVertex(new BFSVertex());
            var isolated = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v0, v1);

            // Act
            bfs.Run(graph, v0);

            // Assert
            Assert.AreEqual(Int32.MaxValue, isolated.Value.Distance);
            Assert.IsNull(isolated.Value.Predecessor);
            Assert.IsFalse(isolated.Value.Processed);
        }

        [Test, Category("valid")]
        public void CorrectlyTraversesCyclicGraph()
        {
            // Arrange
            var bfs = new BreadthFirstSearch();
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v0 = graph.AddVertex(new BFSVertex());
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v0, v1);
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);
            graph.AddEdge(v3, v0);

            // Act
            bfs.Run(graph, v0);

            // Assert
            Assert.AreEqual(0, v0.Value.Distance);
            Assert.AreEqual(1, v1.Value.Distance);
            Assert.AreEqual(1, v3.Value.Distance);
            Assert.AreEqual(2, v2.Value.Distance);
            Assert.IsTrue(v0.Value.Processed);
            Assert.IsTrue(v1.Value.Processed);
            Assert.IsTrue(v2.Value.Processed);
            Assert.IsTrue(v3.Value.Processed);
        }

        [Test, Category("valid")]
        public void PerformsEfficientlyOnLargeGraph()
        {
            // Arrange
            var bfs = new BreadthFirstSearch();
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertices = new List<Vertex<BFSVertex>>();
            for (int i = 0; i < 10000; i++)
            {
                vertices.Add(graph.AddVertex(new BFSVertex()));
            }
            for (int i = 0; i < 9999; i++)
            {
                graph.AddEdge(vertices[i], vertices[i + 1]);
            }

            // Act
            var startTime = DateTime.Now;
            bfs.Run(graph, vertices[0]);
            var endTime = DateTime.Now;

            // Assert
            var duration = (endTime - startTime).TotalSeconds;
            Assert.Less(duration, 5, "BFS took too long to complete");
            Assert.AreEqual(9999, vertices[9999].Value.Distance);
            Assert.IsTrue(vertices[9999].Value.Processed);
        }

        [Test, Category("valid")]
        public void CorrectlyHandlesDisconnectedGraph()
        {
            // Arrange
            var bfs = new BreadthFirstSearch();
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v0 = graph.AddVertex(new BFSVertex());
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v0, v1);
            graph.AddEdge(v2, v3);

            // Act
            bfs.Run(graph, v0);

            // Assert
            Assert.AreEqual(0, v0.Value.Distance);
            Assert.AreEqual(1, v1.Value.Distance);
            Assert.AreEqual(Int32.MaxValue, v2.Value.Distance);
            Assert.AreEqual(Int32.MaxValue, v3.Value.Distance);
            Assert.IsTrue(v0.Value.Processed);
            Assert.IsTrue(v1.Value.Processed);
            Assert.IsFalse(v2.Value.Processed);
            Assert.IsFalse(v3.Value.Processed);
        }
    }
}
