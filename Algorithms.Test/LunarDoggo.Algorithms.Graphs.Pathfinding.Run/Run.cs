// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleCSharpEnv using AI Type  and AI Model 

ROOST_METHOD_HASH=Run_bbc3b7dcfd
ROOST_METHOD_SIG_HASH=Run_23f9485d25

   ########## Test-Scenarios ##########  

Based on the provided method and related code, here are several test scenarios for the `Run` method of the `BreadthFirstSearch` class:

Scenario 1: Null Graph Handling

Details:
  TestName: ThrowsArgumentNullExceptionWhenGraphIsNull
  Description: Verify that the method throws an ArgumentNullException when a null graph is provided.
Execution:
  Arrange: Create a BreadthFirstSearch instance and prepare a null graph and a valid start vertex.
  Act: Call the Run method with the null graph and valid start vertex.
  Assert: Expect an ArgumentNullException to be thrown.
Validation:
  This test ensures that the method properly handles null input for the graph parameter, maintaining robustness and preventing null reference exceptions later in the execution.

Scenario 2: Single Vertex Graph

Details:
  TestName: ProcessesSingleVertexGraphCorrectly
  Description: Ensure the method correctly processes a graph with only one vertex (the start vertex).
Execution:
  Arrange: Create a graph with a single vertex, set it as the start vertex, and initialize a BreadthFirstSearch instance.
  Act: Call the Run method with the graph and start vertex.
  Assert: Verify that the start vertex's distance is 0 and it has no predecessor.
Validation:
  This test confirms that the method correctly initializes and processes the simplest possible graph, setting the base case for more complex scenarios.

Scenario 3: Linear Graph Traversal

Details:
  TestName: TraversesLinearGraphCorrectly
  Description: Verify correct traversal and distance calculation in a linear graph (A -> B -> C).
Execution:
  Arrange: Create a linear graph with three vertices, set the first as the start vertex, and initialize a BreadthFirstSearch instance.
  Act: Call the Run method with the graph and start vertex.
  Assert: Check that each vertex has the correct distance (0, 1, 2) and predecessor.
Validation:
  This test ensures that the BFS algorithm correctly traverses a simple linear path, updating distances and predecessors appropriately.

Scenario 4: Branching Graph Traversal

Details:
  TestName: TraversesBranchingGraphCorrectly
  Description: Verify correct traversal and distance calculation in a branching graph (A -> B, A -> C, B -> D, C -> D).
Execution:
  Arrange: Create a branching graph, set the root as the start vertex, and initialize a BreadthFirstSearch instance.
  Act: Call the Run method with the graph and start vertex.
  Assert: Verify that all vertices have correct distances and predecessors, especially checking that D has a distance of 2.
Validation:
  This test confirms that the BFS algorithm correctly handles branching paths, ensuring it visits all vertices at a given depth before moving deeper.

Scenario 5: Cyclic Graph Handling

Details:
  TestName: HandlesCyclicGraphWithoutInfiniteLoop
  Description: Ensure the method correctly processes a graph with cycles without getting stuck in an infinite loop.
Execution:
  Arrange: Create a graph with a cycle (A -> B -> C -> A), set A as the start vertex, and initialize a BreadthFirstSearch instance.
  Act: Call the Run method with the graph and start vertex.
  Assert: Verify that all vertices are processed, have correct distances, and the method terminates.
Validation:
  This test checks that the algorithm can handle cycles in the graph without revisiting already processed vertices, which is crucial for preventing infinite loops.

Scenario 6: Disconnected Graph Components

Details:
  TestName: ProcessesOnlyReachableVerticesInDisconnectedGraph
  Description: Verify that only vertices reachable from the start vertex are processed in a disconnected graph.
Execution:
  Arrange: Create a graph with two disconnected components, set a start vertex in one component, and initialize a BreadthFirstSearch instance.
  Act: Call the Run method with the graph and start vertex.
  Assert: Check that vertices in the start vertex's component are processed (have finite distances) while vertices in the other component remain unprocessed (have max int distance).
Validation:
  This test ensures that the BFS algorithm correctly handles disconnected graphs, processing only the reachable vertices from the given start point.

Scenario 7: Large Graph Performance

Details:
  TestName: CompletesLargeGraphTraversalInReasonableTime
  Description: Ensure the method can process a large graph within a reasonable time frame.
Execution:
  Arrange: Create a large graph (e.g., 10000 vertices), set a start vertex, and initialize a BreadthFirstSearch instance.
  Act: Measure the time taken to call and complete the Run method.
  Assert: Verify that the execution completes within a specified time limit and all vertices are processed.
Validation:
  This test checks the performance and scalability of the BFS implementation, ensuring it can handle large datasets efficiently.

These scenarios cover various aspects of the BreadthFirstSearch.Run method, including error handling, correct traversal in different graph structures, cycle handling, and performance with large datasets. They aim to thoroughly test the method's functionality and robustness.


*/

// ********RoostGPT********
using NUnit.Framework;
using LunarDoggo.Datastructures.Graphs;
using LunarDoggo.Algorithms.Graphs.Pathfinding;
using System;
using System.Linq;

namespace LunarDoggo.Algorithms.Graphs.Pathfinding.Test
{
    [TestFixture]
    public class RunTest
    {
        [Test, Category("invalid")]
        public void ThrowsArgumentNullExceptionWhenGraphIsNull()
        {
            var bfs = new BreadthFirstSearch();
            var startVertex = new Vertex<BFSVertex>(0, new BFSVertex());

            Assert.Throws<ArgumentNullException>(() => bfs.Run(null, startVertex));
        }

        [Test, Category("valid")]
        public void ProcessesSingleVertexGraphCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var startVertex = graph.AddVertex(new BFSVertex());
            var bfs = new BreadthFirstSearch();

            bfs.Run(graph, startVertex);

            Assert.That(startVertex.Value.Distance, Is.EqualTo(0));
            Assert.That(startVertex.Value.Predecessor, Is.Null);
        }

        [Test, Category("valid")]
        public void TraversesLinearGraphCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertexA = graph.AddVertex(new BFSVertex());
            var vertexB = graph.AddVertex(new BFSVertex());
            var vertexC = graph.AddVertex(new BFSVertex());
            graph.AddEdge(vertexA, vertexB);
            graph.AddEdge(vertexB, vertexC);

            var bfs = new BreadthFirstSearch();
            bfs.Run(graph, vertexA);

            Assert.That(vertexA.Value.Distance, Is.EqualTo(0));
            Assert.That(vertexB.Value.Distance, Is.EqualTo(1));
            Assert.That(vertexC.Value.Distance, Is.EqualTo(2));
            Assert.That(vertexB.Value.Predecessor, Is.EqualTo(vertexA));
            Assert.That(vertexC.Value.Predecessor, Is.EqualTo(vertexB));
        }

        [Test, Category("valid")]
        public void TraversesBranchingGraphCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertexA = graph.AddVertex(new BFSVertex());
            var vertexB = graph.AddVertex(new BFSVertex());
            var vertexC = graph.AddVertex(new BFSVertex());
            var vertexD = graph.AddVertex(new BFSVertex());
            graph.AddEdge(vertexA, vertexB);
            graph.AddEdge(vertexA, vertexC);
            graph.AddEdge(vertexB, vertexD);
            graph.AddEdge(vertexC, vertexD);

            var bfs = new BreadthFirstSearch();
            bfs.Run(graph, vertexA);

            Assert.That(vertexA.Value.Distance, Is.EqualTo(0));
            Assert.That(vertexB.Value.Distance, Is.EqualTo(1));
            Assert.That(vertexC.Value.Distance, Is.EqualTo(1));
            Assert.That(vertexD.Value.Distance, Is.EqualTo(2));
            Assert.That(vertexD.Value.Predecessor, Is.AnyOf(vertexB, vertexC));
        }

        [Test, Category("valid")]
        public void HandlesCyclicGraphWithoutInfiniteLoop()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertexA = graph.AddVertex(new BFSVertex());
            var vertexB = graph.AddVertex(new BFSVertex());
            var vertexC = graph.AddVertex(new BFSVertex());
            graph.AddEdge(vertexA, vertexB);
            graph.AddEdge(vertexB, vertexC);
            graph.AddEdge(vertexC, vertexA);

            var bfs = new BreadthFirstSearch();
            bfs.Run(graph, vertexA);

            Assert.That(vertexA.Value.Distance, Is.EqualTo(0));
            Assert.That(vertexB.Value.Distance, Is.EqualTo(1));
            Assert.That(vertexC.Value.Distance, Is.EqualTo(1));
            Assert.That(vertexB.Value.Predecessor, Is.EqualTo(vertexA));
            Assert.That(vertexC.Value.Predecessor, Is.EqualTo(vertexA));
        }

        [Test, Category("valid")]
        public void ProcessesOnlyReachableVerticesInDisconnectedGraph()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertexA = graph.AddVertex(new BFSVertex());
            var vertexB = graph.AddVertex(new BFSVertex());
            var vertexC = graph.AddVertex(new BFSVertex());
            var vertexD = graph.AddVertex(new BFSVertex());
            graph.AddEdge(vertexA, vertexB);
            graph.AddEdge(vertexC, vertexD);

            var bfs = new BreadthFirstSearch();
            bfs.Run(graph, vertexA);

            Assert.That(vertexA.Value.Distance, Is.EqualTo(0));
            Assert.That(vertexB.Value.Distance, Is.EqualTo(1));
            Assert.That(vertexC.Value.Distance, Is.EqualTo(int.MaxValue));
            Assert.That(vertexD.Value.Distance, Is.EqualTo(int.MaxValue));
        }

        [Test, Category("valid")]
        public void CompletesLargeGraphTraversalInReasonableTime()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertices = Enumerable.Range(0, 10000).Select(_ => graph.AddVertex(new BFSVertex())).ToList();
            for (int i = 0; i < vertices.Count - 1; i++)
            {
                graph.AddEdge(vertices[i], vertices[i + 1]);
            }

            var bfs = new BreadthFirstSearch();
            var startTime = DateTime.Now;
            bfs.Run(graph, vertices[0]);
            var endTime = DateTime.Now;

            Assert.That((endTime - startTime).TotalSeconds, Is.LessThan(5));
            Assert.That(vertices.All(v => v.Value.Processed), Is.True);
        }
    }
}
