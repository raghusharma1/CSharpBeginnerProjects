// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleCSharpEnv using AI Type  and AI Model 

ROOST_METHOD_HASH=Run_bbc3b7dcfd
ROOST_METHOD_SIG_HASH=Run_23f9485d25

   ########## Test-Scenarios ##########  

Based on the provided method and related code, I'll generate test scenarios for the `Run` method of the `BreadthFirstSearch` class. Here are the test scenarios:

Scenario 1: Null Graph Handling

Details:
  TestName: ThrowArgumentNullExceptionWhenGraphIsNull
  Description: Verify that the method throws an ArgumentNullException when a null graph is passed.

Execution:
  Arrange: Create a BreadthFirstSearch instance and set up a null graph and a valid start vertex.
  Act: Call the Run method with the null graph and valid start vertex.
  Assert: Expect an ArgumentNullException to be thrown.

Validation:
  This test ensures that the method properly handles null input for the graph parameter, maintaining robustness and preventing null reference exceptions later in the execution.

Scenario 2: Basic BFS Traversal

Details:
  TestName: CorrectlyTraverseSimpleGraph
  Description: Verify that the BFS algorithm correctly traverses a simple graph and sets the correct distances and predecessors.

Execution:
  Arrange: Create a simple graph with known structure using UndirectedUnweightedGraph<BFSVertex>.
  Act: Run the BFS algorithm on the graph starting from a specific vertex.
  Assert: Check that each vertex has the correct distance and predecessor set.

Validation:
  This test confirms that the BFS algorithm correctly traverses the graph in breadth-first order, setting appropriate distances and predecessors for each vertex.

Scenario 3: Isolated Vertices Handling

Details:
  TestName: HandleIsolatedVerticesCorrectly
  Description: Ensure that the BFS algorithm correctly handles graphs with isolated vertices.

Execution:
  Arrange: Create a graph with some connected vertices and some isolated vertices.
  Act: Run the BFS algorithm starting from a connected vertex.
  Assert: Verify that isolated vertices remain unprocessed (distance = Int32.MaxValue, predecessor = null).

Validation:
  This test checks if the algorithm correctly leaves isolated vertices unprocessed, as they are unreachable from the starting point.

Scenario 4: Cyclic Graph Traversal

Details:
  TestName: TraverseCyclicGraphCorrectly
  Description: Verify that the BFS algorithm correctly traverses a graph containing cycles without getting stuck in an infinite loop.

Execution:
  Arrange: Create a graph with cycles using UndirectedUnweightedGraph<BFSVertex>.
  Act: Run the BFS algorithm on the cyclic graph.
  Assert: Check that all vertices are processed exactly once and have correct distances and predecessors.

Validation:
  This test ensures that the algorithm can handle cyclic graphs without revisiting vertices or getting stuck in loops.

Scenario 5: Large Graph Performance

Details:
  TestName: HandleLargeGraphEfficiently
  Description: Test the performance of the BFS algorithm on a large graph to ensure it completes within a reasonable time.

Execution:
  Arrange: Create a large graph with many vertices and edges.
  Act: Run the BFS algorithm on the large graph and measure the execution time.
  Assert: Verify that the algorithm completes within an acceptable time limit and processes all vertices correctly.

Validation:
  This test checks the efficiency and scalability of the BFS implementation for larger datasets.

Scenario 6: Start Vertex Initialization

Details:
  TestName: CorrectlyInitializeStartVertex
  Description: Verify that the start vertex is correctly initialized with distance 0 and marked as processed.

Execution:
  Arrange: Create a graph and select a start vertex.
  Act: Run the BFS algorithm.
  Assert: Check that the start vertex has a distance of 0 and is marked as processed.

Validation:
  This test ensures that the starting point of the BFS is correctly set up, which is crucial for the rest of the traversal.

Scenario 7: Empty Graph Handling

Details:
  TestName: HandleEmptyGraphGracefully
  Description: Ensure that the BFS algorithm handles an empty graph (no vertices) without errors.

Execution:
  Arrange: Create an empty UndirectedUnweightedGraph<BFSVertex>.
  Act: Run the BFS algorithm on the empty graph.
  Assert: Verify that the method completes without throwing exceptions and doesn't modify the graph.

Validation:
  This test checks the robustness of the algorithm when dealing with edge cases like empty graphs.

These test scenarios cover various aspects of the BFS algorithm implementation, including normal operation, edge cases, and error handling. They should provide good coverage for testing the `Run` method of the `BreadthFirstSearch` class.


*/

// ********RoostGPT********
using NUnit.Framework;
using LunarDoggo.Datastructures.Graphs;
using LunarDoggo.Algorithms.Graphs.Pathfinding;
using System;
using System.Linq;

namespace LunarDoggo.Algorithms.Graphs.Pathfinding.Test
{
    [TestFixture]
    public class RunTest
    {
        [Test, Category("invalid")]
        public void ThrowArgumentNullExceptionWhenGraphIsNull()
        {
            // Arrange
            BreadthFirstSearch bfs = new BreadthFirstSearch();
            IGraph<BFSVertex> graph = null;
            Vertex<BFSVertex> start = new Vertex<BFSVertex>(0, new BFSVertex());

            // Act & Assert
            Assert.Throws<ArgumentNullException>(() => bfs.Run(graph, start));
        }

        [Test, Category("valid")]
        public void CorrectlyTraverseSimpleGraph()
        {
            // Arrange
            BreadthFirstSearch bfs = new BreadthFirstSearch();
            UndirectedUnweightedGraph<BFSVertex> graph = new UndirectedUnweightedGraph<BFSVertex>();
            Vertex<BFSVertex> v1 = graph.AddVertex(new BFSVertex());
            Vertex<BFSVertex> v2 = graph.AddVertex(new BFSVertex());
            Vertex<BFSVertex> v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);

            // Act
            bfs.Run(graph, v1);

            // Assert
            Assert.AreEqual(0, v1.Value.Distance);
            Assert.AreEqual(1, v2.Value.Distance);
            Assert.AreEqual(2, v3.Value.Distance);
            Assert.IsNull(v1.Value.Predecessor);
            Assert.AreEqual(v1, v2.Value.Predecessor);
            Assert.AreEqual(v2, v3.Value.Predecessor);
        }

        [Test, Category("valid")]
        public void HandleIsolatedVerticesCorrectly()
        {
            // Arrange
            BreadthFirstSearch bfs = new BreadthFirstSearch();
            UndirectedUnweightedGraph<BFSVertex> graph = new UndirectedUnweightedGraph<BFSVertex>();
            Vertex<BFSVertex> v1 = graph.AddVertex(new BFSVertex());
            Vertex<BFSVertex> v2 = graph.AddVertex(new BFSVertex());
            Vertex<BFSVertex> isolated = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);

            // Act
            bfs.Run(graph, v1);

            // Assert
            Assert.AreEqual(Int32.MaxValue, isolated.Value.Distance);
            Assert.IsNull(isolated.Value.Predecessor);
            Assert.IsFalse(isolated.Value.Processed);
        }

        [Test, Category("valid")]
        public void TraverseCyclicGraphCorrectly()
        {
            // Arrange
            BreadthFirstSearch bfs = new BreadthFirstSearch();
            UndirectedUnweightedGraph<BFSVertex> graph = new UndirectedUnweightedGraph<BFSVertex>();
            Vertex<BFSVertex> v1 = graph.AddVertex(new BFSVertex());
            Vertex<BFSVertex> v2 = graph.AddVertex(new BFSVertex());
            Vertex<BFSVertex> v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);
            graph.AddEdge(v3, v1);

            // Act
            bfs.Run(graph, v1);

            // Assert
            Assert.AreEqual(0, v1.Value.Distance);
            Assert.AreEqual(1, v2.Value.Distance);
            Assert.AreEqual(1, v3.Value.Distance);
            Assert.IsTrue(v1.Value.Processed);
            Assert.IsTrue(v2.Value.Processed);
            Assert.IsTrue(v3.Value.Processed);
        }

        [Test, Category("valid")]
        public void HandleLargeGraphEfficiently()
        {
            // Arrange
            BreadthFirstSearch bfs = new BreadthFirstSearch();
            UndirectedUnweightedGraph<BFSVertex> graph = new UndirectedUnweightedGraph<BFSVertex>();
            int vertexCount = 10000;
            Vertex<BFSVertex>[] vertices = new Vertex<BFSVertex>[vertexCount];
            for (int i = 0; i < vertexCount; i++)
            {
                vertices[i] = graph.AddVertex(new BFSVertex());
                if (i > 0)
                {
                    graph.AddEdge(vertices[i - 1], vertices[i]);
                }
            }

            // Act
            var startTime = DateTime.Now;
            bfs.Run(graph, vertices[0]);
            var endTime = DateTime.Now;

            // Assert
            Assert.Less((endTime - startTime).TotalSeconds, 5); // Adjust time limit as needed
            Assert.IsTrue(vertices.All(v => v.Value.Processed));
            for (int i = 0; i < vertexCount; i++)
            {
                Assert.AreEqual(i, vertices[i].Value.Distance);
            }
        }

        [Test, Category("valid")]
        public void CorrectlyInitializeStartVertex()
        {
            // Arrange
            BreadthFirstSearch bfs = new BreadthFirstSearch();
            UndirectedUnweightedGraph<BFSVertex> graph = new UndirectedUnweightedGraph<BFSVertex>();
            Vertex<BFSVertex> start = graph.AddVertex(new BFSVertex());

            // Act
            bfs.Run(graph, start);

            // Assert
            Assert.AreEqual(0, start.Value.Distance);
            Assert.IsTrue(start.Value.Processed);
            Assert.IsNull(start.Value.Predecessor);
        }

        [Test, Category("boundary")]
        public void HandleEmptyGraphGracefully()
        {
            // Arrange
            BreadthFirstSearch bfs = new BreadthFirstSearch();
            UndirectedUnweightedGraph<BFSVertex> graph = new UndirectedUnweightedGraph<BFSVertex>();
            Vertex<BFSVertex> start = new Vertex<BFSVertex>(0, new BFSVertex());

            // Act & Assert
            Assert.DoesNotThrow(() => bfs.Run(graph, start));
        }
    }
}
