// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleCSharpEnv using AI Type  and AI Model 

ROOST_METHOD_HASH=Run_bbc3b7dcfd
ROOST_METHOD_SIG_HASH=Run_23f9485d25

   ########## Test-Scenarios ##########  

Based on the provided method and context, here are several test scenarios for the `Run` method of the `BreadthFirstSearch` class:

Scenario 1: Null Graph Handling

Details:
  TestName: ThrowArgumentNullExceptionWhenGraphIsNull
  Description: Verify that the method throws an ArgumentNullException when a null graph is passed.
Execution:
  Arrange: Create a BreadthFirstSearch instance and set up a null graph and a valid start vertex.
  Act: Call the Run method with the null graph and valid start vertex.
  Assert: Expect an ArgumentNullException to be thrown.
Validation:
  This test ensures that the method properly handles null input for the graph parameter, maintaining robustness and preventing null reference exceptions later in the execution.

Scenario 2: Single Vertex Graph

Details:
  TestName: ProcessSingleVertexGraphCorrectly
  Description: Ensure the method correctly processes a graph with only one vertex.
Execution:
  Arrange: Create a graph with a single vertex and set it as the start vertex.
  Act: Run the BFS algorithm on this graph.
  Assert: Verify that the single vertex is processed (Processed = true) and its Distance is 0.
Validation:
  This test confirms that the BFS algorithm works correctly for the simplest possible graph, setting a baseline for more complex scenarios.

Scenario 3: Linear Graph Traversal

Details:
  TestName: TraverseLinearGraphCorrectly
  Description: Check if the BFS algorithm correctly traverses a linear graph (each vertex connected to at most two others).
Execution:
  Arrange: Create a linear graph with multiple vertices (e.g., A -> B -> C -> D).
  Act: Run the BFS algorithm starting from vertex A.
  Assert: Verify that all vertices are processed and their distances are set correctly (A:0, B:1, C:2, D:3).
Validation:
  This scenario tests the basic functionality of the BFS algorithm in a simple, predictable graph structure.

Scenario 4: Cyclic Graph Handling

Details:
  TestName: HandleCyclicGraphWithoutInfiniteLoop
  Description: Ensure the BFS algorithm correctly handles a graph with cycles without getting stuck in an infinite loop.
Execution:
  Arrange: Create a graph with a cycle (e.g., A -> B -> C -> A).
  Act: Run the BFS algorithm starting from any vertex.
  Assert: Verify that all vertices are processed exactly once and have correct distances.
Validation:
  This test checks if the algorithm can handle cycles in the graph, which is crucial for its correctness and termination.

Scenario 5: Disconnected Graph Components

Details:
  TestName: ProcessOnlyReachableVerticesInDisconnectedGraph
  Description: Verify that the BFS algorithm only processes vertices reachable from the start vertex in a disconnected graph.
Execution:
  Arrange: Create a graph with two disconnected components (e.g., A -> B, C -> D).
  Act: Run the BFS algorithm starting from vertex A.
  Assert: Check that A and B are processed and have distances set, while C and D remain unprocessed with maximum distance.
Validation:
  This scenario ensures that the algorithm correctly handles disconnected graphs, processing only the reachable portion.

Scenario 6: Large Graph Performance

Details:
  TestName: CompleteTraversalOfLargeGraphWithinReasonableTime
  Description: Test the performance of the BFS algorithm on a large graph to ensure it completes within a reasonable time frame.
Execution:
  Arrange: Create a large graph with many vertices and edges (e.g., 10000 vertices).
  Act: Run the BFS algorithm and measure the execution time.
  Assert: Verify that the algorithm completes within a specified time limit and all vertices are processed.
Validation:
  This test checks the efficiency and scalability of the BFS implementation for large datasets.

Scenario 7: Correct Predecessor Assignment

Details:
  TestName: AssignCorrectPredecessorsInComplexGraph
  Description: Ensure that the BFS algorithm correctly assigns predecessors to vertices in a complex graph structure.
Execution:
  Arrange: Create a graph with multiple paths between vertices (e.g., A -> B -> D, A -> C -> D).
  Act: Run the BFS algorithm starting from vertex A.
  Assert: Verify that each vertex (except the start vertex) has a correct predecessor assigned based on the shortest path.
Validation:
  This test confirms that the algorithm correctly builds the breadth-first tree, which is crucial for path reconstruction and other applications of BFS.

These test scenarios cover various aspects of the BreadthFirstSearch algorithm, including edge cases, error handling, and performance considerations. They aim to ensure the correctness and robustness of the implementation across different graph structures and sizes.


*/

// ********RoostGPT********
using NUnit.Framework;
using LunarDoggo.Datastructures.Graphs;
using LunarDoggo.Algorithms.Graphs.Pathfinding;
using System;
using System.Linq;

namespace LunarDoggo.Algorithms.Graphs.Pathfinding.Test
{
    [TestFixture]
    public class RunTest
    {
        [Test, Category("invalid")]
        public void ThrowArgumentNullExceptionWhenGraphIsNull()
        {
            var bfs = new BreadthFirstSearch();
            var startVertex = new Vertex<BFSVertex>(0, new BFSVertex());

            Assert.Throws<ArgumentNullException>(() => bfs.Run(null, startVertex));
        }

        [Test, Category("valid")]
        public void ProcessSingleVertexGraphCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertex = graph.AddVertex(new BFSVertex());
            var bfs = new BreadthFirstSearch();

            bfs.Run(graph, vertex);

            Assert.IsTrue(vertex.Value.Processed);
            Assert.AreEqual(0, vertex.Value.Distance);
        }

        [Test, Category("valid")]
        public void TraverseLinearGraphCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertexA = graph.AddVertex(new BFSVertex());
            var vertexB = graph.AddVertex(new BFSVertex());
            var vertexC = graph.AddVertex(new BFSVertex());
            var vertexD = graph.AddVertex(new BFSVertex());

            graph.AddEdge(vertexA, vertexB);
            graph.AddEdge(vertexB, vertexC);
            graph.AddEdge(vertexC, vertexD);

            var bfs = new BreadthFirstSearch();
            bfs.Run(graph, vertexA);

            Assert.IsTrue(vertexA.Value.Processed);
            Assert.IsTrue(vertexB.Value.Processed);
            Assert.IsTrue(vertexC.Value.Processed);
            Assert.IsTrue(vertexD.Value.Processed);

            Assert.AreEqual(0, vertexA.Value.Distance);
            Assert.AreEqual(1, vertexB.Value.Distance);
            Assert.AreEqual(2, vertexC.Value.Distance);
            Assert.AreEqual(3, vertexD.Value.Distance);
        }

        [Test, Category("valid")]
        public void HandleCyclicGraphWithoutInfiniteLoop()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertexA = graph.AddVertex(new BFSVertex());
            var vertexB = graph.AddVertex(new BFSVertex());
            var vertexC = graph.AddVertex(new BFSVertex());

            graph.AddEdge(vertexA, vertexB);
            graph.AddEdge(vertexB, vertexC);
            graph.AddEdge(vertexC, vertexA);

            var bfs = new BreadthFirstSearch();
            bfs.Run(graph, vertexA);

            Assert.IsTrue(vertexA.Value.Processed);
            Assert.IsTrue(vertexB.Value.Processed);
            Assert.IsTrue(vertexC.Value.Processed);

            Assert.AreEqual(0, vertexA.Value.Distance);
            Assert.AreEqual(1, vertexB.Value.Distance);
            Assert.AreEqual(1, vertexC.Value.Distance);
        }

        [Test, Category("valid")]
        public void ProcessOnlyReachableVerticesInDisconnectedGraph()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertexA = graph.AddVertex(new BFSVertex());
            var vertexB = graph.AddVertex(new BFSVertex());
            var vertexC = graph.AddVertex(new BFSVertex());
            var vertexD = graph.AddVertex(new BFSVertex());

            graph.AddEdge(vertexA, vertexB);
            graph.AddEdge(vertexC, vertexD);

            var bfs = new BreadthFirstSearch();
            bfs.Run(graph, vertexA);

            Assert.IsTrue(vertexA.Value.Processed);
            Assert.IsTrue(vertexB.Value.Processed);
            Assert.IsFalse(vertexC.Value.Processed);
            Assert.IsFalse(vertexD.Value.Processed);

            Assert.AreEqual(0, vertexA.Value.Distance);
            Assert.AreEqual(1, vertexB.Value.Distance);
            Assert.AreEqual(int.MaxValue, vertexC.Value.Distance);
            Assert.AreEqual(int.MaxValue, vertexD.Value.Distance);
        }

        [Test, Category("valid")]
        public void CompleteTraversalOfLargeGraphWithinReasonableTime()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertices = Enumerable.Range(0, 10000).Select(_ => graph.AddVertex(new BFSVertex())).ToList();

            for (int i = 0; i < vertices.Count - 1; i++)
            {
                graph.AddEdge(vertices[i], vertices[i + 1]);
            }

            var bfs = new BreadthFirstSearch();
            var startTime = DateTime.Now;
            bfs.Run(graph, vertices[0]);
            var endTime = DateTime.Now;

            Assert.Less((endTime - startTime).TotalSeconds, 5); // Assuming 5 seconds is a reasonable time limit
            Assert.IsTrue(vertices.All(v => v.Value.Processed));
        }

        [Test, Category("valid")]
        public void AssignCorrectPredecessorsInComplexGraph()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertexA = graph.AddVertex(new BFSVertex());
            var vertexB = graph.AddVertex(new BFSVertex());
            var vertexC = graph.AddVertex(new BFSVertex());
            var vertexD = graph.AddVertex(new BFSVertex());

            graph.AddEdge(vertexA, vertexB);
            graph.AddEdge(vertexA, vertexC);
            graph.AddEdge(vertexB, vertexD);
            graph.AddEdge(vertexC, vertexD);

            var bfs = new BreadthFirstSearch();
            bfs.Run(graph, vertexA);

            Assert.AreEqual(null, vertexA.Value.Predecessor);
            Assert.AreEqual(vertexA, vertexB.Value.Predecessor);
            Assert.AreEqual(vertexA, vertexC.Value.Predecessor);
            Assert.AreEqual(vertexB, vertexD.Value.Predecessor); // Assuming BFS processes B before C
        }
    }
}
