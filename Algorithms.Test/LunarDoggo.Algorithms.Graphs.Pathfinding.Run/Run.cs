// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleCSharpEnv using AI Type  and AI Model 

ROOST_METHOD_HASH=Run_bbc3b7dcfd
ROOST_METHOD_SIG_HASH=Run_23f9485d25

   ########## Test-Scenarios ##########  

Based on the provided method and context, here are several test scenarios for the `Run` method of the `BreadthFirstSearch` class:

Scenario 1: Null Graph Handling

Details:
  TestName: ThrowsArgumentNullExceptionWhenGraphIsNull
  Description: Verify that the method throws an ArgumentNullException when a null graph is passed.
Execution:
  Arrange: Create a BreadthFirstSearch instance and set up a null graph and a valid start vertex.
  Act: Call the Run method with the null graph and valid start vertex.
  Assert: Expect an ArgumentNullException to be thrown.
Validation:
  This test ensures that the method properly handles null input for the graph parameter, maintaining robustness and preventing null reference exceptions later in the execution.

Scenario 2: Basic BFS Traversal

Details:
  TestName: CorrectlyTraversesSimpleGraph
  Description: Ensure that the BFS algorithm correctly traverses a simple graph and sets the correct distances and predecessors.
Execution:
  Arrange: Create a simple graph with known structure (e.g., a small tree or a simple connected graph).
  Act: Run the BFS algorithm on this graph starting from a specific vertex.
  Assert: Check that all vertices have been processed, and their distances and predecessors are set correctly.
Validation:
  This test verifies the core functionality of the BFS algorithm, ensuring it correctly explores the graph level by level and sets the appropriate metadata for each vertex.

Scenario 3: Disconnected Graph Handling

Details:
  TestName: HandlesDisconnectedGraphCorrectly
  Description: Verify that the BFS algorithm correctly handles a disconnected graph, only processing reachable vertices.
Execution:
  Arrange: Create a graph with multiple disconnected components.
  Act: Run the BFS algorithm starting from a vertex in one of the components.
  Assert: Verify that only vertices in the same component as the start vertex are processed, while others remain unprocessed.
Validation:
  This test ensures that the BFS algorithm doesn't erroneously process unreachable parts of a disconnected graph, maintaining the correct behavior for partial graph traversal.

Scenario 4: Single Vertex Graph

Details:
  TestName: CorrectlyProcessesSingleVertexGraph
  Description: Ensure that the BFS algorithm correctly handles a graph with only one vertex.
Execution:
  Arrange: Create a graph with a single vertex.
  Act: Run the BFS algorithm on this single-vertex graph.
  Assert: Verify that the vertex is processed, has a distance of 0, and no predecessor.
Validation:
  This edge case test confirms that the algorithm behaves correctly for the simplest possible graph, ensuring no assumptions are made about minimum graph size.

Scenario 5: Cyclic Graph Traversal

Details:
  TestName: CorrectlyTraversesCyclicGraph
  Description: Verify that the BFS algorithm correctly handles a graph containing cycles without getting stuck in infinite loops.
Execution:
  Arrange: Create a graph with known cycles.
  Act: Run the BFS algorithm on the cyclic graph.
  Assert: Check that all vertices are processed exactly once, with correct distances and predecessors set.
Validation:
  This test ensures that the algorithm can handle more complex graph structures with cycles, a common scenario in real-world graph problems.

Scenario 6: Large Graph Performance

Details:
  TestName: CompletesLargeGraphTraversalInReasonableTime
  Description: Ensure that the BFS algorithm can handle a large graph within an acceptable time frame.
Execution:
  Arrange: Create a large graph with many vertices and edges.
  Act: Run the BFS algorithm on the large graph, measuring the execution time.
  Assert: Verify that the algorithm completes within a predefined time limit and correctly processes all vertices.
Validation:
  This performance test checks the scalability of the BFS implementation, ensuring it can handle larger datasets efficiently.

Scenario 7: Preservation of Original Graph Structure

Details:
  TestName: PreservesOriginalGraphStructure
  Description: Verify that the BFS algorithm does not modify the original structure of the input graph.
Execution:
  Arrange: Create a graph and make a deep copy of its structure.
  Act: Run the BFS algorithm on the original graph.
  Assert: Compare the original graph's structure (vertices and edges) with the copied structure to ensure they are identical.
Validation:
  This test ensures that the BFS algorithm is non-destructive and only modifies the BFSVertex values associated with each vertex, not the graph structure itself.

These test scenarios cover various aspects of the BreadthFirstSearch.Run method, including normal operation, edge cases, error handling, and performance considerations.


*/

// ********RoostGPT********
using NUnit.Framework;
using LunarDoggo.Datastructures.Graphs;
using LunarDoggo.Algorithms.Graphs.Pathfinding;
using System;
using System.Collections.Generic;
using System.Linq;

namespace LunarDoggo.Algorithms.Graphs.Pathfinding.Test
{
    [TestFixture]
    public class RunTest
    {
        private BreadthFirstSearch bfs;

        [SetUp]
        public void Setup()
        {
            bfs = new BreadthFirstSearch();
        }

        [Test, Category("invalid")]
        public void ThrowsArgumentNullExceptionWhenGraphIsNull()
        {
            var startVertex = new Vertex<BFSVertex>(0, new BFSVertex());
            Assert.Throws<ArgumentNullException>(() => bfs.Run(null, startVertex));
        }

        [Test, Category("valid")]
        public void CorrectlyTraversesSimpleGraph()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);

            bfs.Run(graph, v1);

            Assert.That(v1.Value.Distance, Is.EqualTo(0));
            Assert.That(v2.Value.Distance, Is.EqualTo(1));
            Assert.That(v3.Value.Distance, Is.EqualTo(2));
            Assert.That(v1.Value.Predecessor, Is.Null);
            Assert.That(v2.Value.Predecessor, Is.EqualTo(v1));
            Assert.That(v3.Value.Predecessor, Is.EqualTo(v2));
        }

        [Test, Category("valid")]
        public void HandlesDisconnectedGraphCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);

            bfs.Run(graph, v1);

            Assert.That(v1.Value.Processed, Is.True);
            Assert.That(v2.Value.Processed, Is.True);
            Assert.That(v3.Value.Processed, Is.False);
            Assert.That(v3.Value.Distance, Is.EqualTo(int.MaxValue));
        }

        [Test, Category("boundary")]
        public void CorrectlyProcessesSingleVertexGraph()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());

            bfs.Run(graph, v1);

            Assert.That(v1.Value.Distance, Is.EqualTo(0));
            Assert.That(v1.Value.Predecessor, Is.Null);
            Assert.That(v1.Value.Processed, Is.True);
        }

        [Test, Category("valid")]
        public void CorrectlyTraversesCyclicGraph()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);
            graph.AddEdge(v3, v1);

            bfs.Run(graph, v1);

            Assert.That(v1.Value.Distance, Is.EqualTo(0));
            Assert.That(v2.Value.Distance, Is.EqualTo(1));
            Assert.That(v3.Value.Distance, Is.EqualTo(1));
            Assert.That(v1.Value.Predecessor, Is.Null);
            Assert.That(v2.Value.Predecessor, Is.EqualTo(v1));
            Assert.That(v3.Value.Predecessor, Is.EqualTo(v1));
        }

        [Test, Category("valid")]
        public void CompletesLargeGraphTraversalInReasonableTime()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertices = new List<Vertex<BFSVertex>>();
            for (int i = 0; i < 10000; i++)
            {
                vertices.Add(graph.AddVertex(new BFSVertex()));
            }
            for (int i = 0; i < 9999; i++)
            {
                graph.AddEdge(vertices[i], vertices[i + 1]);
            }

            var startTime = DateTime.Now;
            bfs.Run(graph, vertices[0]);
            var endTime = DateTime.Now;

            Assert.That((endTime - startTime).TotalSeconds, Is.LessThan(5));
            Assert.That(vertices.All(v => v.Value.Processed), Is.True);
        }

        [Test, Category("valid")]
        public void PreservesOriginalGraphStructure()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);

            var originalVertices = graph.Vertices.ToList();
            var originalEdges = graph.Edges.ToList();

            bfs.Run(graph, v1);

            Assert.That(graph.Vertices, Is.EquivalentTo(originalVertices));
            Assert.That(graph.Edges, Is.EquivalentTo(originalEdges));
        }
    }
}
