// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleCSharpEnv using AI Type  and AI Model 

ROOST_METHOD_HASH=Run_bbc3b7dcfd
ROOST_METHOD_SIG_HASH=Run_23f9485d25

   ########## Test-Scenarios ##########  

Based on the provided method and context, here are several test scenarios for the `Run` method of the `BreadthFirstSearch` class:

Scenario 1: Null Graph Handling

Details:
  TestName: ThrowArgumentNullExceptionWhenGraphIsNull
  Description: Verify that the method throws an ArgumentNullException when a null graph is passed.
Execution:
  Arrange: Create a BreadthFirstSearch instance and set up a null graph and a valid start vertex.
  Act: Call the Run method with the null graph and valid start vertex.
  Assert: Expect an ArgumentNullException to be thrown.
Validation:
  This test ensures that the method properly handles null input for the graph parameter, maintaining robustness and preventing null reference exceptions later in the execution.

Scenario 2: Single Vertex Graph

Details:
  TestName: ProcessSingleVertexGraphCorrectly
  Description: Ensure the method correctly processes a graph with only one vertex.
Execution:
  Arrange: Create a graph with a single vertex and set it as the start vertex.
  Act: Run the BFS algorithm on this graph.
  Assert: Verify that the single vertex is processed (Processed = true) and its Distance is 0.
Validation:
  This test confirms that the BFS algorithm works correctly for the simplest possible graph, setting a baseline for more complex scenarios.

Scenario 3: Linear Graph Traversal

Details:
  TestName: TraverseLinearGraphCorrectly
  Description: Check if the BFS algorithm correctly traverses a linear graph (each vertex connected to at most two others).
Execution:
  Arrange: Create a linear graph with multiple vertices (e.g., A -> B -> C -> D).
  Act: Run the BFS algorithm starting from vertex A.
  Assert: Verify that all vertices are processed and their distances are set correctly (0 for A, 1 for B, 2 for C, 3 for D).
Validation:
  This test ensures that the BFS algorithm correctly calculates distances and processes vertices in a simple linear structure.

Scenario 4: Cyclic Graph Handling

Details:
  TestName: HandleCyclicGraphWithoutInfiniteLoop
  Description: Verify that the BFS algorithm correctly handles a graph with cycles without getting stuck in an infinite loop.
Execution:
  Arrange: Create a cyclic graph (e.g., A -> B -> C -> A).
  Act: Run the BFS algorithm starting from any vertex.
  Assert: Check that all vertices are processed exactly once and have correct distances set.
Validation:
  This test confirms that the algorithm can handle cycles in the graph without revisiting already processed vertices.

Scenario 5: Disconnected Graph Components

Details:
  TestName: ProcessOnlyReachableVerticesInDisconnectedGraph
  Description: Ensure that only vertices reachable from the start vertex are processed in a disconnected graph.
Execution:
  Arrange: Create a graph with two disconnected components (e.g., A -> B, C -> D).
  Act: Run the BFS algorithm starting from vertex A.
  Assert: Verify that A and B are processed and have distances set, while C and D remain unprocessed with maximum distance.
Validation:
  This test checks that the BFS algorithm correctly handles disconnected graphs by only processing reachable vertices.

Scenario 6: Correct Predecessor Assignment

Details:
  TestName: AssignPredecessorsCorrectlyDuringTraversal
  Description: Verify that each processed vertex (except the start vertex) is assigned the correct predecessor.
Execution:
  Arrange: Create a graph with multiple paths (e.g., A -> B -> D, A -> C -> D).
  Act: Run the BFS algorithm starting from vertex A.
  Assert: Check that B's predecessor is A, C's predecessor is A, and D's predecessor is either B or C (whichever was processed first).
Validation:
  This test ensures that the predecessor assignment logic works correctly, which is crucial for path reconstruction in BFS applications.

Scenario 7: Large Graph Performance

Details:
  TestName: ProcessLargeGraphWithinReasonableTime
  Description: Ensure the BFS algorithm can handle a large graph without excessive time consumption.
Execution:
  Arrange: Create a large graph with thousands of vertices and edges.
  Act: Run the BFS algorithm and measure the execution time.
  Assert: Verify that the algorithm completes within a reasonable time frame and processes all vertices.
Validation:
  This test checks the performance and scalability of the BFS implementation for large datasets.

These test scenarios cover various aspects of the BreadthFirstSearch.Run method, including error handling, correct traversal in different graph structures, cycle handling, disconnected components, predecessor assignment, and performance with large graphs. They aim to ensure the robustness and correctness of the BFS implementation across different scenarios.


*/

// ********RoostGPT********
using NUnit.Framework;
using LunarDoggo.Datastructures.Graphs;
using LunarDoggo.Algorithms.Graphs.Pathfinding;
using System;
using System.Linq;

namespace LunarDoggo.Algorithms.Graphs.Pathfinding.Test
{
    [TestFixture]
    public class RunTest
    {
        private BreadthFirstSearch bfs;

        [SetUp]
        public void Setup()
        {
            bfs = new BreadthFirstSearch();
        }

        [Test, Category("invalid")]
        public void ThrowArgumentNullExceptionWhenGraphIsNull()
        {
            var start = new Vertex<BFSVertex>(0, new BFSVertex());
            Assert.Throws<ArgumentNullException>(() => bfs.Run(null, start));
        }

        [Test, Category("valid")]
        public void ProcessSingleVertexGraphCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertex = graph.AddVertex(new BFSVertex());

            bfs.Run(graph, vertex);

            Assert.IsTrue(vertex.Value.Processed);
            Assert.AreEqual(0, vertex.Value.Distance);
        }

        [Test, Category("valid")]
        public void TraverseLinearGraphCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var a = graph.AddVertex(new BFSVertex());
            var b = graph.AddVertex(new BFSVertex());
            var c = graph.AddVertex(new BFSVertex());
            var d = graph.AddVertex(new BFSVertex());

            graph.AddEdge(a, b);
            graph.AddEdge(b, c);
            graph.AddEdge(c, d);

            bfs.Run(graph, a);

            Assert.AreEqual(0, a.Value.Distance);
            Assert.AreEqual(1, b.Value.Distance);
            Assert.AreEqual(2, c.Value.Distance);
            Assert.AreEqual(3, d.Value.Distance);
            Assert.IsTrue(graph.Vertices.All(v => v.Value.Processed));
        }

        [Test, Category("valid")]
        public void HandleCyclicGraphWithoutInfiniteLoop()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var a = graph.AddVertex(new BFSVertex());
            var b = graph.AddVertex(new BFSVertex());
            var c = graph.AddVertex(new BFSVertex());

            graph.AddEdge(a, b);
            graph.AddEdge(b, c);
            graph.AddEdge(c, a);

            bfs.Run(graph, a);

            Assert.IsTrue(graph.Vertices.All(v => v.Value.Processed));
            Assert.AreEqual(0, a.Value.Distance);
            Assert.AreEqual(1, b.Value.Distance);
            Assert.AreEqual(1, c.Value.Distance);
        }

        [Test, Category("valid")]
        public void ProcessOnlyReachableVerticesInDisconnectedGraph()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var a = graph.AddVertex(new BFSVertex());
            var b = graph.AddVertex(new BFSVertex());
            var c = graph.AddVertex(new BFSVertex());
            var d = graph.AddVertex(new BFSVertex());

            graph.AddEdge(a, b);
            graph.AddEdge(c, d);

            bfs.Run(graph, a);

            Assert.IsTrue(a.Value.Processed);
            Assert.IsTrue(b.Value.Processed);
            Assert.IsFalse(c.Value.Processed);
            Assert.IsFalse(d.Value.Processed);
            Assert.AreEqual(0, a.Value.Distance);
            Assert.AreEqual(1, b.Value.Distance);
            Assert.AreEqual(int.MaxValue, c.Value.Distance);
            Assert.AreEqual(int.MaxValue, d.Value.Distance);
        }

        [Test, Category("valid")]
        public void AssignPredecessorsCorrectlyDuringTraversal()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var a = graph.AddVertex(new BFSVertex());
            var b = graph.AddVertex(new BFSVertex());
            var c = graph.AddVertex(new BFSVertex());
            var d = graph.AddVertex(new BFSVertex());

            graph.AddEdge(a, b);
            graph.AddEdge(a, c);
            graph.AddEdge(b, d);
            graph.AddEdge(c, d);

            bfs.Run(graph, a);

            Assert.AreEqual(null, a.Value.Predecessor);
            Assert.AreEqual(a, b.Value.Predecessor);
            Assert.AreEqual(a, c.Value.Predecessor);
            Assert.IsTrue(d.Value.Predecessor == b || d.Value.Predecessor == c);
        }

        [Test, Category("integration")]
        public void ProcessLargeGraphWithinReasonableTime()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertices = Enumerable.Range(0, 10000).Select(_ => graph.AddVertex(new BFSVertex())).ToList();

            for (int i = 0; i < vertices.Count - 1; i++)
            {
                graph.AddEdge(vertices[i], vertices[i + 1]);
            }

            var startTime = DateTime.Now;
            bfs.Run(graph, vertices[0]);
            var endTime = DateTime.Now;

            Assert.Less((endTime - startTime).TotalSeconds, 5);
            Assert.IsTrue(graph.Vertices.All(v => v.Value.Processed));
        }
    }
}
