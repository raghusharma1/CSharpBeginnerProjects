// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleCSharpEnv using AI Type  and AI Model 

ROOST_METHOD_HASH=Run_bbc3b7dcfd
ROOST_METHOD_SIG_HASH=Run_23f9485d25

   ########## Test-Scenarios ##########  

Based on the provided method and context, here are several test scenarios for the `Run` method of the `BreadthFirstSearch` class:

Scenario 1: Null Graph Handling

Details:
  TestName: ThrowsArgumentNullExceptionWhenGraphIsNull
  Description: Verify that the method throws an ArgumentNullException when a null graph is passed.
Execution:
  Arrange: Create a BreadthFirstSearch instance and set up a null graph and a valid start vertex.
  Act: Call the Run method with the null graph and valid start vertex.
  Assert: Expect an ArgumentNullException to be thrown.
Validation:
  This test ensures that the method properly handles null input for the graph parameter, maintaining robustness and preventing null reference exceptions later in the execution.

Scenario 2: Basic BFS Traversal

Details:
  TestName: CorrectlyTraversesSimpleGraph
  Description: Ensure that the BFS algorithm correctly traverses a simple graph and sets the correct distances and predecessors.
Execution:
  Arrange: Create a simple graph with known structure (e.g., a small tree or a simple connected graph).
  Act: Run the BFS algorithm on this graph starting from a specific vertex.
  Assert: Check that all vertices have been processed, and their distances and predecessors are set correctly.
Validation:
  This test verifies the core functionality of the BFS algorithm, ensuring it correctly explores the graph level by level and sets the appropriate metadata for each vertex.

Scenario 3: Disconnected Graph Handling

Details:
  TestName: HandlesDisconnectedGraphCorrectly
  Description: Verify that the BFS algorithm correctly handles a disconnected graph, only processing the connected component of the start vertex.
Execution:
  Arrange: Create a graph with multiple disconnected components.
  Act: Run the BFS algorithm starting from a vertex in one of the components.
  Assert: Check that only vertices in the same component as the start vertex are processed, while others remain unprocessed.
Validation:
  This test ensures that the BFS algorithm respects graph connectivity and doesn't incorrectly process unreachable vertices.

Scenario 4: Single Vertex Graph

Details:
  TestName: CorrectlyHandlesSingleVertexGraph
  Description: Ensure the BFS algorithm works correctly on a graph containing only one vertex.
Execution:
  Arrange: Create a graph with a single vertex.
  Act: Run the BFS algorithm on this single-vertex graph.
  Assert: Verify that the vertex is processed, has a distance of 0, and no predecessor.
Validation:
  This edge case test confirms that the algorithm behaves correctly in the simplest possible scenario, which is important for robustness.

Scenario 5: Cyclic Graph Traversal

Details:
  TestName: CorrectlyTraversesCyclicGraph
  Description: Verify that the BFS algorithm correctly handles graphs with cycles without getting stuck in infinite loops.
Execution:
  Arrange: Create a graph with one or more cycles.
  Act: Run the BFS algorithm on this cyclic graph.
  Assert: Check that all vertices are processed exactly once, with correct distances and predecessors.
Validation:
  This test ensures that the algorithm can handle more complex graph structures without issues, which is crucial for its general applicability.

Scenario 6: Large Graph Performance

Details:
  TestName: CompletesLargeGraphTraversalInReasonableTime
  Description: Ensure that the BFS algorithm can handle large graphs efficiently.
Execution:
  Arrange: Create a large graph with many vertices and edges.
  Act: Run the BFS algorithm on this large graph, measuring the execution time.
  Assert: Verify that the algorithm completes within a reasonable time frame and processes all vertices correctly.
Validation:
  This performance test checks the scalability of the implementation, which is important for real-world usage with potentially large datasets.

Scenario 7: Preservation of Original Graph Structure

Details:
  TestName: PreservesOriginalGraphStructure
  Description: Ensure that the BFS algorithm doesn't modify the original structure of the graph.
Execution:
  Arrange: Create a graph and make a deep copy of its structure.
  Act: Run the BFS algorithm on the original graph.
  Assert: Compare the original graph's structure (vertices and edges) with the copy to ensure no modifications were made.
Validation:
  This test verifies that the algorithm is non-destructive, which is important for maintaining data integrity when the same graph might be used for multiple operations.

These test scenarios cover various aspects of the BFS algorithm implementation, including normal operation, edge cases, error handling, and performance considerations.


*/

// ********RoostGPT********
using NUnit.Framework;
using LunarDoggo.Datastructures.Graphs;
using LunarDoggo.Algorithms.Graphs.Pathfinding;
using System;
using System.Collections.Generic;
using System.Linq;

namespace LunarDoggo.Algorithms.Graphs.Pathfinding.Test
{
    [TestFixture]
    public class RunTest
    {
        private BreadthFirstSearch bfs;

        [SetUp]
        public void Setup()
        {
            bfs = new BreadthFirstSearch();
        }

        [Test, Category("invalid")]
        public void ThrowsArgumentNullExceptionWhenGraphIsNull()
        {
            // Arrange
            IGraph<BFSVertex> nullGraph = null;
            Vertex<BFSVertex> startVertex = new Vertex<BFSVertex>(0, new BFSVertex());

            // Act & Assert
            Assert.Throws<ArgumentNullException>(() => bfs.Run(nullGraph, startVertex));
        }

        [Test, Category("valid")]
        public void CorrectlyTraversesSimpleGraph()
        {
            // Arrange
            UndirectedUnweightedGraph<BFSVertex> graph = new UndirectedUnweightedGraph<BFSVertex>();
            Vertex<BFSVertex> v1 = graph.AddVertex(new BFSVertex());
            Vertex<BFSVertex> v2 = graph.AddVertex(new BFSVertex());
            Vertex<BFSVertex> v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);

            // Act
            bfs.Run(graph, v1);

            // Assert
            Assert.That(v1.Value.Distance, Is.EqualTo(0));
            Assert.That(v2.Value.Distance, Is.EqualTo(1));
            Assert.That(v3.Value.Distance, Is.EqualTo(2));
            Assert.That(v1.Value.Predecessor, Is.Null);
            Assert.That(v2.Value.Predecessor, Is.EqualTo(v1));
            Assert.That(v3.Value.Predecessor, Is.EqualTo(v2));
        }

        [Test, Category("valid")]
        public void HandlesDisconnectedGraphCorrectly()
        {
            // Arrange
            UndirectedUnweightedGraph<BFSVertex> graph = new UndirectedUnweightedGraph<BFSVertex>();
            Vertex<BFSVertex> v1 = graph.AddVertex(new BFSVertex());
            Vertex<BFSVertex> v2 = graph.AddVertex(new BFSVertex());
            Vertex<BFSVertex> v3 = graph.AddVertex(new BFSVertex());
            Vertex<BFSVertex> v4 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v3, v4);

            // Act
            bfs.Run(graph, v1);

            // Assert
            Assert.That(v1.Value.Processed, Is.True);
            Assert.That(v2.Value.Processed, Is.True);
            Assert.That(v3.Value.Processed, Is.False);
            Assert.That(v4.Value.Processed, Is.False);
        }

        [Test, Category("boundary")]
        public void CorrectlyHandlesSingleVertexGraph()
        {
            // Arrange
            UndirectedUnweightedGraph<BFSVertex> graph = new UndirectedUnweightedGraph<BFSVertex>();
            Vertex<BFSVertex> v1 = graph.AddVertex(new BFSVertex());

            // Act
            bfs.Run(graph, v1);

            // Assert
            Assert.That(v1.Value.Distance, Is.EqualTo(0));
            Assert.That(v1.Value.Predecessor, Is.Null);
            Assert.That(v1.Value.Processed, Is.True);
        }

        [Test, Category("valid")]
        public void CorrectlyTraversesCyclicGraph()
        {
            // Arrange
            UndirectedUnweightedGraph<BFSVertex> graph = new UndirectedUnweightedGraph<BFSVertex>();
            Vertex<BFSVertex> v1 = graph.AddVertex(new BFSVertex());
            Vertex<BFSVertex> v2 = graph.AddVertex(new BFSVertex());
            Vertex<BFSVertex> v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);
            graph.AddEdge(v3, v1);

            // Act
            bfs.Run(graph, v1);

            // Assert
            Assert.That(v1.Value.Distance, Is.EqualTo(0));
            Assert.That(v2.Value.Distance, Is.EqualTo(1));
            Assert.That(v3.Value.Distance, Is.EqualTo(1));
            Assert.That(v1.Value.Predecessor, Is.Null);
            Assert.That(v2.Value.Predecessor, Is.EqualTo(v1));
            Assert.That(v3.Value.Predecessor, Is.EqualTo(v1));
        }

        [Test, Category("valid")]
        public void CompletesLargeGraphTraversalInReasonableTime()
        {
            // Arrange
            UndirectedUnweightedGraph<BFSVertex> graph = new UndirectedUnweightedGraph<BFSVertex>();
            int vertexCount = 10000;
            List<Vertex<BFSVertex>> vertices = new List<Vertex<BFSVertex>>();

            for (int i = 0; i < vertexCount; i++)
            {
                vertices.Add(graph.AddVertex(new BFSVertex()));
            }

            for (int i = 0; i < vertexCount - 1; i++)
            {
                graph.AddEdge(vertices[i], vertices[i + 1]);
            }

            // Act
            var startTime = DateTime.Now;
            bfs.Run(graph, vertices[0]);
            var endTime = DateTime.Now;

            // Assert
            var duration = endTime - startTime;
            Assert.That(duration.TotalSeconds, Is.LessThan(5)); // Adjust the time limit as needed
            Assert.That(vertices.All(v => v.Value.Processed), Is.True);
        }

        [Test, Category("valid")]
        public void PreservesOriginalGraphStructure()
        {
            // Arrange
            UndirectedUnweightedGraph<BFSVertex> graph = new UndirectedUnweightedGraph<BFSVertex>();
            Vertex<BFSVertex> v1 = graph.AddVertex(new BFSVertex());
            Vertex<BFSVertex> v2 = graph.AddVertex(new BFSVertex());
            Vertex<BFSVertex> v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);

            var originalVertices = graph.Vertices.ToList();
            var originalEdges = graph.Edges.ToList();

            // Act
            bfs.Run(graph, v1);

            // Assert
            Assert.That(graph.Vertices, Is.EquivalentTo(originalVertices));
            Assert.That(graph.Edges, Is.EquivalentTo(originalEdges));
        }
    }
}
