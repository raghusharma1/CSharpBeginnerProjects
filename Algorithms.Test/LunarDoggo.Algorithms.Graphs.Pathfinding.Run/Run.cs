// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleCSharpEnv using AI Type Claude AI and AI Model claude-3-5-sonnet-20240620

ROOST_METHOD_HASH=Run_bbc3b7dcfd
ROOST_METHOD_SIG_HASH=Run_23f9485d25

   ########## Test-Scenarios ##########  

Based on the provided method and related code, here are several test scenarios for the `Run` method of the `BreadthFirstSearch` class:

Scenario 1: Null Graph Handling

Details:
  TestName: ThrowsArgumentNullExceptionWhenGraphIsNull
  Description: Verify that the method throws an ArgumentNullException when a null graph is passed.

Execution:
  Arrange: Create a BreadthFirstSearch instance and a null graph.
  Act: Call the Run method with the null graph and a valid start vertex.
  Assert: Verify that an ArgumentNullException is thrown.

Validation:
  This test ensures that the method properly handles null input for the graph parameter, maintaining robustness and preventing null reference exceptions later in the execution.

Scenario 2: Single Vertex Graph

Details:
  TestName: ProcessesSingleVertexGraphCorrectly
  Description: Ensure the method correctly processes a graph with only one vertex.

Execution:
  Arrange: Create a graph with a single vertex and initialize a BreadthFirstSearch instance.
  Act: Run the BFS algorithm on this graph.
  Assert: Verify that the single vertex is processed (Processed = true) and its Distance is 0.

Validation:
  This test confirms that the BFS algorithm works correctly for the simplest possible graph, setting the base case for more complex scenarios.

Scenario 3: Linear Graph Traversal

Details:
  TestName: TraversesLinearGraphCorrectly
  Description: Check if the BFS algorithm correctly traverses a linear graph (each vertex connected to at most two others).

Execution:
  Arrange: Create a linear graph with multiple vertices and set up a BreadthFirstSearch instance.
  Act: Run the BFS algorithm starting from one end of the linear graph.
  Assert: Verify that all vertices are processed in order, with distances increasing by 1 for each step away from the start.

Validation:
  This scenario tests the core functionality of BFS in a simple, predictable graph structure, ensuring correct distance calculation and processing order.

Scenario 4: Cyclic Graph Handling

Details:
  TestName: HandlesCyclicGraphWithoutInfiniteLoop
  Description: Ensure the BFS algorithm correctly handles a graph with cycles without getting stuck in an infinite loop.

Execution:
  Arrange: Create a graph with cycles and initialize a BreadthFirstSearch instance.
  Act: Run the BFS algorithm on this cyclic graph.
  Assert: Verify that all vertices are processed exactly once and have correct distances from the start vertex.

Validation:
  This test is crucial for ensuring that the algorithm can handle more complex graph structures without issues, particularly avoiding revisiting already processed nodes.

Scenario 5: Disconnected Graph Components

Details:
  TestName: ProcessesOnlyReachableVerticesInDisconnectedGraph
  Description: Verify that BFS only processes vertices reachable from the start vertex in a disconnected graph.

Execution:
  Arrange: Create a graph with multiple disconnected components and set up a BreadthFirstSearch instance.
  Act: Run the BFS algorithm starting from a vertex in one component.
  Assert: Check that only vertices in the same component as the start vertex are processed, while others remain unprocessed.

Validation:
  This scenario tests the algorithm's behavior with disconnected graphs, ensuring it doesn't attempt to process unreachable vertices.

Scenario 6: Correct Predecessor Assignment

Details:
  TestName: AssignsCorrectPredecessorsInComplexGraph
  Description: Ensure that the BFS algorithm correctly assigns predecessor vertices in a complex graph structure.

Execution:
  Arrange: Create a complex graph with multiple paths between vertices and initialize a BreadthFirstSearch instance.
  Act: Run the BFS algorithm on this graph.
  Assert: Verify that each processed vertex (except the start) has a predecessor assigned, and that the predecessor is always one step closer to the start vertex.

Validation:
  This test is important for verifying the correct construction of the breadth-first tree, which is crucial for path reconstruction and other graph algorithms that may use BFS as a subroutine.

Scenario 7: Large Graph Performance

Details:
  TestName: CompletesInReasonableTimeForLargeGraph
  Description: Verify that the BFS algorithm completes in a reasonable time for a large graph.

Execution:
  Arrange: Create a large graph with thousands of vertices and edges, and set up a BreadthFirstSearch instance.
  Act: Run the BFS algorithm on this large graph, measuring the execution time.
  Assert: Verify that the algorithm completes within an acceptable time frame and that all reachable vertices are processed.

Validation:
  This performance test ensures that the BFS implementation remains efficient for large-scale graphs, which is crucial for real-world applications dealing with substantial datasets.

These scenarios cover various aspects of the BreadthFirstSearch algorithm, including edge cases, error handling, and performance considerations. They should provide a comprehensive test suite for the given method.


*/

// ********RoostGPT********
using NUnit.Framework;
using LunarDoggo.Datastructures.Graphs;
using LunarDoggo.Algorithms.Graphs.Pathfinding;
using System;
using System.Linq;

namespace LunarDoggo.Algorithms.Graphs.Pathfinding.Test
{
    [TestFixture]
    public class RunTest
    {
        [Test, Category("invalid")]
        public void ThrowsArgumentNullExceptionWhenGraphIsNull()
        {
            var bfs = new BreadthFirstSearch();
            var start = new Vertex<BFSVertex>(0, new BFSVertex());

            Assert.Throws<ArgumentNullException>(() => bfs.Run(null, start));
        }

        [Test, Category("valid")]
        public void ProcessesSingleVertexGraphCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertex = graph.AddVertex(new BFSVertex());
            var bfs = new BreadthFirstSearch();

            bfs.Run(graph, vertex);

            Assert.IsTrue(vertex.Value.Processed);
            Assert.AreEqual(0, vertex.Value.Distance);
        }

        [Test, Category("valid")]
        public void TraversesLinearGraphCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);

            var bfs = new BreadthFirstSearch();
            bfs.Run(graph, v1);

            Assert.IsTrue(v1.Value.Processed);
            Assert.IsTrue(v2.Value.Processed);
            Assert.IsTrue(v3.Value.Processed);
            Assert.AreEqual(0, v1.Value.Distance);
            Assert.AreEqual(1, v2.Value.Distance);
            Assert.AreEqual(2, v3.Value.Distance);
        }

        [Test, Category("valid")]
        public void HandlesCyclicGraphWithoutInfiniteLoop()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);
            graph.AddEdge(v3, v1);

            var bfs = new BreadthFirstSearch();
            bfs.Run(graph, v1);

            Assert.IsTrue(v1.Value.Processed);
            Assert.IsTrue(v2.Value.Processed);
            Assert.IsTrue(v3.Value.Processed);
            Assert.AreEqual(0, v1.Value.Distance);
            Assert.AreEqual(1, v2.Value.Distance);
            Assert.AreEqual(1, v3.Value.Distance);
        }

        [Test, Category("valid")]
        public void ProcessesOnlyReachableVerticesInDisconnectedGraph()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            var v4 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v3, v4);

            var bfs = new BreadthFirstSearch();
            bfs.Run(graph, v1);

            Assert.IsTrue(v1.Value.Processed);
            Assert.IsTrue(v2.Value.Processed);
            Assert.IsFalse(v3.Value.Processed);
            Assert.IsFalse(v4.Value.Processed);
        }

        [Test, Category("valid")]
        public void AssignsCorrectPredecessorsInComplexGraph()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            var v4 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v1, v3);
            graph.AddEdge(v2, v4);
            graph.AddEdge(v3, v4);

            var bfs = new BreadthFirstSearch();
            bfs.Run(graph, v1);

            Assert.AreEqual(null, v1.Value.Predecessor);
            Assert.AreEqual(v1, v2.Value.Predecessor);
            Assert.AreEqual(v1, v3.Value.Predecessor);
            Assert.IsTrue(v4.Value.Predecessor == v2 || v4.Value.Predecessor == v3);
        }

        [Test, Category("valid")]
        public void CompletesInReasonableTimeForLargeGraph()
        {
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertices = Enumerable.Range(0, 10000).Select(_ => graph.AddVertex(new BFSVertex())).ToList();
            
            for (int i = 0; i < vertices.Count - 1; i++)
            {
                graph.AddEdge(vertices[i], vertices[i + 1]);
            }

            var bfs = new BreadthFirstSearch();
            var startTime = DateTime.Now;
            bfs.Run(graph, vertices[0]);
            var endTime = DateTime.Now;

            Assert.Less((endTime - startTime).TotalSeconds, 5); // Assuming 5 seconds is reasonable
            Assert.IsTrue(vertices.All(v => v.Value.Processed));
        }
    }
}
