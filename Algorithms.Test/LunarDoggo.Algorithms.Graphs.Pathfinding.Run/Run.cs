// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleCSharpEnv using AI Type  and AI Model 

ROOST_METHOD_HASH=Run_bbc3b7dcfd
ROOST_METHOD_SIG_HASH=Run_23f9485d25

   ########## Test-Scenarios ##########  

Based on the provided method and context, here are several test scenarios for the `Run` method of the `BreadthFirstSearch` class:

Scenario 1: Null Graph Handling

Details:
  TestName: ThrowArgumentNullExceptionWhenGraphIsNull
  Description: Verify that the method throws an ArgumentNullException when a null graph is provided.
Execution:
  Arrange: Create a BreadthFirstSearch instance and set up a null graph and a valid start vertex.
  Act: Call the Run method with the null graph and valid start vertex.
  Assert: Expect an ArgumentNullException to be thrown.
Validation:
  This test ensures that the method properly handles null input for the graph parameter, maintaining robustness and preventing null reference exceptions later in the execution.

Scenario 2: Single Vertex Graph

Details:
  TestName: ProcessSingleVertexGraphCorrectly
  Description: Ensure the method correctly processes a graph with only one vertex.
Execution:
  Arrange: Create a graph with a single vertex and instantiate a BreadthFirstSearch object.
  Act: Run the BFS algorithm on this graph.
  Assert: Verify that the single vertex is processed (Processed = true) and its Distance is 0.
Validation:
  This test confirms that the BFS algorithm works correctly for the simplest possible graph, setting a baseline for more complex scenarios.

Scenario 3: Linear Graph Traversal

Details:
  TestName: TraverseLinearGraphCorrectly
  Description: Check if the BFS algorithm correctly traverses a linear graph (vertices connected in a line).
Execution:
  Arrange: Create a linear graph with multiple vertices and set up a BreadthFirstSearch instance.
  Act: Run the BFS algorithm starting from one end of the linear graph.
  Assert: Verify that all vertices are processed, and their distances increase linearly from the start vertex.
Validation:
  This scenario tests the core functionality of BFS in a simple, predictable graph structure, ensuring correct distance calculation and processing order.

Scenario 4: Cyclic Graph Handling

Details:
  TestName: HandleCyclicGraphWithoutInfiniteLoop
  Description: Ensure the BFS algorithm correctly handles a graph with cycles without getting stuck in an infinite loop.
Execution:
  Arrange: Create a graph with cycles and instantiate a BreadthFirstSearch object.
  Act: Run the BFS algorithm on the cyclic graph.
  Assert: Check that all vertices are processed exactly once and have correct distance values.
Validation:
  This test verifies that the algorithm can handle more complex graph structures with cycles, which is crucial for its robustness and correctness in real-world scenarios.

Scenario 5: Disconnected Graph Components

Details:
  TestName: ProcessOnlyReachableVerticesInDisconnectedGraph
  Description: Verify that BFS only processes vertices reachable from the start vertex in a disconnected graph.
Execution:
  Arrange: Create a graph with multiple disconnected components and set up a BreadthFirstSearch instance.
  Act: Run the BFS algorithm starting from a vertex in one component.
  Assert: Confirm that only vertices in the same component as the start vertex are processed, while others remain unprocessed.
Validation:
  This scenario ensures that the BFS algorithm respects the graph's structure and doesn't incorrectly process unreachable vertices.

Scenario 6: Large Graph Performance

Details:
  TestName: CompleteTraversalOfLargeGraphWithinReasonableTime
  Description: Test the performance of the BFS algorithm on a large graph to ensure it completes within a reasonable time frame.
Execution:
  Arrange: Generate a large graph with many vertices and edges, and create a BreadthFirstSearch instance.
  Act: Run the BFS algorithm on the large graph, measuring the execution time.
  Assert: Verify that the algorithm completes within an acceptable time limit and processes all vertices correctly.
Validation:
  This test assesses the algorithm's efficiency and scalability, which is important for its practical application on larger datasets.

These scenarios cover various aspects of the BreadthFirstSearch algorithm, including error handling, correctness for different graph structures, and performance considerations.


*/

// ********RoostGPT********
using NUnit.Framework;
using LunarDoggo.Datastructures.Graphs;
using LunarDoggo.Algorithms.Graphs.Pathfinding;
using System;
using System.Collections.Generic;
using System.Linq;

namespace LunarDoggo.Algorithms.Graphs.Pathfinding.Test
{
    [TestFixture]
    public class RunTest
    {
        private BreadthFirstSearch bfs;

        [SetUp]
        public void Setup()
        {
            bfs = new BreadthFirstSearch();
        }

        [Test, Category("invalid")]
        public void ThrowArgumentNullExceptionWhenGraphIsNull()
        {
            // Arrange
            IGraph<BFSVertex> nullGraph = null;
            Vertex<BFSVertex> startVertex = new Vertex<BFSVertex>(0, new BFSVertex());

            // Act & Assert
            Assert.Throws<ArgumentNullException>(() => bfs.Run(nullGraph, startVertex));
        }

        [Test, Category("valid")]
        public void ProcessSingleVertexGraphCorrectly()
        {
            // Arrange
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertex = graph.AddVertex(new BFSVertex());

            // Act
            bfs.Run(graph, vertex);

            // Assert
            Assert.IsTrue(vertex.Value.Processed);
            Assert.AreEqual(0, vertex.Value.Distance);
        }

        [Test, Category("valid")]
        public void TraverseLinearGraphCorrectly()
        {
            // Arrange
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);

            // Act
            bfs.Run(graph, v1);

            // Assert
            Assert.IsTrue(v1.Value.Processed);
            Assert.IsTrue(v2.Value.Processed);
            Assert.IsTrue(v3.Value.Processed);
            Assert.AreEqual(0, v1.Value.Distance);
            Assert.AreEqual(1, v2.Value.Distance);
            Assert.AreEqual(2, v3.Value.Distance);
        }

        [Test, Category("valid")]
        public void HandleCyclicGraphWithoutInfiniteLoop()
        {
            // Arrange
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);
            graph.AddEdge(v3, v1);

            // Act
            bfs.Run(graph, v1);

            // Assert
            Assert.IsTrue(v1.Value.Processed);
            Assert.IsTrue(v2.Value.Processed);
            Assert.IsTrue(v3.Value.Processed);
            Assert.AreEqual(0, v1.Value.Distance);
            Assert.AreEqual(1, v2.Value.Distance);
            Assert.AreEqual(1, v3.Value.Distance);
        }

        [Test, Category("valid")]
        public void ProcessOnlyReachableVerticesInDisconnectedGraph()
        {
            // Arrange
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var v1 = graph.AddVertex(new BFSVertex());
            var v2 = graph.AddVertex(new BFSVertex());
            var v3 = graph.AddVertex(new BFSVertex());
            var v4 = graph.AddVertex(new BFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v3, v4);

            // Act
            bfs.Run(graph, v1);

            // Assert
            Assert.IsTrue(v1.Value.Processed);
            Assert.IsTrue(v2.Value.Processed);
            Assert.IsFalse(v3.Value.Processed);
            Assert.IsFalse(v4.Value.Processed);
        }

        [Test, Category("valid")]
        public void CompleteTraversalOfLargeGraphWithinReasonableTime()
        {
            // Arrange
            var graph = new UndirectedUnweightedGraph<BFSVertex>();
            var vertices = new List<Vertex<BFSVertex>>();
            for (int i = 0; i < 10000; i++)
            {
                vertices.Add(graph.AddVertex(new BFSVertex()));
            }
            for (int i = 0; i < 9999; i++)
            {
                graph.AddEdge(vertices[i], vertices[i + 1]);
            }

            // Act
            var startTime = DateTime.Now;
            bfs.Run(graph, vertices[0]);
            var endTime = DateTime.Now;

            // Assert
            Assert.IsTrue((endTime - startTime).TotalSeconds < 5); // Assuming 5 seconds is reasonable
            Assert.IsTrue(vertices.All(v => v.Value.Processed));
            Assert.AreEqual(9999, vertices.Last().Value.Distance);
        }
    }
}
