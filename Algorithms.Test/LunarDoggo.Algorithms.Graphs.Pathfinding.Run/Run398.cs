// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleCSharpEnv using AI Type  and AI Model 

ROOST_METHOD_HASH=Run_a2e9436d0a
ROOST_METHOD_SIG_HASH=Run_9ce955ed80

   ########## Test-Scenarios ##########  

Based on the provided method and related code, here are several test scenarios for the `Run` method of the `DepthFirstSearch` class:

Scenario 1: Null Graph Handling

Details:
  TestName: ThrowArgumentNullExceptionWhenGraphIsNull
  Description: Verify that the method throws an ArgumentNullException when a null graph is passed.
Execution:
  Arrange: Create a DepthFirstSearch instance.
  Act: Call the Run method with a null graph.
  Assert: Expect an ArgumentNullException to be thrown.
Validation:
  This test ensures that the method properly handles null input, preventing null reference exceptions later in the execution.

Scenario 2: Empty Graph Processing

Details:
  TestName: ProcessEmptyGraphWithoutException
  Description: Ensure the method can handle an empty graph without throwing exceptions.
Execution:
  Arrange: Create a DepthFirstSearch instance and an empty IGraph<DFSVertex>.
  Act: Call the Run method with the empty graph.
  Assert: Verify that no exception is thrown and the method completes successfully.
Validation:
  This test confirms that the method can handle edge cases like empty graphs gracefully.

Scenario 3: Single Vertex Graph Processing

Details:
  TestName: ProcessSingleVertexGraphCorrectly
  Description: Check if the method correctly processes a graph with a single vertex.
Execution:
  Arrange: Create a DepthFirstSearch instance and an IGraph<DFSVertex> with one vertex.
  Act: Call the Run method with the single-vertex graph.
  Assert: Verify that the vertex's StartTime and EndTime are set and Processed is true.
Validation:
  This test ensures that the basic functionality works for the simplest possible graph.

Scenario 4: Connected Graph Processing

Details:
  TestName: ProcessFullyConnectedGraphCorrectly
  Description: Verify that all vertices in a fully connected graph are processed.
Execution:
  Arrange: Create a DepthFirstSearch instance and a fully connected IGraph<DFSVertex>.
  Act: Call the Run method with the graph.
  Assert: Check that all vertices have been processed (Processed is true, StartTime and EndTime are set).
Validation:
  This test confirms that the method can handle a typical use case of a fully connected graph.

Scenario 5: Disconnected Graph Processing

Details:
  TestName: ProcessDisconnectedGraphComponents
  Description: Ensure that all components of a disconnected graph are processed.
Execution:
  Arrange: Create a DepthFirstSearch instance and an IGraph<DFSVertex> with multiple disconnected components.
  Act: Call the Run method with the disconnected graph.
  Assert: Verify that all vertices in all components have been processed.
Validation:
  This test checks if the method can handle graphs with multiple disconnected components, ensuring complete traversal.

Scenario 6: Cyclic Graph Processing

Details:
  TestName: ProcessCyclicGraphWithoutInfiniteLoop
  Description: Check if the method can process a graph containing cycles without getting stuck in an infinite loop.
Execution:
  Arrange: Create a DepthFirstSearch instance and an IGraph<DFSVertex> containing at least one cycle.
  Act: Call the Run method with the cyclic graph.
  Assert: Verify that all vertices are processed and the method terminates.
Validation:
  This test ensures that the method can handle graphs with cycles, which is crucial for preventing infinite recursion.

Scenario 7: Correct Time Assignment

Details:
  TestName: AssignCorrectStartAndEndTimes
  Description: Verify that the StartTime and EndTime for each vertex are assigned correctly and in the right order.
Execution:
  Arrange: Create a DepthFirstSearch instance and an IGraph<DFSVertex> with a known structure.
  Act: Call the Run method with the graph.
  Assert: Check that StartTime and EndTime for each vertex are set, and that they follow the expected DFS order.
Validation:
  This test confirms that the time assignment, which is crucial for certain DFS applications, is working correctly.

Scenario 8: Predecessor Assignment

Details:
  TestName: AssignCorrectPredecessors
  Description: Ensure that the Predecessor property of each vertex is set correctly during the traversal.
Execution:
  Arrange: Create a DepthFirstSearch instance and an IGraph<DFSVertex> with a known structure.
  Act: Call the Run method with the graph.
  Assert: Verify that each processed vertex (except the start vertex) has a correct Predecessor assigned.
Validation:
  This test checks if the method correctly builds the DFS tree by assigning predecessors, which is important for path reconstruction and other DFS applications.

These test scenarios cover various aspects of the DepthFirstSearch.Run method, including edge cases, error handling, and core functionality. They should provide a comprehensive test suite for the given method.


*/

// ********RoostGPT********
using NUnit.Framework;
using LunarDoggo.Datastructures.Graphs;
using LunarDoggo.Algorithms.Graphs.Pathfinding;
using System;
using System.Linq;

namespace LunarDoggo.Algorithms.Graphs.Pathfinding.Test
{
    [TestFixture]
    public class Run398Test
    {
        private DepthFirstSearch dfs;

        [SetUp]
        public void Setup()
        {
            dfs = new DepthFirstSearch();
        }

        [Test, Category("invalid")]
        public void ThrowArgumentNullExceptionWhenGraphIsNull()
        {
            Assert.Throws<ArgumentNullException>(() => dfs.Run(null));
        }

        [Test, Category("valid")]
        public void ProcessEmptyGraphWithoutException()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            Assert.DoesNotThrow(() => dfs.Run(graph));
        }

        [Test, Category("valid")]
        public void ProcessSingleVertexGraphCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var vertex = graph.AddVertex(new DFSVertex());

            dfs.Run(graph);

            Assert.IsTrue(vertex.Value.Processed);
            Assert.Greater(vertex.Value.StartTime, -1);
            Assert.Greater(vertex.Value.EndTime, vertex.Value.StartTime);
        }

        [Test, Category("valid")]
        public void ProcessFullyConnectedGraphCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var v1 = graph.AddVertex(new DFSVertex());
            var v2 = graph.AddVertex(new DFSVertex());
            var v3 = graph.AddVertex(new DFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);
            graph.AddEdge(v3, v1);

            dfs.Run(graph);

            Assert.IsTrue(graph.Vertices.All(v => v.Value.Processed));
            Assert.IsTrue(graph.Vertices.All(v => v.Value.StartTime > -1));
            Assert.IsTrue(graph.Vertices.All(v => v.Value.EndTime > v.Value.StartTime));
        }

        [Test, Category("valid")]
        public void ProcessDisconnectedGraphComponents()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var v1 = graph.AddVertex(new DFSVertex());
            var v2 = graph.AddVertex(new DFSVertex());
            var v3 = graph.AddVertex(new DFSVertex());
            var v4 = graph.AddVertex(new DFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v3, v4);

            dfs.Run(graph);

            Assert.IsTrue(graph.Vertices.All(v => v.Value.Processed));
            Assert.IsTrue(graph.Vertices.All(v => v.Value.StartTime > -1));
            Assert.IsTrue(graph.Vertices.All(v => v.Value.EndTime > v.Value.StartTime));
        }

        [Test, Category("valid")]
        public void ProcessCyclicGraphWithoutInfiniteLoop()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var v1 = graph.AddVertex(new DFSVertex());
            var v2 = graph.AddVertex(new DFSVertex());
            var v3 = graph.AddVertex(new DFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);
            graph.AddEdge(v3, v1);

            dfs.Run(graph);

            Assert.IsTrue(graph.Vertices.All(v => v.Value.Processed));
            Assert.IsTrue(graph.Vertices.All(v => v.Value.StartTime > -1));
            Assert.IsTrue(graph.Vertices.All(v => v.Value.EndTime > v.Value.StartTime));
        }

        [Test, Category("valid")]
        public void AssignCorrectStartAndEndTimes()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var v1 = graph.AddVertex(new DFSVertex());
            var v2 = graph.AddVertex(new DFSVertex());
            var v3 = graph.AddVertex(new DFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);

            dfs.Run(graph);

            var sortedVertices = graph.Vertices.OrderBy(v => v.Value.StartTime).ToList();
            for (int i = 1; i < sortedVertices.Count; i++)
            {
                Assert.Greater(sortedVertices[i].Value.StartTime, sortedVertices[i - 1].Value.StartTime);
                Assert.Greater(sortedVertices[i - 1].Value.EndTime, sortedVertices[i].Value.StartTime);
            }
        }

        [Test, Category("valid")]
        public void AssignCorrectPredecessors()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var v1 = graph.AddVertex(new DFSVertex());
            var v2 = graph.AddVertex(new DFSVertex());
            var v3 = graph.AddVertex(new DFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);

            dfs.Run(graph);

            Assert.IsNull(v1.Value.Predecessor);
            Assert.AreEqual(v1, v2.Value.Predecessor);
            Assert.AreEqual(v2, v3.Value.Predecessor);
        }
    }
}
