// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleCSharpEnv using AI Type Claude AI and AI Model claude-3-5-sonnet-20240620

ROOST_METHOD_HASH=Run_a2e9436d0a
ROOST_METHOD_SIG_HASH=Run_9ce955ed80

   ########## Test-Scenarios ##########  

Based on the provided method and related code, here are several test scenarios for the `Run` method of the `DepthFirstSearch` class:

Scenario 1: Null Graph Input

Details:
  TestName: ThrowArgumentNullExceptionWhenGraphIsNull
  Description: Verify that the method throws an ArgumentNullException when a null graph is provided.
Execution:
  Arrange: Create a DepthFirstSearch instance.
  Act: Call the Run method with a null graph.
  Assert: Expect an ArgumentNullException to be thrown.
Validation:
  This test ensures that the method properly handles null input, preventing potential null reference exceptions later in the execution.

Scenario 2: Empty Graph

Details:
  TestName: ProcessEmptyGraphWithoutException
  Description: Ensure the method can handle an empty graph without throwing exceptions.
Execution:
  Arrange: Create a DepthFirstSearch instance and an empty IGraph<DFSVertex>.
  Act: Call the Run method with the empty graph.
  Assert: Verify that no exception is thrown and the method completes successfully.
Validation:
  This test confirms that the method can handle edge cases like empty graphs gracefully.

Scenario 3: Single Vertex Graph

Details:
  TestName: ProcessSingleVertexGraphCorrectly
  Description: Check if the method correctly processes a graph with a single vertex.
Execution:
  Arrange: Create a DepthFirstSearch instance and an IGraph<DFSVertex> with one vertex.
  Act: Call the Run method with the single-vertex graph.
  Assert: Verify that the vertex's StartTime and EndTime are set and Processed is true.
Validation:
  This test ensures that the basic functionality works for the simplest possible graph.

Scenario 4: Connected Graph Processing

Details:
  TestName: ProcessAllVerticesInConnectedGraph
  Description: Verify that all vertices in a connected graph are processed.
Execution:
  Arrange: Create a DepthFirstSearch instance and a connected IGraph<DFSVertex> with multiple vertices.
  Act: Call the Run method with the connected graph.
  Assert: Check that all vertices have been processed (Processed is true for all).
Validation:
  This test confirms that the DFS algorithm visits all vertices in a connected graph.

Scenario 5: Disconnected Graph Processing

Details:
  TestName: ProcessAllComponentsInDisconnectedGraph
  Description: Ensure that all components of a disconnected graph are processed.
Execution:
  Arrange: Create a DepthFirstSearch instance and a disconnected IGraph<DFSVertex> with multiple components.
  Act: Call the Run method with the disconnected graph.
  Assert: Verify that all vertices in all components have been processed.
Validation:
  This test checks if the method correctly handles disconnected graphs by processing all components.

Scenario 6: Correct Start and End Times

Details:
  TestName: AssignCorrectStartAndEndTimesToVertices
  Description: Check if the start and end times are assigned correctly to all vertices.
Execution:
  Arrange: Create a DepthFirstSearch instance and an IGraph<DFSVertex> with known structure.
  Act: Call the Run method with the graph.
  Assert: Verify that for each vertex, StartTime < EndTime, and that the times are unique and sequential.
Validation:
  This test ensures that the core DFS timing mechanism is working correctly, which is crucial for applications like topological sorting.

Scenario 7: Correct Predecessor Assignment

Details:
  TestName: AssignCorrectPredecessorsToVertices
  Description: Verify that predecessors are correctly assigned during the DFS traversal.
Execution:
  Arrange: Create a DepthFirstSearch instance and an IGraph<DFSVertex> with known structure.
  Act: Call the Run method with the graph.
  Assert: Check that each vertex (except the start vertex of each component) has a non-null Predecessor that was visited before it.
Validation:
  This test confirms that the DFS correctly builds the predecessor relationships, which are important for path reconstruction and other graph algorithms.

Scenario 8: Graph Modification During Execution

Details:
  TestName: HandleGraphModificationDuringExecution
  Description: Ensure the method behaves correctly if the graph is modified during execution.
Execution:
  Arrange: Create a DepthFirstSearch instance and an IGraph<DFSVertex> that can be modified.
  Act: Start the Run method in a separate thread, modify the graph (add/remove vertices/edges) while it's running.
  Assert: Verify that the method either completes successfully or throws an appropriate exception, and that the graph remains in a consistent state.
Validation:
  This test checks the robustness of the implementation against concurrent modifications, which is important for thread-safety in multi-threaded environments.

These test scenarios cover various aspects of the DepthFirstSearch.Run method, including normal operation, edge cases, and potential error conditions. They should provide a comprehensive test suite for this method.


*/

// ********RoostGPT********
using NUnit.Framework;
using LunarDoggo.Datastructures.Graphs;
using LunarDoggo.Algorithms.Graphs.Pathfinding;
using System;
using System.Linq;

namespace LunarDoggo.Algorithms.Graphs.Pathfinding.Test
{
    [TestFixture]
    public class Run901Test
    {
        private DepthFirstSearch dfs;

        [SetUp]
        public void Setup()
        {
            dfs = new DepthFirstSearch();
        }

        [Test, Category("invalid")]
        public void ThrowArgumentNullExceptionWhenGraphIsNull()
        {
            Assert.Throws<ArgumentNullException>(() => dfs.Run(null));
        }

        [Test, Category("valid")]
        public void ProcessEmptyGraphWithoutException()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            Assert.DoesNotThrow(() => dfs.Run(graph));
        }

        [Test, Category("valid")]
        public void ProcessSingleVertexGraphCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var vertex = graph.AddVertex(new DFSVertex());

            dfs.Run(graph);

            Assert.That(vertex.Value.Processed, Is.True);
            Assert.That(vertex.Value.StartTime, Is.GreaterThanOrEqualTo(0));
            Assert.That(vertex.Value.EndTime, Is.GreaterThan(vertex.Value.StartTime));
        }

        [Test, Category("valid")]
        public void ProcessAllVerticesInConnectedGraph()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var v1 = graph.AddVertex(new DFSVertex());
            var v2 = graph.AddVertex(new DFSVertex());
            var v3 = graph.AddVertex(new DFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);

            dfs.Run(graph);

            Assert.That(graph.Vertices.All(v => v.Value.Processed), Is.True);
        }

        [Test, Category("valid")]
        public void ProcessAllComponentsInDisconnectedGraph()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var v1 = graph.AddVertex(new DFSVertex());
            var v2 = graph.AddVertex(new DFSVertex());
            var v3 = graph.AddVertex(new DFSVertex());
            var v4 = graph.AddVertex(new DFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v3, v4);

            dfs.Run(graph);

            Assert.That(graph.Vertices.All(v => v.Value.Processed), Is.True);
        }

        [Test, Category("valid")]
        public void AssignCorrectStartAndEndTimesToVertices()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var v1 = graph.AddVertex(new DFSVertex());
            var v2 = graph.AddVertex(new DFSVertex());
            var v3 = graph.AddVertex(new DFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);

            dfs.Run(graph);

            Assert.That(graph.Vertices.All(v => v.Value.StartTime < v.Value.EndTime), Is.True);
            Assert.That(graph.Vertices.Select(v => v.Value.StartTime).Distinct().Count(), Is.EqualTo(3));
            Assert.That(graph.Vertices.Select(v => v.Value.EndTime).Distinct().Count(), Is.EqualTo(3));
        }

        [Test, Category("valid")]
        public void AssignCorrectPredecessorsToVertices()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var v1 = graph.AddVertex(new DFSVertex());
            var v2 = graph.AddVertex(new DFSVertex());
            var v3 = graph.AddVertex(new DFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);

            dfs.Run(graph);

            Assert.That(graph.Vertices.Count(v => v.Value.Predecessor == null), Is.EqualTo(1));
            Assert.That(graph.Vertices.Count(v => v.Value.Predecessor != null), Is.EqualTo(2));
            Assert.That(graph.Vertices.Where(v => v.Value.Predecessor != null)
                .All(v => v.Value.Predecessor.Value.StartTime < v.Value.StartTime), Is.True);
        }

        [Test, Category("integration")]
        public void HandleGraphModificationDuringExecution()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var v1 = graph.AddVertex(new DFSVertex());
            var v2 = graph.AddVertex(new DFSVertex());
            graph.AddEdge(v1, v2);

            var runThread = new System.Threading.Thread(() => dfs.Run(graph));
            runThread.Start();

            // Modify graph while DFS is running
            var v3 = graph.AddVertex(new DFSVertex());
            graph.AddEdge(v2, v3);

            runThread.Join();

            Assert.That(graph.Vertices.All(v => v.Value.Processed), Is.True);
        }
    }
}
