// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleCSharpEnv using AI Type  and AI Model 

ROOST_METHOD_HASH=Run_a2e9436d0a
ROOST_METHOD_SIG_HASH=Run_9ce955ed80

   ########## Test-Scenarios ##########  

Based on the provided method and related code, here are several test scenarios for the `Run` method of the `DepthFirstSearch` class:

Scenario 1: Null Graph Input

Details:
  TestName: ThrowArgumentNullExceptionWhenGraphIsNull
  Description: Verify that the method throws an ArgumentNullException when a null graph is passed as an argument.
Execution:
  Arrange: Create a DepthFirstSearch instance.
  Act: Call the Run method with a null graph.
  Assert: Expect an ArgumentNullException to be thrown.
Validation:
  This test ensures that the method properly handles null input, preventing potential null reference exceptions later in the execution.

Scenario 2: Empty Graph

Details:
  TestName: RunSuccessfullyOnEmptyGraph
  Description: Ensure the method can handle an empty graph without errors.
Execution:
  Arrange: Create a DepthFirstSearch instance and an empty IGraph<DFSVertex>.
  Act: Call the Run method with the empty graph.
  Assert: Verify that the method completes without throwing any exceptions.
Validation:
  This test confirms that the method can handle edge cases like empty graphs gracefully.

Scenario 3: Single Vertex Graph

Details:
  TestName: ProcessSingleVertexGraphCorrectly
  Description: Check if the method correctly processes a graph with only one vertex.
Execution:
  Arrange: Create a DepthFirstSearch instance and an IGraph<DFSVertex> with a single vertex.
  Act: Call the Run method with the single-vertex graph.
  Assert: Verify that the vertex's StartTime and EndTime are set and Processed is true.
Validation:
  This test ensures that the basic functionality works for the simplest possible graph.

Scenario 4: Connected Graph

Details:
  TestName: ProcessAllVerticesInConnectedGraph
  Description: Verify that all vertices in a connected graph are processed.
Execution:
  Arrange: Create a DepthFirstSearch instance and a connected IGraph<DFSVertex> with multiple vertices.
  Act: Call the Run method with the connected graph.
  Assert: Check that all vertices have been processed (Processed is true for all vertices).
Validation:
  This test confirms that the method correctly traverses all vertices in a connected graph.

Scenario 5: Disconnected Graph

Details:
  TestName: ProcessAllComponentsInDisconnectedGraph
  Description: Ensure that all components of a disconnected graph are processed.
Execution:
  Arrange: Create a DepthFirstSearch instance and a disconnected IGraph<DFSVertex> with multiple components.
  Act: Call the Run method with the disconnected graph.
  Assert: Verify that all vertices in all components have been processed.
Validation:
  This test checks if the method can handle disconnected graphs and process all components.

Scenario 6: Cyclic Graph

Details:
  TestName: HandleCyclicGraphWithoutInfiniteLoop
  Description: Check if the method can process a graph containing cycles without getting stuck in an infinite loop.
Execution:
  Arrange: Create a DepthFirstSearch instance and an IGraph<DFSVertex> containing at least one cycle.
  Act: Call the Run method with the cyclic graph.
  Assert: Verify that all vertices are processed and the method terminates.
Validation:
  This test ensures that the method can handle graphs with cycles correctly.

Scenario 7: Large Graph

Details:
  TestName: ProcessLargeGraphEfficiently
  Description: Verify that the method can handle a large graph without excessive time or memory usage.
Execution:
  Arrange: Create a DepthFirstSearch instance and a large IGraph<DFSVertex> with many vertices and edges.
  Act: Call the Run method with the large graph, measuring execution time.
  Assert: Check that all vertices are processed and the execution time is within acceptable limits.
Validation:
  This test confirms that the method scales well for larger graphs.

Scenario 8: Correct Start and End Times

Details:
  TestName: AssignCorrectStartAndEndTimesToVertices
  Description: Ensure that the StartTime and EndTime for each vertex are assigned correctly.
Execution:
  Arrange: Create a DepthFirstSearch instance and an IGraph<DFSVertex> with a known structure.
  Act: Call the Run method with the graph.
  Assert: Verify that the StartTime and EndTime for each vertex are consistent with DFS order and nested correctly.
Validation:
  This test checks the core functionality of the DFS algorithm in assigning discovery and finish times.

Scenario 9: Correct Predecessor Assignment

Details:
  TestName: AssignCorrectPredecessorsToVertices
  Description: Verify that the Predecessor property of each vertex is set correctly during the traversal.
Execution:
  Arrange: Create a DepthFirstSearch instance and an IGraph<DFSVertex> with a known structure.
  Act: Call the Run method with the graph.
  Assert: Check that the Predecessor of each vertex (except the start vertex) points to the correct parent in the DFS tree.
Validation:
  This test ensures that the DFS tree structure is correctly captured through predecessor assignments.

Scenario 10: Reinitialization of Vertex Properties

Details:
  TestName: ReinitializeVertexPropertiesCorrectly
  Description: Check if the method correctly reinitializes vertex properties when run multiple times on the same graph.
Execution:
  Arrange: Create a DepthFirstSearch instance and an IGraph<DFSVertex>.
  Act: Call the Run method twice on the same graph.
  Assert: Verify that after the second run, all vertices have been reinitialized and processed correctly.
Validation:
  This test ensures that the method can be called multiple times on the same graph without carrying over state from previous runs.


*/

// ********RoostGPT********
using NUnit.Framework;
using LunarDoggo.Datastructures.Graphs;
using LunarDoggo.Algorithms.Graphs.Pathfinding;
using System;
using System.Linq;

namespace LunarDoggo.Algorithms.Graphs.Pathfinding.Test
{
    [TestFixture]
    public class Run577Test
    {
        private DepthFirstSearch dfs;

        [SetUp]
        public void Setup()
        {
            dfs = new DepthFirstSearch();
        }

        [Test, Category("invalid")]
        public void ThrowArgumentNullExceptionWhenGraphIsNull()
        {
            Assert.Throws<ArgumentNullException>(() => dfs.Run(null));
        }

        [Test, Category("valid")]
        public void RunSuccessfullyOnEmptyGraph()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            Assert.DoesNotThrow(() => dfs.Run(graph));
        }

        [Test, Category("valid")]
        public void ProcessSingleVertexGraphCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var vertex = graph.AddVertex(new DFSVertex());

            dfs.Run(graph);

            Assert.That(vertex.Value.Processed, Is.True);
            Assert.That(vertex.Value.StartTime, Is.GreaterThanOrEqualTo(0));
            Assert.That(vertex.Value.EndTime, Is.GreaterThan(vertex.Value.StartTime));
        }

        [Test, Category("valid")]
        public void ProcessAllVerticesInConnectedGraph()
        {
            var graph = CreateConnectedGraph();

            dfs.Run(graph);

            Assert.That(graph.Vertices.All(v => v.Value.Processed), Is.True);
        }

        [Test, Category("valid")]
        public void ProcessAllComponentsInDisconnectedGraph()
        {
            var graph = CreateDisconnectedGraph();

            dfs.Run(graph);

            Assert.That(graph.Vertices.All(v => v.Value.Processed), Is.True);
        }

        [Test, Category("valid")]
        public void HandleCyclicGraphWithoutInfiniteLoop()
        {
            var graph = CreateCyclicGraph();

            Assert.DoesNotThrow(() => dfs.Run(graph));
            Assert.That(graph.Vertices.All(v => v.Value.Processed), Is.True);
        }

        [Test, Category("valid")]
        public void ProcessLargeGraphEfficiently()
        {
            var graph = CreateLargeGraph();

            var startTime = DateTime.Now;
            dfs.Run(graph);
            var endTime = DateTime.Now;

            Assert.That(graph.Vertices.All(v => v.Value.Processed), Is.True);
            Assert.That((endTime - startTime).TotalSeconds, Is.LessThan(5)); // Adjust timeout as needed
        }

        [Test, Category("valid")]
        public void AssignCorrectStartAndEndTimesToVertices()
        {
            var graph = CreateSimpleGraph();

            dfs.Run(graph);

            var vertices = graph.Vertices.ToList();
            for (int i = 0; i < vertices.Count; i++)
            {
                Assert.That(vertices[i].Value.StartTime, Is.LessThan(vertices[i].Value.EndTime));
                for (int j = i + 1; j < vertices.Count; j++)
                {
                    Assert.That(
                        (vertices[i].Value.StartTime < vertices[j].Value.StartTime && vertices[i].Value.EndTime > vertices[j].Value.EndTime) ||
                        (vertices[i].Value.StartTime > vertices[j].Value.StartTime && vertices[i].Value.EndTime < vertices[j].Value.EndTime) ||
                        (vertices[i].Value.EndTime < vertices[j].Value.StartTime) ||
                        (vertices[i].Value.StartTime > vertices[j].Value.EndTime),
                        Is.True
                    );
                }
            }
        }

        [Test, Category("valid")]
        public void AssignCorrectPredecessorsToVertices()
        {
            var graph = CreateSimpleGraph();

            dfs.Run(graph);

            var vertices = graph.Vertices.ToList();
            Assert.That(vertices[0].Value.Predecessor, Is.Null);
            for (int i = 1; i < vertices.Count; i++)
            {
                Assert.That(vertices[i].Value.Predecessor, Is.Not.Null);
                Assert.That(vertices[i].Value.Predecessor.Adjacent.Contains(vertices[i]), Is.True);
            }
        }

        [Test, Category("valid")]
        public void ReinitializeVertexPropertiesCorrectly()
        {
            var graph = CreateSimpleGraph();

            dfs.Run(graph);
            var firstRunEndTimes = graph.Vertices.Select(v => v.Value.EndTime).ToList();

            dfs.Run(graph);
            var secondRunEndTimes = graph.Vertices.Select(v => v.Value.EndTime).ToList();

            Assert.That(graph.Vertices.All(v => v.Value.Processed), Is.True);
            Assert.That(firstRunEndTimes, Is.Not.EqualTo(secondRunEndTimes));
        }

        private IGraph<DFSVertex> CreateConnectedGraph()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var v1 = graph.AddVertex(new DFSVertex());
            var v2 = graph.AddVertex(new DFSVertex());
            var v3 = graph.AddVertex(new DFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);
            return graph;
        }

        private IGraph<DFSVertex> CreateDisconnectedGraph()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var v1 = graph.AddVertex(new DFSVertex());
            var v2 = graph.AddVertex(new DFSVertex());
            var v3 = graph.AddVertex(new DFSVertex());
            var v4 = graph.AddVertex(new DFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v3, v4);
            return graph;
        }

        private IGraph<DFSVertex> CreateCyclicGraph()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var v1 = graph.AddVertex(new DFSVertex());
            var v2 = graph.AddVertex(new DFSVertex());
            var v3 = graph.AddVertex(new DFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);
            graph.AddEdge(v3, v1);
            return graph;
        }

        private IGraph<DFSVertex> CreateLargeGraph()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var vertices = Enumerable.Range(0, 1000).Select(_ => graph.AddVertex(new DFSVertex())).ToList();
            for (int i = 0; i < vertices.Count - 1; i++)
            {
                graph.AddEdge(vertices[i], vertices[i + 1]);
            }
            return graph;
        }

        private IGraph<DFSVertex> CreateSimpleGraph()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var v1 = graph.AddVertex(new DFSVertex());
            var v2 = graph.AddVertex(new DFSVertex());
            var v3 = graph.AddVertex(new DFSVertex());
            var v4 = graph.AddVertex(new DFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v1, v3);
            graph.AddEdge(v2, v4);
            return graph;
        }
    }
}
