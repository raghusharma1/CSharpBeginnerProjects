// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleCSharpEnv using AI Type  and AI Model 

ROOST_METHOD_HASH=Run_a2e9436d0a
ROOST_METHOD_SIG_HASH=Run_9ce955ed80

   ########## Test-Scenarios ##########  

Based on the provided method and related code, here are several test scenarios for the `Run` method of the `DepthFirstSearch` class:

Scenario 1: Null Graph Input

Details:
  TestName: ThrowArgumentNullExceptionWhenGraphIsNull
  Description: Verify that the method throws an ArgumentNullException when a null graph is passed as an argument.
Execution:
  Arrange: Create a DepthFirstSearch instance.
  Act: Call the Run method with a null graph.
  Assert: Verify that an ArgumentNullException is thrown with the correct message.
Validation:
  This test ensures that the method properly handles null input, preventing potential null reference exceptions later in the execution.

Scenario 2: Empty Graph

Details:
  TestName: ProcessEmptyGraphWithoutException
  Description: Ensure that the method can handle an empty graph (a graph with no vertices) without throwing an exception.
Execution:
  Arrange: Create a DepthFirstSearch instance and an empty IGraph<DFSVertex>.
  Act: Call the Run method with the empty graph.
  Assert: Verify that the method completes without throwing an exception.
Validation:
  This test confirms that the method can handle edge cases like empty graphs gracefully.

Scenario 3: Single Vertex Graph

Details:
  TestName: ProcessSingleVertexGraphCorrectly
  Description: Verify that the method correctly processes a graph with a single vertex.
Execution:
  Arrange: Create a DepthFirstSearch instance and an IGraph<DFSVertex> with one vertex.
  Act: Call the Run method with the single-vertex graph.
  Assert: Check that the vertex's StartTime and EndTime are set and Processed is true.
Validation:
  This test ensures that the basic functionality works for the simplest possible graph.

Scenario 4: Fully Connected Graph

Details:
  TestName: ProcessFullyConnectedGraphCorrectly
  Description: Ensure that the method correctly processes a fully connected graph (where every vertex is connected to every other vertex).
Execution:
  Arrange: Create a DepthFirstSearch instance and a fully connected IGraph<DFSVertex>.
  Act: Call the Run method with the fully connected graph.
  Assert: Verify that all vertices are processed, have valid StartTime and EndTime, and form a valid DFS tree.
Validation:
  This test checks the method's ability to handle complex graph structures without getting stuck in cycles.

Scenario 5: Disconnected Graph

Details:
  TestName: ProcessDisconnectedGraphComponents
  Description: Verify that the method correctly processes all components of a disconnected graph.
Execution:
  Arrange: Create a DepthFirstSearch instance and an IGraph<DFSVertex> with multiple disconnected components.
  Act: Call the Run method with the disconnected graph.
  Assert: Check that all vertices in all components are processed and have valid StartTime and EndTime values.
Validation:
  This test ensures that the method can handle graphs that are not fully connected, processing all vertices regardless of connectivity.

Scenario 6: Graph with Cycles

Details:
  TestName: HandleGraphWithCyclesCorrectly
  Description: Ensure that the method correctly processes a graph containing cycles without getting stuck in an infinite loop.
Execution:
  Arrange: Create a DepthFirstSearch instance and an IGraph<DFSVertex> containing at least one cycle.
  Act: Call the Run method with the cyclic graph.
  Assert: Verify that all vertices are processed exactly once and have valid StartTime and EndTime values.
Validation:
  This test checks the method's ability to handle cycles in the graph, which is a common edge case in graph traversal algorithms.

Scenario 7: Large Graph Performance

Details:
  TestName: ProcessLargeGraphWithinReasonableTime
  Description: Verify that the method can process a large graph within a reasonable time frame.
Execution:
  Arrange: Create a DepthFirstSearch instance and a large IGraph<DFSVertex> (e.g., 10,000+ vertices).
  Act: Call the Run method with the large graph and measure the execution time.
  Assert: Check that all vertices are processed and the execution completes within an acceptable time limit.
Validation:
  This test ensures that the method's performance scales well with larger graphs, which is crucial for real-world applications.

These test scenarios cover various aspects of the `Run` method, including edge cases, error handling, and performance considerations. They should provide a comprehensive test suite for the DepthFirstSearch class.


*/

// ********RoostGPT********
using NUnit.Framework;
using LunarDoggo.Datastructures.Graphs;
using LunarDoggo.Algorithms.Graphs.Pathfinding;
using System;
using System.Linq;

namespace LunarDoggo.Algorithms.Graphs.Pathfinding.Test
{
    [TestFixture]
    public class Run316Test
    {
        private DepthFirstSearch dfs;

        [SetUp]
        public void Setup()
        {
            dfs = new DepthFirstSearch();
        }

        [Test, Category("invalid")]
        public void ThrowArgumentNullExceptionWhenGraphIsNull()
        {
            Assert.Throws<ArgumentNullException>(() => dfs.Run(null));
        }

        [Test, Category("valid")]
        public void ProcessEmptyGraphWithoutException()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            Assert.DoesNotThrow(() => dfs.Run(graph));
        }

        [Test, Category("valid")]
        public void ProcessSingleVertexGraphCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var vertex = graph.AddVertex(new DFSVertex());

            dfs.Run(graph);

            Assert.That(vertex.Value.Processed, Is.True);
            Assert.That(vertex.Value.StartTime, Is.GreaterThanOrEqualTo(0));
            Assert.That(vertex.Value.EndTime, Is.GreaterThan(vertex.Value.StartTime));
        }

        [Test, Category("valid")]
        public void ProcessFullyConnectedGraphCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var vertices = Enumerable.Range(0, 5).Select(_ => graph.AddVertex(new DFSVertex())).ToList();

            for (int i = 0; i < vertices.Count; i++)
            {
                for (int j = i + 1; j < vertices.Count; j++)
                {
                    graph.AddEdge(vertices[i], vertices[j]);
                }
            }

            dfs.Run(graph);

            Assert.That(vertices.All(v => v.Value.Processed), Is.True);
            Assert.That(vertices.All(v => v.Value.StartTime >= 0), Is.True);
            Assert.That(vertices.All(v => v.Value.EndTime > v.Value.StartTime), Is.True);
        }

        [Test, Category("valid")]
        public void ProcessDisconnectedGraphComponents()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var component1 = new[] { graph.AddVertex(new DFSVertex()), graph.AddVertex(new DFSVertex()) };
            var component2 = new[] { graph.AddVertex(new DFSVertex()), graph.AddVertex(new DFSVertex()) };

            graph.AddEdge(component1[0], component1[1]);
            graph.AddEdge(component2[0], component2[1]);

            dfs.Run(graph);

            Assert.That(graph.Vertices.All(v => v.Value.Processed), Is.True);
            Assert.That(graph.Vertices.All(v => v.Value.StartTime >= 0), Is.True);
            Assert.That(graph.Vertices.All(v => v.Value.EndTime > v.Value.StartTime), Is.True);
        }

        [Test, Category("valid")]
        public void HandleGraphWithCyclesCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var vertices = Enumerable.Range(0, 4).Select(_ => graph.AddVertex(new DFSVertex())).ToArray();

            graph.AddEdge(vertices[0], vertices[1]);
            graph.AddEdge(vertices[1], vertices[2]);
            graph.AddEdge(vertices[2], vertices[3]);
            graph.AddEdge(vertices[3], vertices[0]);

            dfs.Run(graph);

            Assert.That(graph.Vertices.All(v => v.Value.Processed), Is.True);
            Assert.That(graph.Vertices.All(v => v.Value.StartTime >= 0), Is.True);
            Assert.That(graph.Vertices.All(v => v.Value.EndTime > v.Value.StartTime), Is.True);
        }

        [Test, Category("valid")]
        public void ProcessLargeGraphWithinReasonableTime()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var vertices = Enumerable.Range(0, 10000).Select(_ => graph.AddVertex(new DFSVertex())).ToList();

            for (int i = 0; i < vertices.Count - 1; i++)
            {
                graph.AddEdge(vertices[i], vertices[i + 1]);
            }

            var stopwatch = System.Diagnostics.Stopwatch.StartNew();
            dfs.Run(graph);
            stopwatch.Stop();

            Assert.That(graph.Vertices.All(v => v.Value.Processed), Is.True);
            Assert.That(stopwatch.ElapsedMilliseconds, Is.LessThan(5000), "DFS took too long to process");
        }
    }
}
