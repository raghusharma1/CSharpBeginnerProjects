// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleCSharpEnv using AI Type  and AI Model 

ROOST_METHOD_HASH=Run_a2e9436d0a
ROOST_METHOD_SIG_HASH=Run_9ce955ed80

   ########## Test-Scenarios ##########  

Based on the provided method and related code, here are several test scenarios for the `Run` method of the `DepthFirstSearch` class:

Scenario 1: Null Graph Input

Details:
  TestName: ThrowArgumentNullExceptionWhenGraphIsNull
  Description: Verify that the method throws an ArgumentNullException when a null graph is provided.
Execution:
  Arrange: Create a DepthFirstSearch instance with no graph.
  Act: Call the Run method with a null graph.
  Assert: Expect an ArgumentNullException to be thrown.
Validation:
  This test ensures that the method properly handles null input, preventing potential null reference exceptions later in the execution.

Scenario 2: Empty Graph

Details:
  TestName: ProcessEmptyGraphWithoutException
  Description: Ensure the method can handle an empty graph without throwing exceptions.
Execution:
  Arrange: Create an empty IGraph<DFSVertex> instance.
  Act: Call the Run method with the empty graph.
  Assert: Verify that no exception is thrown and the method completes successfully.
Validation:
  This test confirms that the method can handle edge cases like empty graphs gracefully.

Scenario 3: Single Vertex Graph

Details:
  TestName: ProcessSingleVertexGraphCorrectly
  Description: Check if the method correctly processes a graph with only one vertex.
Execution:
  Arrange: Create an IGraph<DFSVertex> with a single vertex.
  Act: Run the DepthFirstSearch on this graph.
  Assert: Verify that the vertex's StartTime and EndTime are set and Processed is true.
Validation:
  This test ensures that the basic functionality works for the simplest possible graph.

Scenario 4: Cyclic Graph

Details:
  TestName: HandleCyclicGraphWithoutInfiniteLoop
  Description: Ensure the method can process a graph with cycles without getting stuck in an infinite loop.
Execution:
  Arrange: Create a cyclic graph with at least three vertices forming a loop.
  Act: Run the DepthFirstSearch on this graph.
  Assert: Check that all vertices are processed and have valid StartTime and EndTime values.
Validation:
  This test verifies that the algorithm can handle cycles in the graph, which is a common edge case for graph traversal algorithms.

Scenario 5: Disconnected Graph

Details:
  TestName: ProcessAllComponentsOfDisconnectedGraph
  Description: Verify that the method processes all components of a disconnected graph.
Execution:
  Arrange: Create a graph with multiple disconnected components.
  Act: Run the DepthFirstSearch on this graph.
  Assert: Ensure all vertices in all components are processed.
Validation:
  This test confirms that the method can handle graphs that are not fully connected, processing all vertices regardless of connectivity.

Scenario 6: Large Graph Performance

Details:
  TestName: ProcessLargeGraphWithinReasonableTime
  Description: Check if the method can handle a large graph within a reasonable time frame.
Execution:
  Arrange: Create a large graph with many vertices and edges.
  Act: Run the DepthFirstSearch on this graph, measuring the execution time.
  Assert: Verify that the method completes within an acceptable time limit and processes all vertices.
Validation:
  This test ensures that the implementation is efficient enough to handle large datasets, which is crucial for real-world applications.

Scenario 7: Correct Predecessor Assignment

Details:
  TestName: AssignCorrectPredecessorsInSimpleGraph
  Description: Verify that the method correctly assigns predecessors to vertices in a simple graph.
Execution:
  Arrange: Create a simple graph with a known structure.
  Act: Run the DepthFirstSearch on this graph.
  Assert: Check that each vertex has the correct predecessor assigned based on the expected DFS traversal.
Validation:
  This test ensures that the core functionality of tracking the search path is working correctly.

Scenario 8: Correct Start and End Times

Details:
  TestName: AssignCorrectStartAndEndTimesInGraph
  Description: Ensure that the start and end times for each vertex are assigned correctly and in the right order.
Execution:
  Arrange: Create a graph with a known structure.
  Act: Run the DepthFirstSearch on this graph.
  Assert: Verify that the start and end times for each vertex are consistent with a valid DFS traversal.
Validation:
  This test checks the correctness of the time assignment, which is crucial for applications that rely on the DFS ordering.

These scenarios cover various aspects of the DepthFirstSearch implementation, including edge cases, error handling, and core functionality. They should provide a comprehensive test suite for the given method.


*/

// ********RoostGPT********
using NUnit.Framework;
using LunarDoggo.Datastructures.Graphs;
using LunarDoggo.Algorithms.Graphs.Pathfinding;
using System;
using System.Linq;

namespace LunarDoggo.Algorithms.Graphs.Pathfinding.Test
{
    [TestFixture]
    public class Run685Test
    {
        private DepthFirstSearch dfs;

        [SetUp]
        public void Setup()
        {
            dfs = new DepthFirstSearch();
        }

        [Test, Category("invalid")]
        public void ThrowArgumentNullExceptionWhenGraphIsNull()
        {
            Assert.Throws<ArgumentNullException>(() => dfs.Run(null));
        }

        [Test, Category("valid")]
        public void ProcessEmptyGraphWithoutException()
        {
            var emptyGraph = new UndirectedUnweightedGraph<DFSVertex>();
            Assert.DoesNotThrow(() => dfs.Run(emptyGraph));
        }

        [Test, Category("valid")]
        public void ProcessSingleVertexGraphCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var vertex = graph.AddVertex(new DFSVertex());

            dfs.Run(graph);

            Assert.That(vertex.Value.Processed, Is.True);
            Assert.That(vertex.Value.StartTime, Is.GreaterThanOrEqualTo(0));
            Assert.That(vertex.Value.EndTime, Is.GreaterThan(vertex.Value.StartTime));
        }

        [Test, Category("valid")]
        public void HandleCyclicGraphWithoutInfiniteLoop()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var v1 = graph.AddVertex(new DFSVertex());
            var v2 = graph.AddVertex(new DFSVertex());
            var v3 = graph.AddVertex(new DFSVertex());

            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);
            graph.AddEdge(v3, v1);

            dfs.Run(graph);

            Assert.That(graph.Vertices.All(v => v.Value.Processed), Is.True);
            Assert.That(graph.Vertices.All(v => v.Value.StartTime >= 0), Is.True);
            Assert.That(graph.Vertices.All(v => v.Value.EndTime > v.Value.StartTime), Is.True);
        }

        [Test, Category("valid")]
        public void ProcessAllComponentsOfDisconnectedGraph()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var v1 = graph.AddVertex(new DFSVertex());
            var v2 = graph.AddVertex(new DFSVertex());
            var v3 = graph.AddVertex(new DFSVertex());
            var v4 = graph.AddVertex(new DFSVertex());

            graph.AddEdge(v1, v2);
            graph.AddEdge(v3, v4);

            dfs.Run(graph);

            Assert.That(graph.Vertices.All(v => v.Value.Processed), Is.True);
        }

        [Test, Category("valid")]
        public void ProcessLargeGraphWithinReasonableTime()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            for (int i = 0; i < 10000; i++)
            {
                graph.AddVertex(new DFSVertex());
            }

            for (int i = 0; i < 9999; i++)
            {
                graph.AddEdge(graph.Vertices.ElementAt(i), graph.Vertices.ElementAt(i + 1));
            }

            Assert.That(() => dfs.Run(graph), Throws.Nothing.And.CompletesBefore(TimeSpan.FromSeconds(5)));
        }

        [Test, Category("valid")]
        public void AssignCorrectPredecessorsInSimpleGraph()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var v1 = graph.AddVertex(new DFSVertex());
            var v2 = graph.AddVertex(new DFSVertex());
            var v3 = graph.AddVertex(new DFSVertex());

            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);

            dfs.Run(graph);

            Assert.That(v1.Value.Predecessor, Is.Null);
            Assert.That(v2.Value.Predecessor, Is.EqualTo(v1));
            Assert.That(v3.Value.Predecessor, Is.EqualTo(v2));
        }

        [Test, Category("valid")]
        public void AssignCorrectStartAndEndTimesInGraph()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var v1 = graph.AddVertex(new DFSVertex());
            var v2 = graph.AddVertex(new DFSVertex());
            var v3 = graph.AddVertex(new DFSVertex());

            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);

            dfs.Run(graph);

            Assert.That(v1.Value.StartTime, Is.LessThan(v2.Value.StartTime));
            Assert.That(v2.Value.StartTime, Is.LessThan(v3.Value.StartTime));
            Assert.That(v3.Value.EndTime, Is.LessThan(v2.Value.EndTime));
            Assert.That(v2.Value.EndTime, Is.LessThan(v1.Value.EndTime));
        }
    }
}
