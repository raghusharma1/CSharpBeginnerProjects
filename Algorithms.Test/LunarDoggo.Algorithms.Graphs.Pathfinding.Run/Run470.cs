// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleCSharpEnv using AI Type  and AI Model 

ROOST_METHOD_HASH=Run_a2e9436d0a
ROOST_METHOD_SIG_HASH=Run_9ce955ed80

   ########## Test-Scenarios ##########  

Based on the provided method and related code, here are several test scenarios for the `Run` method of the `DepthFirstSearch` class:

Scenario 1: Null Graph Handling

Details:
  TestName: ThrowsArgumentNullExceptionWhenGraphIsNull
  Description: Verify that the method throws an ArgumentNullException when a null graph is passed.

Execution:
  Arrange: Create a DepthFirstSearch instance.
  Act: Call the Run method with a null graph.
  Assert: Expect an ArgumentNullException to be thrown.

Validation:
  This test ensures that the method properly handles null input, preventing null reference exceptions later in the execution.

Scenario 2: Empty Graph Processing

Details:
  TestName: ProcessesEmptyGraphWithoutErrors
  Description: Ensure the method can handle an empty graph without throwing exceptions.

Execution:
  Arrange: Create a DepthFirstSearch instance and an empty UndirectedUnweightedGraph<DFSVertex>.
  Act: Call the Run method with the empty graph.
  Assert: Verify that no exception is thrown and the method completes successfully.

Validation:
  This test confirms that the method can handle edge cases like empty graphs gracefully.

Scenario 3: Single Vertex Graph Processing

Details:
  TestName: ProcessesSingleVertexGraphCorrectly
  Description: Verify that a graph with a single vertex is processed correctly.

Execution:
  Arrange: Create a DepthFirstSearch instance and a UndirectedUnweightedGraph<DFSVertex> with one vertex.
  Act: Call the Run method with the graph.
  Assert: Check that the vertex's StartTime and EndTime are set and not equal to -1.

Validation:
  This test ensures that the basic processing of a vertex works as expected, even in a minimal graph.

Scenario 4: Connected Graph Full Traversal

Details:
  TestName: TraversesAllVerticesInConnectedGraph
  Description: Ensure all vertices in a connected graph are visited and processed.

Execution:
  Arrange: Create a DepthFirstSearch instance and a UndirectedUnweightedGraph<DFSVertex> with multiple connected vertices.
  Act: Call the Run method with the graph.
  Assert: Verify that all vertices have been processed (StartTime and EndTime not equal to -1).

Validation:
  This test confirms that the DFS algorithm traverses all vertices in a connected graph.

Scenario 5: Disconnected Graph Full Traversal

Details:
  TestName: TraversesAllComponentsInDisconnectedGraph
  Description: Verify that all components of a disconnected graph are fully traversed.

Execution:
  Arrange: Create a DepthFirstSearch instance and a UndirectedUnweightedGraph<DFSVertex> with multiple disconnected components.
  Act: Call the Run method with the graph.
  Assert: Check that all vertices in all components have been processed.

Validation:
  This test ensures that the algorithm can handle disconnected graphs and visits all vertices regardless of connectivity.

Scenario 6: Correct Start and End Times

Details:
  TestName: AssignsCorrectStartAndEndTimesToVertices
  Description: Verify that start and end times are assigned correctly to vertices during traversal.

Execution:
  Arrange: Create a DepthFirstSearch instance and a UndirectedUnweightedGraph<DFSVertex> with a known structure.
  Act: Call the Run method with the graph.
  Assert: Check that for each vertex, StartTime < EndTime, and that times are unique and sequential.

Validation:
  This test confirms that the time assignment aspect of the DFS algorithm is working correctly, which is crucial for understanding the traversal order.

Scenario 7: Correct Predecessor Assignment

Details:
  TestName: AssignsCorrectPredecessorsToVertices
  Description: Ensure that predecessors are correctly assigned during the traversal.

Execution:
  Arrange: Create a DepthFirstSearch instance and a UndirectedUnweightedGraph<DFSVertex> with a known structure.
  Act: Call the Run method with the graph.
  Assert: Verify that each vertex (except the start vertex) has a predecessor that is adjacent to it.

Validation:
  This test checks that the predecessor relationships are correctly established, which is important for reconstructing paths or understanding the traversal structure.

Scenario 8: Cyclic Graph Handling

Details:
  TestName: HandlesGraphWithCyclesCorrectly
  Description: Verify that the algorithm correctly processes a graph containing cycles.

Execution:
  Arrange: Create a DepthFirstSearch instance and a UndirectedUnweightedGraph<DFSVertex> with cycles.
  Act: Call the Run method with the graph.
  Assert: Check that all vertices are processed without getting stuck in an infinite loop.

Validation:
  This test ensures that the DFS algorithm can handle graphs with cycles, which is a common scenario in real-world graph problems.

These test scenarios cover various aspects of the DepthFirstSearch.Run method, including edge cases, error handling, and different graph structures. They aim to ensure the correctness and robustness of the DFS implementation.


*/

// ********RoostGPT********
using NUnit.Framework;
using LunarDoggo.Datastructures.Graphs;
using LunarDoggo.Algorithms.Graphs.Pathfinding;
using System;

namespace LunarDoggo.Algorithms.Graphs.Pathfinding.Test
{
    [TestFixture]
    public class Run470Test
    {
        private DepthFirstSearch dfs;

        [SetUp]
        public void Setup()
        {
            dfs = new DepthFirstSearch();
        }

        [Test, Category("invalid")]
        public void ThrowsArgumentNullExceptionWhenGraphIsNull()
        {
            Assert.Throws<ArgumentNullException>(() => dfs.Run(null));
        }

        [Test, Category("valid")]
        public void ProcessesEmptyGraphWithoutErrors()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            Assert.DoesNotThrow(() => dfs.Run(graph));
        }

        [Test, Category("valid")]
        public void ProcessesSingleVertexGraphCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var vertex = graph.AddVertex(new DFSVertex());
            
            dfs.Run(graph);

            Assert.That(vertex.Value.StartTime, Is.Not.EqualTo(-1));
            Assert.That(vertex.Value.EndTime, Is.Not.EqualTo(-1));
        }

        [Test, Category("valid")]
        public void TraversesAllVerticesInConnectedGraph()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var v1 = graph.AddVertex(new DFSVertex());
            var v2 = graph.AddVertex(new DFSVertex());
            var v3 = graph.AddVertex(new DFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);

            dfs.Run(graph);

            foreach (var vertex in graph.Vertices)
            {
                Assert.That(vertex.Value.StartTime, Is.Not.EqualTo(-1));
                Assert.That(vertex.Value.EndTime, Is.Not.EqualTo(-1));
            }
        }

        [Test, Category("valid")]
        public void TraversesAllComponentsInDisconnectedGraph()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var v1 = graph.AddVertex(new DFSVertex());
            var v2 = graph.AddVertex(new DFSVertex());
            var v3 = graph.AddVertex(new DFSVertex());
            var v4 = graph.AddVertex(new DFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v3, v4);

            dfs.Run(graph);

            foreach (var vertex in graph.Vertices)
            {
                Assert.That(vertex.Value.StartTime, Is.Not.EqualTo(-1));
                Assert.That(vertex.Value.EndTime, Is.Not.EqualTo(-1));
            }
        }

        [Test, Category("valid")]
        public void AssignsCorrectStartAndEndTimesToVertices()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var v1 = graph.AddVertex(new DFSVertex());
            var v2 = graph.AddVertex(new DFSVertex());
            var v3 = graph.AddVertex(new DFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);

            dfs.Run(graph);

            foreach (var vertex in graph.Vertices)
            {
                Assert.That(vertex.Value.StartTime, Is.LessThan(vertex.Value.EndTime));
            }

            var allTimes = graph.Vertices.SelectMany(v => new[] { v.Value.StartTime, v.Value.EndTime }).OrderBy(t => t).ToList();
            for (int i = 0; i < allTimes.Count - 1; i++)
            {
                Assert.That(allTimes[i], Is.LessThan(allTimes[i + 1]));
            }
        }

        [Test, Category("valid")]
        public void AssignsCorrectPredecessorsToVertices()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var v1 = graph.AddVertex(new DFSVertex());
            var v2 = graph.AddVertex(new DFSVertex());
            var v3 = graph.AddVertex(new DFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);

            dfs.Run(graph);

            Assert.That(v1.Value.Predecessor, Is.Null);
            Assert.That(v2.Value.Predecessor, Is.Not.Null);
            Assert.That(v3.Value.Predecessor, Is.Not.Null);
            Assert.That(v2.Adjacent.Contains(v2.Value.Predecessor), Is.True);
            Assert.That(v3.Adjacent.Contains(v3.Value.Predecessor), Is.True);
        }

        [Test, Category("valid")]
        public void HandlesGraphWithCyclesCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var v1 = graph.AddVertex(new DFSVertex());
            var v2 = graph.AddVertex(new DFSVertex());
            var v3 = graph.AddVertex(new DFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);
            graph.AddEdge(v3, v1);

            dfs.Run(graph);

            foreach (var vertex in graph.Vertices)
            {
                Assert.That(vertex.Value.StartTime, Is.Not.EqualTo(-1));
                Assert.That(vertex.Value.EndTime, Is.Not.EqualTo(-1));
            }
        }
    }
}
