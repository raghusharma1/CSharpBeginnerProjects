// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleCSharpEnv using AI Type  and AI Model 

ROOST_METHOD_HASH=Run_a2e9436d0a
ROOST_METHOD_SIG_HASH=Run_9ce955ed80

   ########## Test-Scenarios ##########  

Based on the provided method and related code, here are several test scenarios for the `Run` method of the `DepthFirstSearch` class:

Scenario 1: Null Graph Input

Details:
  TestName: ThrowArgumentNullExceptionWhenGraphIsNull
  Description: Verify that the method throws an ArgumentNullException when a null graph is passed as an argument.
Execution:
  Arrange: Create a DepthFirstSearch instance.
  Act: Call the Run method with a null graph.
  Assert: Expect an ArgumentNullException to be thrown.
Validation:
  This test ensures that the method properly handles null input, preventing potential null reference exceptions later in the execution.

Scenario 2: Empty Graph

Details:
  TestName: RunSuccessfullyOnEmptyGraph
  Description: Ensure the method can handle an empty graph without throwing exceptions.
Execution:
  Arrange: Create a DepthFirstSearch instance and an empty UndirectedUnweightedGraph<DFSVertex>.
  Act: Call the Run method with the empty graph.
  Assert: Verify that no exception is thrown and the method completes successfully.
Validation:
  This test confirms that the method can handle edge cases like empty graphs without errors.

Scenario 3: Single Vertex Graph

Details:
  TestName: ProcessSingleVertexGraphCorrectly
  Description: Check if the method correctly processes a graph with only one vertex.
Execution:
  Arrange: Create a DepthFirstSearch instance and a UndirectedUnweightedGraph<DFSVertex> with one vertex.
  Act: Call the Run method with the single-vertex graph.
  Assert: Verify that the vertex's StartTime and EndTime are set and Processed is true.
Validation:
  This test ensures that the basic functionality works for the simplest possible graph.

Scenario 4: Connected Graph

Details:
  TestName: ProcessAllVerticesInConnectedGraph
  Description: Verify that all vertices in a connected graph are processed.
Execution:
  Arrange: Create a DepthFirstSearch instance and a UndirectedUnweightedGraph<DFSVertex> with multiple connected vertices.
  Act: Call the Run method with the connected graph.
  Assert: Check that all vertices have been processed (Processed is true, StartTime and EndTime are set).
Validation:
  This test confirms that the method correctly traverses all vertices in a connected graph.

Scenario 5: Disconnected Graph

Details:
  TestName: ProcessAllComponentsInDisconnectedGraph
  Description: Ensure that all components of a disconnected graph are processed.
Execution:
  Arrange: Create a DepthFirstSearch instance and a UndirectedUnweightedGraph<DFSVertex> with multiple disconnected components.
  Act: Call the Run method with the disconnected graph.
  Assert: Verify that all vertices in all components have been processed.
Validation:
  This test checks if the method can handle disconnected graphs by processing all components.

Scenario 6: Cyclic Graph

Details:
  TestName: HandleCyclicGraphWithoutInfiniteLoop
  Description: Check if the method can process a graph containing cycles without getting stuck in an infinite loop.
Execution:
  Arrange: Create a DepthFirstSearch instance and a UndirectedUnweightedGraph<DFSVertex> with cycles.
  Act: Call the Run method with the cyclic graph.
  Assert: Confirm that all vertices are processed and the method terminates.
Validation:
  This test ensures that the method can handle graphs with cycles, which is crucial for preventing infinite recursion.

Scenario 7: Verify Correct Start and End Times

Details:
  TestName: AssignCorrectStartAndEndTimesToVertices
  Description: Verify that the start and end times for each vertex are assigned correctly and in the right order.
Execution:
  Arrange: Create a DepthFirstSearch instance and a UndirectedUnweightedGraph<DFSVertex> with a known structure.
  Act: Call the Run method with the graph.
  Assert: Check that for each vertex, StartTime < EndTime, and that the times are consistent with the DFS order.
Validation:
  This test confirms that the time assignment, which is crucial for many DFS applications, is working correctly.

Scenario 8: Verify Predecessor Assignment

Details:
  TestName: AssignCorrectPredecessorsToVertices
  Description: Ensure that the predecessor for each vertex is set correctly during the DFS traversal.
Execution:
  Arrange: Create a DepthFirstSearch instance and a UndirectedUnweightedGraph<DFSVertex> with a known structure.
  Act: Call the Run method with the graph.
  Assert: Verify that each vertex (except the start vertex) has a predecessor that matches the expected DFS tree.
Validation:
  This test checks if the predecessor assignment, which is important for reconstructing paths or understanding the DFS tree, is working as expected.

These test scenarios cover various aspects of the DepthFirstSearch.Run method, including edge cases, different graph structures, and the correctness of the DFS algorithm implementation.


*/

// ********RoostGPT********
using NUnit.Framework;
using LunarDoggo.Datastructures.Graphs;
using LunarDoggo.Algorithms.Graphs.Pathfinding;
using System;

namespace LunarDoggo.Algorithms.Graphs.Pathfinding.Test
{
    [TestFixture]
    public class Run991Test
    {
        private DepthFirstSearch dfs;

        [SetUp]
        public void Setup()
        {
            dfs = new DepthFirstSearch();
        }

        [Test, Category("invalid")]
        public void ThrowArgumentNullExceptionWhenGraphIsNull()
        {
            Assert.Throws<ArgumentNullException>(() => dfs.Run(null));
        }

        [Test, Category("boundary")]
        public void RunSuccessfullyOnEmptyGraph()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            Assert.DoesNotThrow(() => dfs.Run(graph));
        }

        [Test, Category("valid")]
        public void ProcessSingleVertexGraphCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var vertex = graph.AddVertex(new DFSVertex());

            dfs.Run(graph);

            Assert.IsTrue(vertex.Value.Processed);
            Assert.Greater(vertex.Value.StartTime, -1);
            Assert.Greater(vertex.Value.EndTime, vertex.Value.StartTime);
        }

        [Test, Category("valid")]
        public void ProcessAllVerticesInConnectedGraph()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var v1 = graph.AddVertex(new DFSVertex());
            var v2 = graph.AddVertex(new DFSVertex());
            var v3 = graph.AddVertex(new DFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);

            dfs.Run(graph);

            foreach (var vertex in graph.Vertices)
            {
                Assert.IsTrue(vertex.Value.Processed);
                Assert.Greater(vertex.Value.StartTime, -1);
                Assert.Greater(vertex.Value.EndTime, vertex.Value.StartTime);
            }
        }

        [Test, Category("valid")]
        public void ProcessAllComponentsInDisconnectedGraph()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var v1 = graph.AddVertex(new DFSVertex());
            var v2 = graph.AddVertex(new DFSVertex());
            var v3 = graph.AddVertex(new DFSVertex());
            var v4 = graph.AddVertex(new DFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v3, v4);

            dfs.Run(graph);

            foreach (var vertex in graph.Vertices)
            {
                Assert.IsTrue(vertex.Value.Processed);
                Assert.Greater(vertex.Value.StartTime, -1);
                Assert.Greater(vertex.Value.EndTime, vertex.Value.StartTime);
            }
        }

        [Test, Category("valid")]
        public void HandleCyclicGraphWithoutInfiniteLoop()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var v1 = graph.AddVertex(new DFSVertex());
            var v2 = graph.AddVertex(new DFSVertex());
            var v3 = graph.AddVertex(new DFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);
            graph.AddEdge(v3, v1);

            Assert.DoesNotThrow(() => dfs.Run(graph));

            foreach (var vertex in graph.Vertices)
            {
                Assert.IsTrue(vertex.Value.Processed);
                Assert.Greater(vertex.Value.StartTime, -1);
                Assert.Greater(vertex.Value.EndTime, vertex.Value.StartTime);
            }
        }

        [Test, Category("valid")]
        public void AssignCorrectStartAndEndTimesToVertices()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var v1 = graph.AddVertex(new DFSVertex());
            var v2 = graph.AddVertex(new DFSVertex());
            var v3 = graph.AddVertex(new DFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);

            dfs.Run(graph);

            Assert.Less(v1.Value.StartTime, v1.Value.EndTime);
            Assert.Less(v2.Value.StartTime, v2.Value.EndTime);
            Assert.Less(v3.Value.StartTime, v3.Value.EndTime);

            Assert.Less(v1.Value.StartTime, v2.Value.StartTime);
            Assert.Less(v2.Value.StartTime, v3.Value.StartTime);
            Assert.Greater(v1.Value.EndTime, v3.Value.EndTime);
        }

        [Test, Category("valid")]
        public void AssignCorrectPredecessorsToVertices()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var v1 = graph.AddVertex(new DFSVertex());
            var v2 = graph.AddVertex(new DFSVertex());
            var v3 = graph.AddVertex(new DFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);

            dfs.Run(graph);

            Assert.IsNull(v1.Value.Predecessor);
            Assert.AreEqual(v1, v2.Value.Predecessor);
            Assert.AreEqual(v2, v3.Value.Predecessor);
        }
    }
}
