// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleCSharpEnv using AI Type  and AI Model 

ROOST_METHOD_HASH=Run_a2e9436d0a
ROOST_METHOD_SIG_HASH=Run_9ce955ed80

   ########## Test-Scenarios ##########  

Based on the provided method and related code, here are several test scenarios for the `Run` method of the `DepthFirstSearch` class:

Scenario 1: Null Graph Input

Details:
  TestName: ThrowArgumentNullExceptionWhenGraphIsNull
  Description: Verify that the method throws an ArgumentNullException when a null graph is provided.
Execution:
  Arrange: Create a DepthFirstSearch instance.
  Act: Call the Run method with a null graph.
  Assert: Expect an ArgumentNullException to be thrown.
Validation:
  This test ensures that the method properly handles null input, preventing potential null reference exceptions later in the execution.

Scenario 2: Empty Graph

Details:
  TestName: ProcessEmptyGraphWithoutException
  Description: Ensure the method can handle an empty graph without throwing exceptions.
Execution:
  Arrange: Create a DepthFirstSearch instance and an empty UndirectedUnweightedGraph<DFSVertex>.
  Act: Call the Run method with the empty graph.
  Assert: Verify that no exception is thrown and the method completes successfully.
Validation:
  This test confirms that the method can handle edge cases like empty graphs gracefully.

Scenario 3: Single Vertex Graph

Details:
  TestName: ProcessSingleVertexGraphCorrectly
  Description: Verify that a graph with a single vertex is processed correctly.
Execution:
  Arrange: Create a DepthFirstSearch instance and a UndirectedUnweightedGraph<DFSVertex> with one vertex.
  Act: Call the Run method with the graph.
  Assert: Check that the vertex's StartTime and EndTime are set and Processed is true.
Validation:
  This test ensures that the basic functionality works for the simplest possible graph.

Scenario 4: Linear Graph

Details:
  TestName: ProcessLinearGraphInCorrectOrder
  Description: Verify that a linear graph (vertices connected in a line) is processed in the correct order.
Execution:
  Arrange: Create a DepthFirstSearch instance and a UndirectedUnweightedGraph<DFSVertex> with multiple vertices connected linearly.
  Act: Call the Run method with the graph.
  Assert: Verify that the StartTime and EndTime of each vertex are in the correct ascending order.
Validation:
  This test checks if the depth-first traversal works correctly for a simple linear structure.

Scenario 5: Cyclic Graph

Details:
  TestName: HandleCyclicGraphWithoutInfiniteLoop
  Description: Ensure that a graph with cycles is processed without getting stuck in an infinite loop.
Execution:
  Arrange: Create a DepthFirstSearch instance and a UndirectedUnweightedGraph<DFSVertex> with a cycle.
  Act: Call the Run method with the graph.
  Assert: Verify that all vertices are processed (Processed is true for all) and have valid StartTime and EndTime values.
Validation:
  This test confirms that the algorithm can handle cycles in the graph, which is a critical aspect of depth-first search.

Scenario 6: Disconnected Graph

Details:
  TestName: ProcessAllComponentsOfDisconnectedGraph
  Description: Verify that all components of a disconnected graph are processed.
Execution:
  Arrange: Create a DepthFirstSearch instance and a UndirectedUnweightedGraph<DFSVertex> with multiple disconnected components.
  Act: Call the Run method with the graph.
  Assert: Check that all vertices in all components are processed and have valid StartTime and EndTime values.
Validation:
  This test ensures that the algorithm doesn't stop after processing just one connected component but continues to process all vertices in the graph.

Scenario 7: Graph with Pre-initialized Vertices

Details:
  TestName: ResetPreInitializedVerticesCorrectly
  Description: Ensure that vertices with pre-existing DFSVertex values are correctly reset and processed.
Execution:
  Arrange: Create a DepthFirstSearch instance and a UndirectedUnweightedGraph<DFSVertex>. Initialize some vertices with non-default DFSVertex values.
  Act: Call the Run method with the graph.
  Assert: Verify that all vertices are processed, regardless of their initial state, and have new, valid StartTime and EndTime values.
Validation:
  This test checks if the Initialize method correctly resets all vertices before processing, ensuring consistent behavior regardless of initial vertex states.

These scenarios cover various aspects of the DepthFirstSearch.Run method, including edge cases, error handling, and different graph structures. They aim to ensure the correctness and robustness of the depth-first search implementation.


*/

// ********RoostGPT********
using NUnit.Framework;
using LunarDoggo.Datastructures.Graphs;
using LunarDoggo.Algorithms.Graphs.Pathfinding;
using System;

namespace LunarDoggo.Algorithms.Graphs.Pathfinding.Test
{
    [TestFixture]
    public class Run391Test
    {
        private DepthFirstSearch dfs;

        [SetUp]
        public void Setup()
        {
            dfs = new DepthFirstSearch();
        }

        [Test, Category("invalid")]
        public void ThrowArgumentNullExceptionWhenGraphIsNull()
        {
            Assert.Throws<ArgumentNullException>(() => dfs.Run(null));
        }

        [Test, Category("valid")]
        public void ProcessEmptyGraphWithoutException()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            Assert.DoesNotThrow(() => dfs.Run(graph));
        }

        [Test, Category("valid")]
        public void ProcessSingleVertexGraphCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var vertex = graph.AddVertex(new DFSVertex());

            dfs.Run(graph);

            Assert.That(vertex.Value.Processed, Is.True);
            Assert.That(vertex.Value.StartTime, Is.GreaterThanOrEqualTo(0));
            Assert.That(vertex.Value.EndTime, Is.GreaterThan(vertex.Value.StartTime));
        }

        [Test, Category("valid")]
        public void ProcessLinearGraphInCorrectOrder()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var v1 = graph.AddVertex(new DFSVertex());
            var v2 = graph.AddVertex(new DFSVertex());
            var v3 = graph.AddVertex(new DFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);

            dfs.Run(graph);

            Assert.That(v1.Value.StartTime, Is.LessThan(v2.Value.StartTime));
            Assert.That(v2.Value.StartTime, Is.LessThan(v3.Value.StartTime));
            Assert.That(v3.Value.EndTime, Is.LessThan(v2.Value.EndTime));
            Assert.That(v2.Value.EndTime, Is.LessThan(v1.Value.EndTime));
        }

        [Test, Category("valid")]
        public void HandleCyclicGraphWithoutInfiniteLoop()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var v1 = graph.AddVertex(new DFSVertex());
            var v2 = graph.AddVertex(new DFSVertex());
            var v3 = graph.AddVertex(new DFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);
            graph.AddEdge(v3, v1);

            dfs.Run(graph);

            Assert.That(v1.Value.Processed && v2.Value.Processed && v3.Value.Processed, Is.True);
            Assert.That(v1.Value.StartTime, Is.GreaterThanOrEqualTo(0));
            Assert.That(v2.Value.StartTime, Is.GreaterThanOrEqualTo(0));
            Assert.That(v3.Value.StartTime, Is.GreaterThanOrEqualTo(0));
            Assert.That(v1.Value.EndTime, Is.GreaterThan(v1.Value.StartTime));
            Assert.That(v2.Value.EndTime, Is.GreaterThan(v2.Value.StartTime));
            Assert.That(v3.Value.EndTime, Is.GreaterThan(v3.Value.StartTime));
        }

        [Test, Category("valid")]
        public void ProcessAllComponentsOfDisconnectedGraph()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var v1 = graph.AddVertex(new DFSVertex());
            var v2 = graph.AddVertex(new DFSVertex());
            var v3 = graph.AddVertex(new DFSVertex());
            var v4 = graph.AddVertex(new DFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v3, v4);

            dfs.Run(graph);

            Assert.That(v1.Value.Processed && v2.Value.Processed && v3.Value.Processed && v4.Value.Processed, Is.True);
            Assert.That(v1.Value.StartTime, Is.GreaterThanOrEqualTo(0));
            Assert.That(v2.Value.StartTime, Is.GreaterThanOrEqualTo(0));
            Assert.That(v3.Value.StartTime, Is.GreaterThanOrEqualTo(0));
            Assert.That(v4.Value.StartTime, Is.GreaterThanOrEqualTo(0));
        }

        [Test, Category("valid")]
        public void ResetPreInitializedVerticesCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var v1 = graph.AddVertex(new DFSVertex { StartTime = 10, EndTime = 20 });
            var v2 = graph.AddVertex(new DFSVertex { StartTime = 30, EndTime = 40 });
            graph.AddEdge(v1, v2);

            dfs.Run(graph);

            Assert.That(v1.Value.Processed && v2.Value.Processed, Is.True);
            Assert.That(v1.Value.StartTime, Is.Not.EqualTo(10));
            Assert.That(v1.Value.EndTime, Is.Not.EqualTo(20));
            Assert.That(v2.Value.StartTime, Is.Not.EqualTo(30));
            Assert.That(v2.Value.EndTime, Is.Not.EqualTo(40));
            Assert.That(v1.Value.StartTime, Is.LessThan(v1.Value.EndTime));
            Assert.That(v2.Value.StartTime, Is.LessThan(v2.Value.EndTime));
        }
    }
}
