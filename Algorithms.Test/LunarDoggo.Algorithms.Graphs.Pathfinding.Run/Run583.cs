// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleCSharpEnv using AI Type  and AI Model 

ROOST_METHOD_HASH=Run_a2e9436d0a
ROOST_METHOD_SIG_HASH=Run_9ce955ed80

   ########## Test-Scenarios ##########  

Based on the provided method and related code, here are several test scenarios for the `Run` method of the `DepthFirstSearch` class:

Scenario 1: Null Graph Input

Details:
  TestName: ThrowArgumentNullExceptionWhenGraphIsNull
  Description: Verify that the method throws an ArgumentNullException when a null graph is passed as an argument.
Execution:
  Arrange: Create a DepthFirstSearch instance.
  Act: Call the Run method with a null graph.
  Assert: Expect an ArgumentNullException to be thrown.
Validation:
  This test ensures that the method properly handles null input, preventing potential null reference exceptions later in the execution.

Scenario 2: Empty Graph

Details:
  TestName: RunSuccessfullyOnEmptyGraph
  Description: Ensure the method can handle an empty graph without errors.
Execution:
  Arrange: Create a DepthFirstSearch instance and an empty IGraph<DFSVertex>.
  Act: Call the Run method with the empty graph.
  Assert: Verify that the method completes without throwing any exceptions.
Validation:
  This test confirms that the method can handle edge cases like empty graphs without crashing or entering infinite loops.

Scenario 3: Single Vertex Graph

Details:
  TestName: ProcessSingleVertexGraphCorrectly
  Description: Check if the method correctly processes a graph with only one vertex.
Execution:
  Arrange: Create a DepthFirstSearch instance and an IGraph<DFSVertex> with a single vertex.
  Act: Call the Run method with the single-vertex graph.
  Assert: Verify that the vertex's StartTime and EndTime are set and Processed is true.
Validation:
  This test ensures that the basic functionality works for the simplest possible graph structure.

Scenario 4: Cyclic Graph

Details:
  TestName: HandleCyclicGraphWithoutInfiniteLoop
  Description: Verify that the method can process a graph with cycles without getting stuck in an infinite loop.
Execution:
  Arrange: Create a DepthFirstSearch instance and an IGraph<DFSVertex> with a cycle (e.g., A -> B -> C -> A).
  Act: Call the Run method with the cyclic graph.
  Assert: Check that all vertices are processed and have valid StartTime and EndTime values.
Validation:
  This test confirms that the algorithm can handle cycles in the graph, which is a common edge case in graph traversal.

Scenario 5: Disconnected Graph

Details:
  TestName: ProcessAllComponentsInDisconnectedGraph
  Description: Ensure that all components of a disconnected graph are processed.
Execution:
  Arrange: Create a DepthFirstSearch instance and an IGraph<DFSVertex> with multiple disconnected components.
  Act: Call the Run method with the disconnected graph.
  Assert: Verify that all vertices in all components are processed and have valid StartTime and EndTime values.
Validation:
  This test checks if the method correctly handles graphs that are not fully connected, ensuring no vertices are left unprocessed.

Scenario 6: Large Graph Performance

Details:
  TestName: CompleteProcessingOfLargeGraphWithinReasonableTime
  Description: Test the performance of the method on a large graph to ensure it completes within a reasonable time frame.
Execution:
  Arrange: Create a DepthFirstSearch instance and a large IGraph<DFSVertex> (e.g., 10000 vertices).
  Act: Call the Run method with the large graph and measure the execution time.
  Assert: Verify that the method completes within a specified time limit and all vertices are processed.
Validation:
  This test ensures that the algorithm scales well and can handle large graphs efficiently.

Scenario 7: Correct Predecessor Assignment

Details:
  TestName: AssignCorrectPredecessorsInSimpleLinearGraph
  Description: Verify that the method correctly assigns predecessors in a simple linear graph.
Execution:
  Arrange: Create a DepthFirstSearch instance and an IGraph<DFSVertex> with a linear structure (e.g., A -> B -> C -> D).
  Act: Call the Run method with the linear graph.
  Assert: Check that each vertex (except the first) has the correct predecessor assigned.
Validation:
  This test ensures that the predecessor assignment, which is crucial for path reconstruction, works correctly in a simple case.

Scenario 8: Correct Start and End Times

Details:
  TestName: AssignCorrectStartAndEndTimesInSimpleGraph
  Description: Ensure that start and end times are assigned correctly and in the right order.
Execution:
  Arrange: Create a DepthFirstSearch instance and a simple IGraph<DFSVertex>.
  Act: Call the Run method with the graph.
  Assert: Verify that for each vertex, StartTime < EndTime, and that the times are consistent with the DFS order.
Validation:
  This test checks the core functionality of the DFS algorithm in assigning discovery and finish times to vertices.

These test scenarios cover various aspects of the `Run` method, including edge cases, error handling, and core functionality. They should provide a comprehensive test suite for the DepthFirstSearch class.


*/

// ********RoostGPT********
using NUnit.Framework;
using LunarDoggo.Datastructures.Graphs;
using LunarDoggo.Algorithms.Graphs.Pathfinding;
using System;
using System.Linq;

namespace LunarDoggo.Algorithms.Graphs.Pathfinding.Test
{
    [TestFixture]
    public class Run583Test
    {
        private DepthFirstSearch dfs;

        [SetUp]
        public void Setup()
        {
            dfs = new DepthFirstSearch();
        }

        [Test, Category("invalid")]
        public void ThrowArgumentNullExceptionWhenGraphIsNull()
        {
            Assert.Throws<ArgumentNullException>(() => dfs.Run(null));
        }

        [Test, Category("valid")]
        public void RunSuccessfullyOnEmptyGraph()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            Assert.DoesNotThrow(() => dfs.Run(graph));
        }

        [Test, Category("valid")]
        public void ProcessSingleVertexGraphCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var vertex = graph.AddVertex(new DFSVertex());

            dfs.Run(graph);

            Assert.That(vertex.Value.Processed, Is.True);
            Assert.That(vertex.Value.StartTime, Is.GreaterThanOrEqualTo(0));
            Assert.That(vertex.Value.EndTime, Is.GreaterThan(vertex.Value.StartTime));
        }

        [Test, Category("valid")]
        public void HandleCyclicGraphWithoutInfiniteLoop()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var vertexA = graph.AddVertex(new DFSVertex());
            var vertexB = graph.AddVertex(new DFSVertex());
            var vertexC = graph.AddVertex(new DFSVertex());

            graph.AddEdge(vertexA, vertexB);
            graph.AddEdge(vertexB, vertexC);
            graph.AddEdge(vertexC, vertexA);

            dfs.Run(graph);

            Assert.That(graph.Vertices.All(v => v.Value.Processed), Is.True);
            Assert.That(graph.Vertices.All(v => v.Value.StartTime >= 0), Is.True);
            Assert.That(graph.Vertices.All(v => v.Value.EndTime > v.Value.StartTime), Is.True);
        }

        [Test, Category("valid")]
        public void ProcessAllComponentsInDisconnectedGraph()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var vertexA = graph.AddVertex(new DFSVertex());
            var vertexB = graph.AddVertex(new DFSVertex());
            var vertexC = graph.AddVertex(new DFSVertex());
            var vertexD = graph.AddVertex(new DFSVertex());

            graph.AddEdge(vertexA, vertexB);
            graph.AddEdge(vertexC, vertexD);

            dfs.Run(graph);

            Assert.That(graph.Vertices.All(v => v.Value.Processed), Is.True);
            Assert.That(graph.Vertices.All(v => v.Value.StartTime >= 0), Is.True);
            Assert.That(graph.Vertices.All(v => v.Value.EndTime > v.Value.StartTime), Is.True);
        }

        [Test, Category("valid")]
        public void CompleteProcessingOfLargeGraphWithinReasonableTime()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            for (int i = 0; i < 10000; i++)
            {
                graph.AddVertex(new DFSVertex());
            }

            // TODO: Adjust the timeout value as needed
            Assert.That(() => dfs.Run(graph), Throws.Nothing.After(10000));
            Assert.That(graph.Vertices.All(v => v.Value.Processed), Is.True);
        }

        [Test, Category("valid")]
        public void AssignCorrectPredecessorsInSimpleLinearGraph()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var vertexA = graph.AddVertex(new DFSVertex());
            var vertexB = graph.AddVertex(new DFSVertex());
            var vertexC = graph.AddVertex(new DFSVertex());
            var vertexD = graph.AddVertex(new DFSVertex());

            graph.AddEdge(vertexA, vertexB);
            graph.AddEdge(vertexB, vertexC);
            graph.AddEdge(vertexC, vertexD);

            dfs.Run(graph);

            Assert.That(vertexB.Value.Predecessor, Is.EqualTo(vertexA));
            Assert.That(vertexC.Value.Predecessor, Is.EqualTo(vertexB));
            Assert.That(vertexD.Value.Predecessor, Is.EqualTo(vertexC));
        }

        [Test, Category("valid")]
        public void AssignCorrectStartAndEndTimesInSimpleGraph()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var vertexA = graph.AddVertex(new DFSVertex());
            var vertexB = graph.AddVertex(new DFSVertex());
            var vertexC = graph.AddVertex(new DFSVertex());

            graph.AddEdge(vertexA, vertexB);
            graph.AddEdge(vertexB, vertexC);

            dfs.Run(graph);

            Assert.That(vertexA.Value.StartTime, Is.LessThan(vertexA.Value.EndTime));
            Assert.That(vertexB.Value.StartTime, Is.LessThan(vertexB.Value.EndTime));
            Assert.That(vertexC.Value.StartTime, Is.LessThan(vertexC.Value.EndTime));

            Assert.That(vertexA.Value.StartTime, Is.LessThan(vertexB.Value.StartTime));
            Assert.That(vertexB.Value.StartTime, Is.LessThan(vertexC.Value.StartTime));
            Assert.That(vertexC.Value.EndTime, Is.LessThan(vertexB.Value.EndTime));
            Assert.That(vertexB.Value.EndTime, Is.LessThan(vertexA.Value.EndTime));
        }
    }
}
