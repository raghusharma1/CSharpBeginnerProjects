// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleCppEnv using AI Type  and AI Model 

ROOST_METHOD_HASH=Run_a2e9436d0a
ROOST_METHOD_SIG_HASH=Run_9ce955ed80

   ########## Test-Scenarios ##########  

Based on the provided method and related code, here are several test scenarios for the `Run` method of the `DepthFirstSearch` class:

Scenario 1: Null Graph Input

Details:
  TestName: ThrowArgumentNullExceptionWhenGraphIsNull
  Description: Verify that the method throws an ArgumentNullException when a null graph is provided.
Execution:
  Arrange: Create a DepthFirstSearch instance.
  Act: Call the Run method with a null graph.
  Assert: Expect an ArgumentNullException to be thrown.
Validation:
  This test ensures that the method properly handles null input, preventing null reference exceptions later in the execution.

Scenario 2: Empty Graph

Details:
  TestName: RunDFSOnEmptyGraph
  Description: Ensure the method can handle an empty graph without errors.
Execution:
  Arrange: Create a DepthFirstSearch instance and an empty IGraph<DFSVertex>.
  Act: Call the Run method with the empty graph.
  Assert: Verify that the method completes without throwing exceptions.
Validation:
  This test confirms that the method can handle edge cases like empty graphs gracefully.

Scenario 3: Single Vertex Graph

Details:
  TestName: RunDFSOnSingleVertexGraph
  Description: Check the behavior of DFS on a graph with only one vertex.
Execution:
  Arrange: Create a DepthFirstSearch instance and an IGraph<DFSVertex> with one vertex.
  Act: Call the Run method with the single-vertex graph.
  Assert: Verify that the vertex is processed (StartTime and EndTime are set).
Validation:
  This test ensures that the DFS algorithm correctly processes a trivial graph case.

Scenario 4: Disconnected Graph

Details:
  TestName: RunDFSOnDisconnectedGraph
  Description: Verify that DFS processes all vertices in a disconnected graph.
Execution:
  Arrange: Create a DepthFirstSearch instance and an IGraph<DFSVertex> with multiple disconnected components.
  Act: Call the Run method with the disconnected graph.
  Assert: Check that all vertices are processed (have non-negative StartTime and EndTime).
Validation:
  This test confirms that the DFS algorithm handles disconnected graphs correctly, visiting all vertices.

Scenario 5: Cyclic Graph

Details:
  TestName: RunDFSOnCyclicGraph
  Description: Ensure DFS correctly handles a graph containing cycles.
Execution:
  Arrange: Create a DepthFirstSearch instance and an IGraph<DFSVertex> with cycles.
  Act: Call the Run method with the cyclic graph.
  Assert: Verify that all vertices are processed and have correct start/end times.
Validation:
  This test checks that the DFS algorithm doesn't get stuck in cycles and processes all vertices correctly.

Scenario 6: Large Graph

Details:
  TestName: RunDFSOnLargeGraph
  Description: Test the performance and correctness of DFS on a large graph.
Execution:
  Arrange: Create a DepthFirstSearch instance and a large IGraph<DFSVertex> with many vertices and edges.
  Act: Call the Run method with the large graph.
  Assert: Verify that all vertices are processed within a reasonable time frame.
Validation:
  This test ensures that the DFS algorithm scales well and correctly processes large graphs.

Scenario 7: Graph With Pre-existing DFSVertex Values

Details:
  TestName: RunDFSOnGraphWithPreExistingVertexValues
  Description: Verify that DFS correctly reinitializes vertices with pre-existing DFSVertex values.
Execution:
  Arrange: Create a DepthFirstSearch instance and an IGraph<DFSVertex> where vertices already have DFSVertex values set.
  Act: Call the Run method with this graph.
  Assert: Check that all vertices are reinitialized and processed correctly.
Validation:
  This test ensures that the DFS algorithm properly reinitializes vertex data, even when pre-existing values are present.

Scenario 8: Verify Correct Predecessor Assignment

Details:
  TestName: VerifyCorrectPredecessorAssignmentInDFS
  Description: Ensure that DFS correctly assigns predecessors to vertices during traversal.
Execution:
  Arrange: Create a DepthFirstSearch instance and an IGraph<DFSVertex> with a known structure.
  Act: Call the Run method with this graph.
  Assert: Check that vertices have the expected predecessors set.
Validation:
  This test verifies that the DFS algorithm correctly builds the depth-first tree by assigning proper predecessors.

These test scenarios cover various aspects of the DepthFirstSearch.Run method, including edge cases, error handling, and typical use cases. They aim to ensure the correctness and robustness of the DFS implementation.


*/

// ********RoostGPT********
using NUnit.Framework;
using LunarDoggo.Datastructures.Graphs;
using LunarDoggo.Algorithms.Graphs.Pathfinding;
using System;

namespace LunarDoggo.Algorithms.Graphs.Pathfinding.Test
{
    [TestFixture]
    public class Run599Test
    {
        private DepthFirstSearch dfs;

        [SetUp]
        public void Setup()
        {
            dfs = new DepthFirstSearch();
        }

        [Test]
        public void ThrowArgumentNullExceptionWhenGraphIsNull()
        {
            Assert.Throws<ArgumentNullException>(() => dfs.Run(null));
        }

        [Test]
        public void RunDFSOnEmptyGraph()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            Assert.DoesNotThrow(() => dfs.Run(graph));
        }

        [Test]
        public void RunDFSOnSingleVertexGraph()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var vertex = graph.AddVertex(new DFSVertex());

            dfs.Run(graph);

            Assert.That(vertex.Value.StartTime, Is.GreaterThanOrEqualTo(0));
            Assert.That(vertex.Value.EndTime, Is.GreaterThan(vertex.Value.StartTime));
        }

        [Test]
        public void RunDFSOnDisconnectedGraph()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var v1 = graph.AddVertex(new DFSVertex());
            var v2 = graph.AddVertex(new DFSVertex());
            var v3 = graph.AddVertex(new DFSVertex());

            dfs.Run(graph);

            Assert.That(v1.Value.StartTime, Is.GreaterThanOrEqualTo(0));
            Assert.That(v2.Value.StartTime, Is.GreaterThanOrEqualTo(0));
            Assert.That(v3.Value.StartTime, Is.GreaterThanOrEqualTo(0));
            Assert.That(v1.Value.EndTime, Is.GreaterThan(v1.Value.StartTime));
            Assert.That(v2.Value.EndTime, Is.GreaterThan(v2.Value.StartTime));
            Assert.That(v3.Value.EndTime, Is.GreaterThan(v3.Value.StartTime));
        }

        [Test]
        public void RunDFSOnCyclicGraph()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var v1 = graph.AddVertex(new DFSVertex());
            var v2 = graph.AddVertex(new DFSVertex());
            var v3 = graph.AddVertex(new DFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);
            graph.AddEdge(v3, v1);

            dfs.Run(graph);

            Assert.That(v1.Value.StartTime, Is.GreaterThanOrEqualTo(0));
            Assert.That(v2.Value.StartTime, Is.GreaterThanOrEqualTo(0));
            Assert.That(v3.Value.StartTime, Is.GreaterThanOrEqualTo(0));
            Assert.That(v1.Value.EndTime, Is.GreaterThan(v1.Value.StartTime));
            Assert.That(v2.Value.EndTime, Is.GreaterThan(v2.Value.StartTime));
            Assert.That(v3.Value.EndTime, Is.GreaterThan(v3.Value.StartTime));
        }

        [Test]
        public void RunDFSOnLargeGraph()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var vertices = new Vertex<DFSVertex>[1000];
            for (int i = 0; i < 1000; i++)
            {
                vertices[i] = graph.AddVertex(new DFSVertex());
            }
            for (int i = 0; i < 999; i++)
            {
                graph.AddEdge(vertices[i], vertices[i + 1]);
            }

            dfs.Run(graph);

            foreach (var vertex in graph.Vertices)
            {
                Assert.That(vertex.Value.StartTime, Is.GreaterThanOrEqualTo(0));
                Assert.That(vertex.Value.EndTime, Is.GreaterThan(vertex.Value.StartTime));
            }
        }

        [Test]
        public void RunDFSOnGraphWithPreExistingVertexValues()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var v1 = graph.AddVertex(new DFSVertex { StartTime = 5, EndTime = 10 });
            var v2 = graph.AddVertex(new DFSVertex { StartTime = 15, EndTime = 20 });
            graph.AddEdge(v1, v2);

            dfs.Run(graph);

            Assert.That(v1.Value.StartTime, Is.GreaterThanOrEqualTo(0));
            Assert.That(v2.Value.StartTime, Is.GreaterThanOrEqualTo(0));
            Assert.That(v1.Value.EndTime, Is.GreaterThan(v1.Value.StartTime));
            Assert.That(v2.Value.EndTime, Is.GreaterThan(v2.Value.StartTime));
            Assert.That(v1.Value.StartTime, Is.Not.EqualTo(5));
            Assert.That(v2.Value.StartTime, Is.Not.EqualTo(15));
        }

        [Test]
        public void VerifyCorrectPredecessorAssignmentInDFS()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var v1 = graph.AddVertex(new DFSVertex());
            var v2 = graph.AddVertex(new DFSVertex());
            var v3 = graph.AddVertex(new DFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);

            dfs.Run(graph);

            Assert.That(v1.Value.Predecessor, Is.Null);
            Assert.That(v2.Value.Predecessor, Is.EqualTo(v1));
            Assert.That(v3.Value.Predecessor, Is.EqualTo(v2));
        }
    }
}
