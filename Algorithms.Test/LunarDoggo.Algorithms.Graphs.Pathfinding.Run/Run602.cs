// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleCSharpEnv using AI Type  and AI Model 

ROOST_METHOD_HASH=Run_a2e9436d0a
ROOST_METHOD_SIG_HASH=Run_9ce955ed80

   ########## Test-Scenarios ##########  

Based on the provided method and related code, here are several NUnit test scenarios for the `Run` method of the `DepthFirstSearch` class:

Scenario 1: Null Graph Handling

Details:
  TestName: ThrowsArgumentNullExceptionWhenGraphIsNull
  Description: Verify that the method throws an ArgumentNullException when a null graph is passed.
Execution:
  Arrange: Create a DepthFirstSearch instance.
  Act: Call the Run method with a null graph.
  Assert: Verify that an ArgumentNullException is thrown.
Validation:
  This test ensures that the method properly handles null input, preventing null reference exceptions later in the execution.

Scenario 2: Empty Graph Processing

Details:
  TestName: ProcessesEmptyGraphWithoutErrors
  Description: Ensure that the method can handle an empty graph without throwing exceptions.
Execution:
  Arrange: Create a DepthFirstSearch instance and an empty UndirectedUnweightedGraph<DFSVertex>.
  Act: Call the Run method with the empty graph.
  Assert: Verify that no exception is thrown and the method completes successfully.
Validation:
  This test confirms that the method can handle edge cases like empty graphs without errors.

Scenario 3: Single Vertex Graph Processing

Details:
  TestName: ProcessesSingleVertexGraphCorrectly
  Description: Verify that a graph with a single vertex is processed correctly.
Execution:
  Arrange: Create a DepthFirstSearch instance and a UndirectedUnweightedGraph<DFSVertex> with one vertex.
  Act: Call the Run method with the graph.
  Assert: Check that the vertex's StartTime and EndTime are set and Processed is true.
Validation:
  This test ensures that the basic functionality works for the simplest possible graph.

Scenario 4: Multiple Disconnected Vertices Processing

Details:
  TestName: ProcessesMultipleDisconnectedVerticesCorrectly
  Description: Ensure that a graph with multiple disconnected vertices is processed correctly.
Execution:
  Arrange: Create a DepthFirstSearch instance and a UndirectedUnweightedGraph<DFSVertex> with multiple disconnected vertices.
  Act: Call the Run method with the graph.
  Assert: Verify that all vertices have been processed (Processed is true, StartTime and EndTime are set).
Validation:
  This test checks if the method correctly handles graphs with multiple components.

Scenario 5: Connected Graph Processing

Details:
  TestName: ProcessesConnectedGraphCorrectly
  Description: Verify that a connected graph is processed in the correct order.
Execution:
  Arrange: Create a DepthFirstSearch instance and a UndirectedUnweightedGraph<DFSVertex> with multiple connected vertices.
  Act: Call the Run method with the graph.
  Assert: Check that all vertices are processed and that the StartTime and EndTime values reflect a valid DFS order.
Validation:
  This test ensures that the DFS algorithm is correctly implemented for a typical connected graph.

Scenario 6: Cyclic Graph Processing

Details:
  TestName: ProcessesCyclicGraphWithoutInfiniteLoop
  Description: Ensure that a graph containing cycles is processed without getting stuck in an infinite loop.
Execution:
  Arrange: Create a DepthFirstSearch instance and a UndirectedUnweightedGraph<DFSVertex> with cycles.
  Act: Call the Run method with the graph.
  Assert: Verify that all vertices are processed and the method completes in a reasonable time.
Validation:
  This test checks if the method can handle graphs with cycles, which is crucial for the correctness of the DFS algorithm.

Scenario 7: Large Graph Processing

Details:
  TestName: ProcessesLargeGraphEfficiently
  Description: Verify that the method can handle a large graph efficiently.
Execution:
  Arrange: Create a DepthFirstSearch instance and a large UndirectedUnweightedGraph<DFSVertex>.
  Act: Call the Run method with the graph and measure the execution time.
  Assert: Check that all vertices are processed and the execution time is within acceptable limits.
Validation:
  This test ensures that the method scales well for larger graphs, which is important for performance in real-world scenarios.

Scenario 8: Predecessor Correctness

Details:
  TestName: SetsPredecessorsCorrectlyInConnectedGraph
  Description: Ensure that the Predecessor property is set correctly for each vertex in a connected graph.
Execution:
  Arrange: Create a DepthFirstSearch instance and a UndirectedUnweightedGraph<DFSVertex> with a known structure.
  Act: Call the Run method with the graph.
  Assert: Verify that each vertex (except the start vertex) has a Predecessor set, and that the Predecessors form a valid DFS tree.
Validation:
  This test checks if the DFS algorithm correctly builds the DFS tree, which is crucial for many applications of DFS.

These test scenarios cover various aspects of the DepthFirstSearch.Run method, including edge cases, error handling, and correctness of the algorithm implementation.


*/

// ********RoostGPT********
using NUnit.Framework;
using LunarDoggo.Datastructures.Graphs;
using LunarDoggo.Algorithms.Graphs.Pathfinding;
using System;

namespace LunarDoggo.Algorithms.Graphs.Pathfinding.Test
{
    [TestFixture]
    public class Run602Test
    {
        private DepthFirstSearch dfs;

        [SetUp]
        public void Setup()
        {
            dfs = new DepthFirstSearch();
        }

        [Test, Category("invalid")]
        public void ThrowsArgumentNullExceptionWhenGraphIsNull()
        {
            Assert.Throws<ArgumentNullException>(() => dfs.Run(null));
        }

        [Test, Category("valid")]
        public void ProcessesEmptyGraphWithoutErrors()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            Assert.DoesNotThrow(() => dfs.Run(graph));
        }

        [Test, Category("valid")]
        public void ProcessesSingleVertexGraphCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var vertex = graph.AddVertex(new DFSVertex());

            dfs.Run(graph);

            Assert.That(vertex.Value.Processed, Is.True);
            Assert.That(vertex.Value.StartTime, Is.GreaterThanOrEqualTo(0));
            Assert.That(vertex.Value.EndTime, Is.GreaterThan(vertex.Value.StartTime));
        }

        [Test, Category("valid")]
        public void ProcessesMultipleDisconnectedVerticesCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var vertex1 = graph.AddVertex(new DFSVertex());
            var vertex2 = graph.AddVertex(new DFSVertex());
            var vertex3 = graph.AddVertex(new DFSVertex());

            dfs.Run(graph);

            Assert.That(vertex1.Value.Processed && vertex2.Value.Processed && vertex3.Value.Processed, Is.True);
            Assert.That(vertex1.Value.StartTime, Is.GreaterThanOrEqualTo(0));
            Assert.That(vertex2.Value.StartTime, Is.GreaterThanOrEqualTo(0));
            Assert.That(vertex3.Value.StartTime, Is.GreaterThanOrEqualTo(0));
            Assert.That(vertex1.Value.EndTime, Is.GreaterThan(vertex1.Value.StartTime));
            Assert.That(vertex2.Value.EndTime, Is.GreaterThan(vertex2.Value.StartTime));
            Assert.That(vertex3.Value.EndTime, Is.GreaterThan(vertex3.Value.StartTime));
        }

        [Test, Category("valid")]
        public void ProcessesConnectedGraphCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var vertex1 = graph.AddVertex(new DFSVertex());
            var vertex2 = graph.AddVertex(new DFSVertex());
            var vertex3 = graph.AddVertex(new DFSVertex());
            graph.AddEdge(vertex1, vertex2);
            graph.AddEdge(vertex2, vertex3);

            dfs.Run(graph);

            Assert.That(vertex1.Value.Processed && vertex2.Value.Processed && vertex3.Value.Processed, Is.True);
            Assert.That(vertex1.Value.StartTime, Is.LessThan(vertex2.Value.StartTime));
            Assert.That(vertex2.Value.StartTime, Is.LessThan(vertex3.Value.StartTime));
            Assert.That(vertex3.Value.EndTime, Is.LessThan(vertex2.Value.EndTime));
            Assert.That(vertex2.Value.EndTime, Is.LessThan(vertex1.Value.EndTime));
        }

        [Test, Category("valid")]
        public void ProcessesCyclicGraphWithoutInfiniteLoop()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var vertex1 = graph.AddVertex(new DFSVertex());
            var vertex2 = graph.AddVertex(new DFSVertex());
            var vertex3 = graph.AddVertex(new DFSVertex());
            graph.AddEdge(vertex1, vertex2);
            graph.AddEdge(vertex2, vertex3);
            graph.AddEdge(vertex3, vertex1);

            Assert.DoesNotThrow(() => dfs.Run(graph));
            Assert.That(vertex1.Value.Processed && vertex2.Value.Processed && vertex3.Value.Processed, Is.True);
        }

        [Test, Category("valid")]
        public void ProcessesLargeGraphEfficiently()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            for (int i = 0; i < 10000; i++)
            {
                graph.AddVertex(new DFSVertex());
            }

            var startTime = DateTime.Now;
            dfs.Run(graph);
            var endTime = DateTime.Now;

            Assert.That((endTime - startTime).TotalSeconds, Is.LessThan(5));
            Assert.That(graph.Vertices.All(v => v.Value.Processed), Is.True);
        }

        [Test, Category("valid")]
        public void SetsPredecessorsCorrectlyInConnectedGraph()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var vertex1 = graph.AddVertex(new DFSVertex());
            var vertex2 = graph.AddVertex(new DFSVertex());
            var vertex3 = graph.AddVertex(new DFSVertex());
            graph.AddEdge(vertex1, vertex2);
            graph.AddEdge(vertex2, vertex3);

            dfs.Run(graph);

            Assert.That(vertex1.Value.Predecessor, Is.Null);
            Assert.That(vertex2.Value.Predecessor, Is.EqualTo(vertex1));
            Assert.That(vertex3.Value.Predecessor, Is.EqualTo(vertex2));
        }
    }
}
