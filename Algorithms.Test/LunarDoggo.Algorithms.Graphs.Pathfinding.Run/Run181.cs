// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleCSharpEnv using AI Type  and AI Model 

ROOST_METHOD_HASH=Run_a2e9436d0a
ROOST_METHOD_SIG_HASH=Run_9ce955ed80

   ########## Test-Scenarios ##########  

Based on the provided method and related code, here are several test scenarios for the `Run` method of the `DepthFirstSearch` class:

Scenario 1: Null Graph Input

Details:
  TestName: TestRunWithNullGraphThrowsArgumentNullException
  Description: Verify that the Run method throws an ArgumentNullException when passed a null graph.

Execution:
  Arrange: Create a DepthFirstSearch instance.
  Act: Call the Run method with a null graph.
  Assert: Verify that an ArgumentNullException is thrown.

Validation:
  This test ensures that the method properly handles null input, preventing potential null reference exceptions later in the execution.

Scenario 2: Empty Graph

Details:
  TestName: TestRunWithEmptyGraphCompletesWithoutError
  Description: Ensure that the Run method completes successfully when given an empty graph.

Execution:
  Arrange: Create a DepthFirstSearch instance and an empty UndirectedUnweightedGraph<DFSVertex>.
  Act: Call the Run method with the empty graph.
  Assert: Verify that the method completes without throwing any exceptions.

Validation:
  This test confirms that the method can handle edge cases like empty graphs without errors.

Scenario 3: Single Vertex Graph

Details:
  TestName: TestRunWithSingleVertexGraphProcessesCorrectly
  Description: Check if the Run method correctly processes a graph with a single vertex.

Execution:
  Arrange: Create a DepthFirstSearch instance and a UndirectedUnweightedGraph<DFSVertex> with one vertex.
  Act: Call the Run method with the single-vertex graph.
  Assert: Verify that the vertex's DFSVertex value is properly initialized and processed (StartTime and EndTime are set, Processed is true).

Validation:
  This test ensures that the method correctly handles the simplest possible non-empty graph.

Scenario 4: Connected Graph

Details:
  TestName: TestRunWithConnectedGraphProcessesAllVertices
  Description: Verify that all vertices in a connected graph are processed.

Execution:
  Arrange: Create a DepthFirstSearch instance and a UndirectedUnweightedGraph<DFSVertex> with multiple connected vertices.
  Act: Call the Run method with the connected graph.
  Assert: Check that all vertices have been processed (Processed is true for all vertices).

Validation:
  This test confirms that the DFS algorithm visits all vertices in a connected graph.

Scenario 5: Disconnected Graph

Details:
  TestName: TestRunWithDisconnectedGraphProcessesAllComponents
  Description: Ensure that all components of a disconnected graph are processed.

Execution:
  Arrange: Create a DepthFirstSearch instance and a UndirectedUnweightedGraph<DFSVertex> with multiple disconnected components.
  Act: Call the Run method with the disconnected graph.
  Assert: Verify that all vertices in all components have been processed.

Validation:
  This test checks that the method correctly handles disconnected graphs by processing all components.

Scenario 6: Cyclic Graph

Details:
  TestName: TestRunWithCyclicGraphCompletesWithoutInfiniteLoop
  Description: Check that the Run method completes successfully on a graph containing cycles.

Execution:
  Arrange: Create a DepthFirstSearch instance and a UndirectedUnweightedGraph<DFSVertex> with cycles.
  Act: Call the Run method with the cyclic graph.
  Assert: Verify that all vertices are processed and the method completes in a reasonable time.

Validation:
  This test ensures that the DFS algorithm correctly handles cycles without getting stuck in an infinite loop.

Scenario 7: Large Graph

Details:
  TestName: TestRunWithLargeGraphCompletesInReasonableTime
  Description: Verify that the Run method can handle a large graph efficiently.

Execution:
  Arrange: Create a DepthFirstSearch instance and a large UndirectedUnweightedGraph<DFSVertex> (e.g., 10000 vertices).
  Act: Call the Run method with the large graph, measuring execution time.
  Assert: Check that all vertices are processed and the execution time is within acceptable limits.

Validation:
  This test confirms that the method scales well with large inputs and doesn't have unexpected performance issues.

Scenario 8: Correct Start and End Times

Details:
  TestName: TestRunAssignsCorrectStartAndEndTimes
  Description: Ensure that the Run method assigns correct and consistent start and end times to vertices.

Execution:
  Arrange: Create a DepthFirstSearch instance and a UndirectedUnweightedGraph<DFSVertex> with a known structure.
  Act: Call the Run method with the graph.
  Assert: Verify that for each vertex, StartTime < EndTime, and that the times are consistent with the DFS order.

Validation:
  This test checks the correctness of the core DFS algorithm implementation, ensuring that start and end times reflect the actual traversal order.

These scenarios cover various aspects of the Run method, including edge cases, different graph structures, and key functionalities of the Depth-First Search algorithm.


*/

// ********RoostGPT********
using NUnit.Framework;
using LunarDoggo.Datastructures.Graphs;
using LunarDoggo.Algorithms.Graphs.Pathfinding;
using System;

namespace LunarDoggo.Algorithms.Graphs.Pathfinding.Test
{
    [TestFixture]
    public class Run181Test
    {
        private DepthFirstSearch dfs;

        [SetUp]
        public void Setup()
        {
            dfs = new DepthFirstSearch();
        }

        [Test, Category("invalid")]
        public void TestRunWithNullGraphThrowsArgumentNullException()
        {
            Assert.Throws<ArgumentNullException>(() => dfs.Run(null));
        }

        [Test, Category("valid")]
        public void TestRunWithEmptyGraphCompletesWithoutError()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            Assert.DoesNotThrow(() => dfs.Run(graph));
        }

        [Test, Category("valid")]
        public void TestRunWithSingleVertexGraphProcessesCorrectly()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var vertex = graph.AddVertex(new DFSVertex());

            dfs.Run(graph);

            Assert.That(vertex.Value.Processed, Is.True);
            Assert.That(vertex.Value.StartTime, Is.GreaterThanOrEqualTo(0));
            Assert.That(vertex.Value.EndTime, Is.GreaterThan(vertex.Value.StartTime));
        }

        [Test, Category("valid")]
        public void TestRunWithConnectedGraphProcessesAllVertices()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var v1 = graph.AddVertex(new DFSVertex());
            var v2 = graph.AddVertex(new DFSVertex());
            var v3 = graph.AddVertex(new DFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);

            dfs.Run(graph);

            Assert.That(graph.Vertices.All(v => v.Value.Processed), Is.True);
        }

        [Test, Category("valid")]
        public void TestRunWithDisconnectedGraphProcessesAllComponents()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var v1 = graph.AddVertex(new DFSVertex());
            var v2 = graph.AddVertex(new DFSVertex());
            var v3 = graph.AddVertex(new DFSVertex());
            var v4 = graph.AddVertex(new DFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v3, v4);

            dfs.Run(graph);

            Assert.That(graph.Vertices.All(v => v.Value.Processed), Is.True);
        }

        [Test, Category("valid")]
        public void TestRunWithCyclicGraphCompletesWithoutInfiniteLoop()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var v1 = graph.AddVertex(new DFSVertex());
            var v2 = graph.AddVertex(new DFSVertex());
            var v3 = graph.AddVertex(new DFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);
            graph.AddEdge(v3, v1);

            Assert.DoesNotThrow(() => dfs.Run(graph));
            Assert.That(graph.Vertices.All(v => v.Value.Processed), Is.True);
        }

        [Test, Category("valid")]
        public void TestRunWithLargeGraphCompletesInReasonableTime()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            for (int i = 0; i < 10000; i++)
            {
                graph.AddVertex(new DFSVertex());
            }

            var startTime = DateTime.Now;
            dfs.Run(graph);
            var endTime = DateTime.Now;

            Assert.That(graph.Vertices.All(v => v.Value.Processed), Is.True);
            Assert.That((endTime - startTime).TotalSeconds, Is.LessThan(5)); // Adjust the time limit as needed
        }

        [Test, Category("valid")]
        public void TestRunAssignsCorrectStartAndEndTimes()
        {
            var graph = new UndirectedUnweightedGraph<DFSVertex>();
            var v1 = graph.AddVertex(new DFSVertex());
            var v2 = graph.AddVertex(new DFSVertex());
            var v3 = graph.AddVertex(new DFSVertex());
            graph.AddEdge(v1, v2);
            graph.AddEdge(v2, v3);

            dfs.Run(graph);

            foreach (var vertex in graph.Vertices)
            {
                Assert.That(vertex.Value.StartTime, Is.LessThan(vertex.Value.EndTime));
            }

            // Verify DFS order
            Assert.That(v1.Value.StartTime, Is.LessThan(v2.Value.StartTime));
            Assert.That(v2.Value.StartTime, Is.LessThan(v3.Value.StartTime));
            Assert.That(v3.Value.EndTime, Is.LessThan(v2.Value.EndTime));
            Assert.That(v2.Value.EndTime, Is.LessThan(v1.Value.EndTime));
        }
    }
}
