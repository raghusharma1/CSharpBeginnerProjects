// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleCSharpEnv using AI Type  and AI Model 

ROOST_METHOD_HASH=Sort_e91a00f5b4
ROOST_METHOD_SIG_HASH=Sort_77d77f7e8e

   ########## Test-Scenarios ##########  

Based on the provided method and context, here are several test scenarios for the InsertionSort<T> class:

Scenario 1: Sort an Already Sorted Array

Details:
  TestName: SortAlreadySortedArray
  Description: Verify that the Sort method handles an already sorted array correctly without making unnecessary swaps.
Execution:
  Arrange: Create an array of integers that is already in ascending order.
  Act: Call the Sort method on the array.
  Assert: Verify that the array remains in the same order after sorting.
Validation:
  This test ensures that the algorithm is efficient when dealing with pre-sorted data, which is a common edge case.

Scenario 2: Sort a Reverse Sorted Array

Details:
  TestName: SortReverseSortedArray
  Description: Test the Sort method's ability to correctly order an array that is initially in descending order.
Execution:
  Arrange: Create an array of integers in descending order.
  Act: Invoke the Sort method on the array.
  Assert: Check that the resulting array is in ascending order.
Validation:
  This scenario tests the algorithm's performance on the worst-case input, where every element needs to be moved.

Scenario 3: Sort an Array with Duplicate Elements

Details:
  TestName: SortArrayWithDuplicates
  Description: Ensure that the Sort method correctly handles arrays containing duplicate values.
Execution:
  Arrange: Create an array of integers with several duplicate values.
  Act: Call the Sort method on the array.
  Assert: Verify that the array is sorted correctly with duplicates in the correct positions.
Validation:
  This test confirms that the algorithm maintains stability and correctly positions duplicate elements.

Scenario 4: Sort an Empty Array

Details:
  TestName: SortEmptyArray
  Description: Verify that the Sort method handles an empty array without throwing exceptions.
Execution:
  Arrange: Create an empty array of integers.
  Act: Invoke the Sort method on the empty array.
  Assert: Check that the method completes without errors and the array remains empty.
Validation:
  This edge case ensures that the algorithm gracefully handles empty inputs without crashing.

Scenario 5: Sort an Array with a Single Element

Details:
  TestName: SortSingleElementArray
  Description: Test the Sort method's behavior when given an array containing only one element.
Execution:
  Arrange: Create an array with a single integer element.
  Act: Call the Sort method on the single-element array.
  Assert: Verify that the array remains unchanged after sorting.
Validation:
  This scenario checks that the algorithm correctly handles the minimal case of a single-element array.

Scenario 6: Sort an Array of Custom Objects

Details:
  TestName: SortArrayOfCustomObjects
  Description: Ensure that the Sort method can correctly order an array of custom objects that implement IComparable<T>.
Execution:
  Arrange: Create an array of custom objects (e.g., Person objects with age as the comparison criteria).
  Act: Invoke the Sort method on the array of custom objects.
  Assert: Check that the resulting array is sorted based on the custom object's comparison logic.
Validation:
  This test verifies that the algorithm works correctly with custom types, demonstrating its generic capabilities.

Scenario 7: Sort a Large Array

Details:
  TestName: SortLargeArray
  Description: Test the Sort method's performance and correctness when dealing with a large number of elements.
Execution:
  Arrange: Create a large array (e.g., 10,000 elements) with random integers.
  Act: Call the Sort method on the large array.
  Assert: Verify that the resulting array is correctly sorted in ascending order.
Validation:
  This scenario tests the algorithm's efficiency and correctness when handling a significant amount of data.

Scenario 8: Sort an Array of Negative Numbers

Details:
  TestName: SortArrayOfNegativeNumbers
  Description: Ensure that the Sort method correctly orders an array containing only negative numbers.
Execution:
  Arrange: Create an array of negative integers in random order.
  Act: Invoke the Sort method on the array.
  Assert: Check that the resulting array is sorted in ascending order (from the smallest negative to the largest negative).
Validation:
  This test confirms that the algorithm correctly handles negative values, which can sometimes reveal edge cases in comparison logic.


*/

// ********RoostGPT********
using NUnit.Framework;
using System;
using LunarDoggo.Algorithms.Sorting;

namespace LunarDoggo.Algorithms.Sorting.Test
{
    [TestFixture]
    public class SortTest
    {
        private InsertionSort<int> _intSorter;
        private InsertionSort<string> _stringSorter;

        [SetUp]
        public void Setup()
        {
            _intSorter = new InsertionSort<int>();
            _stringSorter = new InsertionSort<string>();
        }

        [Test, Category("valid")]
        public void SortAlreadySortedArray()
        {
            int[] array = { 1, 2, 3, 4, 5 };
            int[] expected = { 1, 2, 3, 4, 5 };

            _intSorter.Sort(array);

            Assert.AreEqual(expected, array);
        }

        [Test, Category("valid")]
        public void SortReverseSortedArray()
        {
            int[] array = { 5, 4, 3, 2, 1 };
            int[] expected = { 1, 2, 3, 4, 5 };

            _intSorter.Sort(array);

            Assert.AreEqual(expected, array);
        }

        [Test, Category("valid")]
        public void SortArrayWithDuplicates()
        {
            int[] array = { 3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5 };
            int[] expected = { 1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9 };

            _intSorter.Sort(array);

            Assert.AreEqual(expected, array);
        }

        [Test, Category("boundary")]
        public void SortEmptyArray()
        {
            int[] array = { };

            _intSorter.Sort(array);

            Assert.IsEmpty(array);
        }

        [Test, Category("boundary")]
        public void SortSingleElementArray()
        {
            int[] array = { 42 };
            int[] expected = { 42 };

            _intSorter.Sort(array);

            Assert.AreEqual(expected, array);
        }

        [Test, Category("valid")]
        public void SortArrayOfCustomObjects()
        {
            Person[] array = {
                new Person("Alice", 30),
                new Person("Bob", 25),
                new Person("Charlie", 35)
            };
            Person[] expected = {
                new Person("Bob", 25),
                new Person("Alice", 30),
                new Person("Charlie", 35)
            };

            InsertionSort<Person> personSorter = new InsertionSort<Person>();
            personSorter.Sort(array);

            Assert.AreEqual(expected, array);
        }

        [Test, Category("valid")]
        public void SortLargeArray()
        {
            Random random = new Random(42); // Seed for reproducibility
            int[] array = new int[10000];
            for (int i = 0; i < array.Length; i++)
            {
                array[i] = random.Next();
            }

            _intSorter.Sort(array);

            Assert.IsTrue(IsSorted(array));
        }

        [Test, Category("valid")]
        public void SortArrayOfNegativeNumbers()
        {
            int[] array = { -5, -2, -8, -1, -9 };
            int[] expected = { -9, -8, -5, -2, -1 };

            _intSorter.Sort(array);

            Assert.AreEqual(expected, array);
        }

        private bool IsSorted<T>(T[] array) where T : IComparable<T>
        {
            for (int i = 1; i < array.Length; i++)
            {
                if (array[i - 1].CompareTo(array[i]) > 0)
                {
                    return false;
                }
            }
            return true;
        }
    }

    public class Person : IComparable<Person>
    {
        public string Name { get; }
        public int Age { get; }

        public Person(string name, int age)
        {
            Name = name;
            Age = age;
        }

        public int CompareTo(Person other)
        {
            return Age.CompareTo(other.Age);
        }

        public override bool Equals(object obj)
        {
            return obj is Person person &&
                   Name == person.Name &&
                   Age == person.Age;
        }

        public override int GetHashCode()
        {
            return HashCode.Combine(Name, Age);
        }
    }
}
