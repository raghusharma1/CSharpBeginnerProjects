// ********RoostGPT********
/*
Test generated by RoostGPT for test sampleCSharpEnv using AI Type  and AI Model 

ROOST_METHOD_HASH=Sort_e91a00f5b4
ROOST_METHOD_SIG_HASH=Sort_77d77f7e8e

   ########## Test-Scenarios ##########  

Based on the provided method and context, here are several test scenarios for the InsertionSort<T> class:

Scenario 1: Sort an already sorted array

Details:
  TestName: SortAlreadySortedArray
  Description: Verify that the Sort method correctly handles an array that is already in sorted order.
Execution:
  Arrange: Create an array of integers that is already sorted in ascending order.
  Act: Call the Sort method on the array.
  Assert: Verify that the array remains in the same order after sorting.
Validation:
  This test ensures that the algorithm doesn't unnecessarily modify an already sorted array, which is an important efficiency consideration.

Scenario 2: Sort a reverse-sorted array

Details:
  TestName: SortReverseSortedArray
  Description: Check if the Sort method can correctly sort an array that is in descending order.
Execution:
  Arrange: Create an array of integers sorted in descending order.
  Act: Call the Sort method on the array.
  Assert: Verify that the resulting array is sorted in ascending order.
Validation:
  This test checks the algorithm's ability to handle a worst-case scenario for insertion sort, where each element needs to be moved to the beginning of the array.

Scenario 3: Sort an array with duplicate elements

Details:
  TestName: SortArrayWithDuplicates
  Description: Ensure that the Sort method correctly handles arrays containing duplicate elements.
Execution:
  Arrange: Create an array of integers with some duplicate values.
  Act: Call the Sort method on the array.
  Assert: Verify that the resulting array is sorted in ascending order with duplicates properly placed.
Validation:
  This test confirms that the algorithm can handle non-unique elements, which is crucial for real-world data sets.

Scenario 4: Sort an array with a single element

Details:
  TestName: SortSingleElementArray
  Description: Verify that the Sort method correctly handles an array containing only one element.
Execution:
  Arrange: Create an array with a single integer element.
  Act: Call the Sort method on the array.
  Assert: Verify that the array remains unchanged.
Validation:
  This test checks the algorithm's behavior with the minimum possible input size, ensuring it doesn't throw exceptions or produce unexpected results.

Scenario 5: Sort an empty array

Details:
  TestName: SortEmptyArray
  Description: Ensure that the Sort method can handle an empty array without throwing exceptions.
Execution:
  Arrange: Create an empty array of integers.
  Act: Call the Sort method on the empty array.
  Assert: Verify that no exception is thrown and the array remains empty.
Validation:
  This test checks the algorithm's ability to handle edge cases, specifically an input with no elements.

Scenario 6: Sort an array of strings

Details:
  TestName: SortStringArray
  Description: Verify that the Sort method can correctly sort an array of strings based on lexicographic order.
Execution:
  Arrange: Create an unsorted array of strings.
  Act: Call the Sort method on the string array.
  Assert: Verify that the resulting array is sorted in lexicographic (dictionary) order.
Validation:
  This test ensures that the generic implementation works correctly with non-numeric types that implement IComparable<T>.

Scenario 7: Sort a large array

Details:
  TestName: SortLargeArray
  Description: Test the performance and correctness of the Sort method on a large array of integers.
Execution:
  Arrange: Create a large array (e.g., 10,000 elements) of randomly generated integers.
  Act: Call the Sort method on the large array.
  Assert: Verify that the resulting array is correctly sorted in ascending order.
Validation:
  This test checks the algorithm's ability to handle larger datasets, which is important for understanding its performance characteristics.

Scenario 8: Sort an array of custom objects

Details:
  TestName: SortCustomObjectArray
  Description: Verify that the Sort method can correctly sort an array of custom objects that implement IComparable<T>.
Execution:
  Arrange: Create a custom class implementing IComparable<T> and an unsorted array of these objects.
  Act: Call the Sort method on the array of custom objects.
  Assert: Verify that the resulting array is sorted according to the custom comparison logic.
Validation:
  This test ensures that the generic implementation works correctly with user-defined types, demonstrating its flexibility.

These scenarios cover various aspects of the InsertionSort<T> implementation, including edge cases, different data types, and potential performance considerations.


*/

// ********RoostGPT********
using NUnit.Framework;
using System;
using LunarDoggo.Algorithms.Sorting;

namespace LunarDoggo.Algorithms.Sorting.Test
{
    [TestFixture]
    public class SortTest
    {
        private InsertionSort<int> intSorter;
        private InsertionSort<string> stringSorter;

        [SetUp]
        public void Setup()
        {
            intSorter = new InsertionSort<int>();
            stringSorter = new InsertionSort<string>();
        }

        [Test, Category("valid")]
        public void SortAlreadySortedArray()
        {
            int[] array = { 1, 2, 3, 4, 5 };
            int[] expected = { 1, 2, 3, 4, 5 };

            intSorter.Sort(array);

            Assert.AreEqual(expected, array);
        }

        [Test, Category("valid")]
        public void SortReverseSortedArray()
        {
            int[] array = { 5, 4, 3, 2, 1 };
            int[] expected = { 1, 2, 3, 4, 5 };

            intSorter.Sort(array);

            Assert.AreEqual(expected, array);
        }

        [Test, Category("valid")]
        public void SortArrayWithDuplicates()
        {
            int[] array = { 3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5 };
            int[] expected = { 1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9 };

            intSorter.Sort(array);

            Assert.AreEqual(expected, array);
        }

        [Test, Category("boundary")]
        public void SortSingleElementArray()
        {
            int[] array = { 42 };
            int[] expected = { 42 };

            intSorter.Sort(array);

            Assert.AreEqual(expected, array);
        }

        [Test, Category("boundary")]
        public void SortEmptyArray()
        {
            int[] array = { };

            intSorter.Sort(array);

            Assert.IsEmpty(array);
        }

        [Test, Category("valid")]
        public void SortStringArray()
        {
            string[] array = { "banana", "apple", "cherry", "date" };
            string[] expected = { "apple", "banana", "cherry", "date" };

            stringSorter.Sort(array);

            Assert.AreEqual(expected, array);
        }

        [Test, Category("valid")]
        public void SortLargeArray()
        {
            Random random = new Random(42); // Seed for reproducibility
            int[] array = new int[10000];
            for (int i = 0; i < array.Length; i++)
            {
                array[i] = random.Next();
            }

            int[] expected = (int[])array.Clone();
            Array.Sort(expected);

            intSorter.Sort(array);

            Assert.AreEqual(expected, array);
        }

        [Test, Category("valid")]
        public void SortCustomObjectArray()
        {
            CustomObject[] array = new CustomObject[]
            {
                new CustomObject(3),
                new CustomObject(1),
                new CustomObject(4),
                new CustomObject(1),
                new CustomObject(5)
            };

            CustomObject[] expected = new CustomObject[]
            {
                new CustomObject(1),
                new CustomObject(1),
                new CustomObject(3),
                new CustomObject(4),
                new CustomObject(5)
            };

            InsertionSort<CustomObject> customSorter = new InsertionSort<CustomObject>();
            customSorter.Sort(array);

            Assert.AreEqual(expected, array);
        }

        private class CustomObject : IComparable<CustomObject>
        {
            public int Value { get; }

            public CustomObject(int value)
            {
                Value = value;
            }

            public int CompareTo(CustomObject other)
            {
                return Value.CompareTo(other.Value);
            }

            public override bool Equals(object obj)
            {
                return obj is CustomObject other && Value == other.Value;
            }

            public override int GetHashCode()
            {
                return Value.GetHashCode();
            }
        }
    }
}
